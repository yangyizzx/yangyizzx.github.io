<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>DFS/BFS刷题指南</title>
    <url>/2021/09/24/DFS-BFS%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>总结：</p>
<ol>
<li>BFS问题与<code>队列Queue</code>分不开。</li>
<li>DFS问题与<code>栈Stack</code>分不开。</li>
</ol>
<span id="more"></span>

<h4 id="LeetCode-617-合并二叉树"><a href="#LeetCode-617-合并二叉树" class="headerlink" title="LeetCode 617. 合并二叉树"></a>LeetCode <a href="https://leetcode-cn.com/problems/merge-two-binary-trees/">617. 合并二叉树</a></h4><blockquote>
<p>「方法一」DFS</p>
</blockquote>
<pre><code class="java">class Solution &#123;
    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) &#123;
        if(root1 == null) return root2;
        if(root2 == null) return root1;
        root1.val = root1.val+root2.val;
        root1.left = mergeTrees(root1.left,root2.left);
        root1.right = mergeTrees(root1.right,root2.right);
        return root1;
    &#125;
&#125;
</code></pre>
<h4 id="LeetCode-116-填充每个节点的下一个右侧节点指针"><a href="#LeetCode-116-填充每个节点的下一个右侧节点指针" class="headerlink" title="LeetCode 116. 填充每个节点的下一个右侧节点指针"></a>LeetCode <a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/">116. 填充每个节点的下一个右侧节点指针</a></h4><blockquote>
<p>「方法一」DFS</p>
</blockquote>
<pre><code class="java">class Solution &#123;
    public Node connect(Node root) &#123;
        if(root == null) return null;
        dfs(root);
        return root;
    &#125;

    public void dfs(Node node)&#123;
        if(node.left != null)&#123;
            node.left.next = node.right;
            if(node.next != null)&#123;
                node.right.next = node.next.left;
            &#125;
        &#125;
        if(node.left != null) dfs(node.left);
        if(node.right != null) dfs(node.right);
    &#125;
&#125;
</code></pre>
<blockquote>
<p>「方法二」BFS</p>
</blockquote>
<pre><code class="java">class Solution &#123;
    public Node connect(Node root) &#123;
        if(root == null) return null;
        Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;();
        queue.offer(root);
        while(!queue.isEmpty())&#123;
            int n = queue.size();

            for(int i = 0;i &lt; n;i++)&#123;
                Node node = queue.poll();
                if(i &lt; n - 1)&#123;
                    node.next = queue.peek();
                &#125;
                if(node.left != null)&#123;
                    queue.offer(node.left);
                &#125;
                if(node.right != null)&#123;
                    queue.offer(node.right);
                &#125;
            &#125;
            
        &#125;
        return root;
    &#125;
&#125;
</code></pre>
<h4 id="LeetCode-542-01-矩阵"><a href="#LeetCode-542-01-矩阵" class="headerlink" title="LeetCode 542. 01 矩阵"></a>LeetCode <a href="https://leetcode-cn.com/problems/01-matrix/">542. 01 矩阵</a></h4><blockquote>
<p>「方法一」BFS</p>
</blockquote>
<pre><code class="java">class Solution &#123;
    public int[][] updateMatrix(int[][] mat) &#123;

        int[] dx = &#123;1,0,0,-1&#125;;
        int[] dy = &#123;0,1,-1,0&#125;;
        //模拟队列
        Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;();

        int rn = mat.length;
        int cn = mat[0].length;

        //初始化队列、二维数组
        for(int i = 0; i &lt; rn; i++)&#123;
            for(int j = 0; j &lt; cn; j++)&#123;
                if(mat[i][j] == 0)&#123;
                    queue.offer(new int[]&#123;i,j&#125;);
                &#125;else&#123;
                    mat[i][j] = -1;
                &#125;
            &#125;
        &#125;

        while(!queue.isEmpty())&#123;
            int[] cell = queue.poll();
            int x = cell[0];
            int y = cell[1];
            for(int i = 0; i &lt; 4; i++)&#123;
                int newX = x + dx[i];
                int newY = y + dy[i];
                //当遇到未处理的位置
                if(newX &gt;= 0 &amp;&amp; newX &lt; rn &amp;&amp; newY &gt;= 0 &amp;&amp; newY &lt; cn &amp;&amp; mat[newX][newY] == -1)&#123;
                    //设置位置信息并且将该位置加入队列
                    queue.offer(new int[]&#123;newX,newY&#125;);
                    mat[newX][newY] = mat[x][y] + 1;
                &#125;
            &#125;
        &#125;
        return mat;

    &#125;
&#125;
</code></pre>
<blockquote>
<p>「方法二」DP（还没研究，再嗦）</p>
</blockquote>
<h4 id="LeetCode-994-腐烂的橘子"><a href="#LeetCode-994-腐烂的橘子" class="headerlink" title="LeetCode 994. 腐烂的橘子"></a>LeetCode <a href="https://leetcode-cn.com/problems/rotting-oranges/">994. 腐烂的橘子</a></h4><blockquote>
<p>「方法一」BFS</p>
</blockquote>
<pre><code class="java">class Solution &#123;
    public int orangesRotting(int[][] grid) &#123;
        int[] dx = &#123;1,0,0,-1&#125;;
        int[] dy = &#123;0,1,-1,0&#125;;

        int rn = grid.length;
        int cn = grid[0].length;

        Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();
        Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();

        for(int i = 0; i &lt; rn; i++)&#123;
            for(int j = 0; j &lt; cn; j++)&#123;
                if(grid[i][j] == 2)&#123;
                    int rc = i * cn + j;
                    queue.offer(rc);
                    map.put(rc,0);
                &#125;
            &#125;
        &#125;

        int ans = 0;
        while(!queue.isEmpty())&#123;
            int rc = queue.poll();
            int x = rc / cn;
            int y = rc % cn;
            for(int i = 0; i &lt; 4; i++)&#123;
                int newX = x + dx[i];
                int newY = y + dy[i];
                if(newX &gt;= 0 &amp;&amp; newX &lt; rn &amp;&amp; newY &gt;= 0 &amp;&amp; newY &lt; cn &amp;&amp; grid[newX][newY] == 1 )&#123;
                    int newRc = newX * cn + newY;
                    queue.offer(newRc);
                    grid[newX][newY] = 2;
                    map.put(newRc ,map.get(rc) + 1);      
                    ans = map.get(newRc);         
                &#125;
            &#125;
        &#125;

        for(int[] nums:grid)&#123;
            for(int num: nums)&#123;
                if(num == 1)   return -1;
            &#125;
        &#125;

        return ans;
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>DFS/BFS</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap-Hashtable-ConcurrentHashMap</title>
    <url>/2021/09/24/HashMap-Hashtable-ConcurrentHashMap/</url>
    <content><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/58621094">原文链接</a></p>
<span id="more"></span>

]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo基本使用</title>
    <url>/2021/09/07/Hexo%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="初始化博客"><a href="#初始化博客" class="headerlink" title="初始化博客"></a>初始化博客</h2><p> <code>hexo init</code> 文件夹名称</p>
<h2 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h2><p> <code>hexo new</code> 文章名称<br>(或者)<br> <code>hexo n</code> 文章名称</p>
<h2 id="在线预览"><a href="#在线预览" class="headerlink" title="在线预览"></a>在线预览</h2><p> <code>hexo server</code><br>(或者)<br><code>hexo s</code></p>
<h2 id="一键部署"><a href="#一键部署" class="headerlink" title="一键部署"></a>一键部署</h2><p> <code>hexo deploy</code><br>(或者)<br> <code>hexo d</code></p>
<h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><p>git clone <a href="https://github.com/litten/hexo-theme-yilia.git">https://github.com/litten/hexo-theme-yilia.git</a> themes&#x2F;yilia</p>
<p>hexo clean</p>
<p>hexo g</p>
<p>hexo s  localhost:4000查看</p>
<p><code>hexo d</code> 推到GitHub远端</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>—    #安装Nodejs<br>node -v    #查看node版本<br>npm -v    #查看npm版本<br>npm install -g cnpm –registry&#x3D;<a href="http://registry.npm.taobao.org/">http://registry.npm.taobao.org</a>    #安装淘宝的cnpm 管理器<br>cnpm -v    #查看cnpm版本<br>cnpm install -g hexo-cli    #安装hexo框架<br>hexo -v    #查看hexo版本<br>mkdir blog    #创建blog目录<br>cd blog     #进入blog目录<br>sudo hexo init     #生成博客 初始化博客<br>hexo s    #启动本地博客服务<br><a href="http://localhost:4000/">http://localhost:4000/</a>    #本地访问地址<br>hexo n 我的第一篇文章 #创建新的文章<br>#返回blog目录<br>hexo clean #清理<br>hexo g #生成<br>#Github创建一个新的仓库 YourGithubName.github.io<br>cnpm install –save hexo-deployer-git #在blog目录下安装git部署插件</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo的基本使用</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/09/07/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;
</code></pre>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server
</code></pre>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate
</code></pre>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy
</code></pre>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>Hello</category>
      </categories>
  </entry>
  <entry>
    <title>img-test.md</title>
    <url>/2022/02/24/img-test-md/</url>
    <content><![CDATA[<span id="more"></span>

<p><img src="/2022/02/24/img-test-md/1%EF%BC%887%EF%BC%89.png" alt="图片测试"></p>


<p><img src="/2022/02/24/img-test-md/v2-52220b2dba6901ee2181b72951d25a7b_r.jpg" alt="preview"></p>
]]></content>
      <categories>
        <category>img</category>
      </categories>
  </entry>
  <entry>
    <title>【Hexo】github开启令牌验证后无法更新Blog的问题</title>
    <url>/2022/02/10/%E3%80%90Hexo%E3%80%91github%E5%BC%80%E5%90%AF%E4%BB%A4%E7%89%8C%E9%AA%8C%E8%AF%81%E5%90%8E%E6%97%A0%E6%B3%95%E6%9B%B4%E6%96%B0Blog%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>从2021年8月13日起， github不再支持帐号密码验证Git操作，改用token(令牌)或SSH密钥。</p>
<p><a href="https://nokiasonic.github.io/2021/08/30/%E3%80%90Hexo%E3%80%91github%E5%BC%80%E5%90%AF%E4%BB%A4%E7%89%8C%E9%AA%8C%E8%AF%81%E5%90%8E%E6%97%A0%E6%B3%95%E6%9B%B4%E6%96%B0Blog%E7%9A%84%E9%97%AE%E9%A2%98/">原文链接</a></p>
<span id="more"></span>

<p><img src="https://gitee.com/nokiasonic/pic/raw/master/img/20210830140625.png" alt="img"></p>
<p><strong>解决方案</strong></p>
<ol>
<li>在<code>github</code>中注册一个<code>token令牌</code>：首先登入Github 账户，<code>Setting - Developer settings - Personal access tokens - Generate new token</code>, Note 填写 Hexo 或 Blog 之类，勾选第一项 repo，然后 Generate token；为Hexo项目生成一个令牌。</li>
<li>在<code>Hexo配置文件</code>中修改<code>_config.yml</code>：</li>
</ol>
<pre><code class="yaml"># Deployment
## Docs: https://hexo.io/docs/one-command-deployment
deploy:
  type: &#39;git&#39;
  repo: https://[复制生成的token]@github.com/nokiasonic/nokiasonic.github.io.git
  branch: main
</code></pre>
<p>即可正常hexo d更新blog。</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>个人博客</tag>
        <tag>技术问题解决</tag>
      </tags>
  </entry>
  <entry>
    <title>【计算机网络】HTTP知识</title>
    <url>/2022/02/20/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%91HTTP%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>二分查找详解</title>
    <url>/2021/09/12/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/binary-search/solution/er-fen-cha-zhao-xiang-jie-by-labuladong/">原文链接:二分查找细节详解  –LeetCode labuladong</a></p>
<p>相关题目:</p>
<p><a href="https://leetcode-cn.com/problems/binary-search/">LeetCode 704. 二分查找</a></p>
<p><a href="https://leetcode-cn.com/problems/first-bad-version/">LeetCode 278. 第一个错误的版本</a></p>
<p><a href="https://leetcode-cn.com/problems/search-insert-position/">LeetCode 35. 搜索插入位置</a></p>
<p><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">LeetCode 34. 在排序数组中查找元素的第一个和最后一个位置</a></p>
<p><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/">LeetCode 153. 寻找旋转排序数组中的最小值</a></p>
<p><a href="https://leetcode-cn.com/problems/find-peak-element/">LeetCode 162. 寻找峰值</a></p>
<p>注意：</p>
<ol>
<li>模板的左右初始值细节很重要，但是<strong>应用时要注意根据具体情况取左右初始值和循环条件</strong>！！</li>
</ol>
<span id="more"></span>

<p>本人懒狗一枚，详解可以看看上面链接，hhhhh。</p>
<h4 id="寻找一个数（基本的二分搜索）"><a href="#寻找一个数（基本的二分搜索）" class="headerlink" title="寻找一个数（基本的二分搜索）"></a>寻找一个数（基本的二分搜索）</h4><pre><code class="java">class Solution &#123;
    public int search(int[] nums, int target) &#123;
        int left = 0;
        int right = nums.length - 1;    //这里-1时，while循环条件得加上=
        while(left &lt;= right)&#123;            //注意
            int mid = left + (right - left) / 2; //防止了 left 和 right 太大直接相加导致溢出
            if(target == nums[mid])&#123;
                return mid;
            &#125;else if(target &lt; nums[mid])&#123;
                //如果right初始化为nums.length - 1，这里应该为mid-1;
                right = mid - 1;        
            &#125;else if(target &gt; nums[mid])&#123;
                left = mid + 1;            //注意
            &#125;
        &#125;
        return -1;
    &#125;
&#125;
</code></pre>
<h4 id="寻找左侧边界的二分搜索"><a href="#寻找左侧边界的二分搜索" class="headerlink" title="寻找左侧边界的二分搜索"></a>寻找左侧边界的二分搜索</h4><pre><code class="java">public int search(int[] nums, int target) &#123;
        int left = 0,right = nums.length;
        while(left &lt; right)&#123;
            int mid = left + (right - left) / 2;
            //寻找左、右侧边界的二分搜索要注意
            //收紧边界时的条件很重要，
            //这里right = mid ，并且循环结束的条件是 right = left
            //所以循环结束是 right = mid = left
            if(target == nums[mid])&#123;
                right = mid;
            &#125;else if(target &lt; nums[mid])&#123;
                right = mid;
            &#125;else if(target &gt; nums[mid])&#123;
                left = mid + 1;
            &#125;
        &#125;
        if(left &gt;= nums.length || nums[left] != target) return -1;
        return left;
    &#125;
</code></pre>
<h4 id="寻找右侧边界的二分搜索"><a href="#寻找右侧边界的二分搜索" class="headerlink" title="寻找右侧边界的二分搜索"></a>寻找右侧边界的二分搜索</h4><pre><code class="java">public int search(int[] nums, int target) &#123;
        int left = 0,right = nums.length;
        while(left &lt; right)&#123;
            int mid = left + (right - left) / 2;
            if(target == nums[mid])&#123;
                //收紧边界时的条件很重要，
                //这里left = mid + 1;并且循环结束的条件是 right = left
                //所以循环结束是 mid = left - 1 = right - 1；
                left = mid + 1;
            &#125;else if(target &lt; nums[mid])&#123;
                right = mid;
            &#125;else if(target &gt; nums[mid])&#123;
                left = mid + 1;
            &#125;
        &#125;
        if(right - 1 &lt; 0 || nums[right - 1] != target) return -1;
        return right -1;
    &#125;
</code></pre>
<h4 id="LeetCode-153-寻找旋转排序数组中的最小值"><a href="#LeetCode-153-寻找旋转排序数组中的最小值" class="headerlink" title="LeetCode 153. 寻找旋转排序数组中的最小值"></a>LeetCode 153. 寻找旋转排序数组中的最小值</h4><blockquote>
<p>思路：根据左值，中值，右值的大小关系分类讨论.</p>
<p>其中符合数组规律的大小关系如下:</p>
</blockquote>
<blockquote>
<p>​        右            中值 &lt; 右值 ， 缩小右边界</p>
<p>​    中</p>
<p>左    </p>
<hr>
<p>​    中                中值 &gt; 右值 ， 缩小左边界</p>
<p>左</p>
<p>​        右</p>
<hr>
<p>左                    中值 &lt; 右值 ,    缩小右边界</p>
<p>​        右</p>
<p>​    中</p>
</blockquote>
<pre><code class="java">class Solution &#123;
    public int findMin(int[] nums) &#123;
        int left = 0,right = nums.length - 1;
        while(left &lt; right)&#123;
            int mid = (left + right) / 2;
            if(nums[mid] &lt; nums[right])&#123;
                right = mid;
            &#125;else&#123;
                left = mid + 1;
            &#125;
        &#125;
        return nums[left];
    &#125;
&#125;
</code></pre>
<h4 id="LeetCode-162-寻找峰值"><a href="#LeetCode-162-寻找峰值" class="headerlink" title="LeetCode 162. 寻找峰值"></a>LeetCode 162. 寻找峰值</h4><blockquote>
<p>根据左右指针计算中间位置 m，并比较 m 与 m+1 的值，如果 m 较大，则左侧存在峰值，r &#x3D; m，如果 m + 1 较大，则右侧存在峰值，l &#x3D; m + 1.</p>
</blockquote>
<pre><code class="java">class Solution &#123;
    public int findPeakElement(int[] nums) &#123;
        int left = 0,right = nums.length - 1;
        while(left &lt; right)&#123;
            int mid = (left + right) / 2;
            if(nums[mid] &gt; nums[mid + 1])&#123;
                right = mid;
            &#125;else&#123;
                left = mid + 1;
            &#125;
        &#125;
        return left;

    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>二分查找</tag>
        <tag>模板题</tag>
      </tags>
  </entry>
  <entry>
    <title>创建线程的方式</title>
    <url>/2021/09/24/%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/58821827">原文链接</a></p>
<span id="more"></span>

<p>我们常说的方式有以下三种：</p>
<blockquote>
<p>继承Thread<br>实现Runable接口<br>实现Callable接口（可以获取线程执行之后的返回值）</p>
</blockquote>
<p>但实际后两种，更准确的理解是创建了一个可执行的任务，要采用多线程的方式执行，</p>
<p>还需要通过创建Thread对象来执行，比如 new Thread(new Runnable(){}).start();这样的方式来执行。</p>
<p>在实际开发中，我们通常采用线程池的方式来完成Thread的创建，更好管理线程资源。</p>
<p>案例：如何正确启动线程</p>
<pre><code class="java">class MyThread extends Thread&#123;
    @Override
    public void run() &#123;
        System.out.println(Thread.currentThread().getName()+&quot;:running......&quot;);
    &#125;
&#125;

public static void main(String[] args) &#123;
    MyThread thread = new MyThread();
    //正确启动线程的方式
    //thread.run();     //调用run方法并非开启线程
    thread.start();
&#125;
</code></pre>
<p>案例：实现runnable只是创建了一个可执行任务，并不是一个线程</p>
<pre><code class="java">class MyTask implements Runnable&#123;
    @Override
    public void run() &#123;
        System.out.println(Thread.currentThread().getName()+&quot;:running......&quot;);
    &#125;
&#125;

public static void main(String[] args) &#123;
    MyTask task = new MyTask();
    //task.start();     //并不能直接以线程的方式来启动
    new Thread(task).start();
&#125;
</code></pre>
<p>案例三：runnable vs callable</p>
<pre><code class="java">class MyTask2 implements Callable&lt;String&gt;&#123;
    @Override
    public String call() throws Exception &#123;
        return Thread.currentThread().getName() + &quot;:running......&quot;;
    &#125;
&#125;
// java5提供了Future接口来代表Callable接口里的call()方法的返回值，并为Future接口提供了一个FutureTask实现类，该实现类实现了Future接口，并实现了Runnable接口，所以这样可以作为Thread的target。
//通过FutuerTask类的对象的get()方法来获取线程结束后的返回值
public static void main(String[] args) &#123;
    MyTask2 task2 = new MyTask2();
    FutureTask&lt;String&gt; futureTask = new FutureTask&lt;&gt;(task2);

    Thread thread1 = new Thread(futureTask,&quot;我是futureTask线程&quot;);
    thread1.start();
    try &#123;
        System.out.println(futureTask.get());
    &#125; catch (Exception e) &#123;
        e.printStackTrace();
    &#125;
&#125;
</code></pre>
<p>明确一点：</p>
<p><strong>本质上来说创建线程的方式就是继承Thread，就是线程池，内部也是创建好线程对象来执行任务。</strong></p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树遍历详解</title>
    <url>/2021/09/15/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<span id="more"></span>

<h4 id="LeetCode-144-二叉树的前序遍历"><a href="#LeetCode-144-二叉树的前序遍历" class="headerlink" title="LeetCode 144. 二叉树的前序遍历"></a>LeetCode <a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a></h4><blockquote>
<p>「方法一」递归</p>
</blockquote>
<pre><code class="java">    public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;
        List&lt;Integer&gt; preArr = new ArrayList&lt;&gt;();
        preorder(root,preArr);
        return preArr;
    &#125;

    public void preorder(TreeNode root,List&lt;Integer&gt; preArr)&#123;
        if(root == null) return;
        arr.add(root.val);
        preorder(root.left,preArr);
        preorder(root.right,preArr);
    &#125;
</code></pre>
<blockquote>
<p>「方法二」迭代</p>
</blockquote>
<pre><code class="java">    public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;
        if(root == null) return new ArrayList&lt;&gt;();
        List&lt;Integer&gt; preList = new ArrayList&lt;&gt;();
        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();
        stack.push(root);
        while(!stack.isEmpty())&#123;
            TreeNode node = stack.pop();
            preList.add(node.val);
            //因为出栈顺序是左子树，右子树
            //所以入栈时右子树应该先进，左子树后进。
            if(node.right != null)&#123;
                stack.push(node.right);
            &#125;
            if(node.left != null)&#123;
                stack.push(node.left);
            &#125;
        &#125;
        return preList;
    &#125;
</code></pre>
<h4 id="LeetCode-94-二叉树的中序遍历"><a href="#LeetCode-94-二叉树的中序遍历" class="headerlink" title="LeetCode 94. 二叉树的中序遍历"></a>LeetCode <a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></h4><blockquote>
<p>「方法一」递归</p>
</blockquote>
<pre><code class="java">    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;
        List&lt;Integer&gt; inList = new ArrayList&lt;&gt;();
        inorder(root,inList);
        return inList;
    &#125;

    public void inorder(TreeNode root,List&lt;Integer&gt; inList)&#123;
        if(root == null) return;
        if(root.left != null) inorder(root.left,inList);
        inList.add(root.val);
        inorder(root.right,inList);
    &#125;
</code></pre>
<blockquote>
<p>「方法二」迭代</p>
<ol>
<li>创建一个Stack，然后按 左 中 右的顺序输出节点。</li>
<li>尽可能的将这个节点的左子树压入Stack，此时栈顶的元素是最左侧的元素，其目的是找到一个最小单位的子树(也就是最左侧的一个节点)，并且在寻找的过程中记录了来源，才能返回上层,同时在返回上层的时候已经处理完毕左子树了。。</li>
<li>当处理完最小单位的子树时，返回到上层处理了中间节点。（如果把整个左中右的遍历都理解成子树的话，就是处理完 左子树-&gt;中间(就是一个节点)-&gt;右子树）</li>
<li>如果有右节点，其也要进行中序遍历。当整个左子树退栈的时候这个时候输出了该子树的根节点 2，之后输出中间节点 1。然后处理根节点为3右子树。</li>
</ol>
</blockquote>
<pre><code class="java">    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;
        if (root == null) return new ArrayList&lt;&gt;();
        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();
        TreeNode cur = root;
        while(!stack.isEmpty() || cur != null)&#123;
            while(cur != null)&#123;
                stack.push(cur);
                cur = cur.left;
            &#125;
            TreeNode node = stack.pop();
            list.add(node.val);
            if(node.right != null)&#123;
                cur = node.right;
            &#125;
        &#125;
        return list;
    &#125;
</code></pre>
<h4 id="LeetCode-145-二叉树的后序遍历"><a href="#LeetCode-145-二叉树的后序遍历" class="headerlink" title="LeetCode 145. 二叉树的后序遍历"></a>LeetCode <a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历</a></h4><blockquote>
<p>「方法一」递归</p>
</blockquote>
<pre><code class="java">    public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;
        if(root == null) return new ArrayList&lt;&gt;();
        List&lt;Integer&gt; postList = new ArrayList&lt;&gt;();
        postorder(root,postList);
        return postList;
    &#125;
    public void postorder(TreeNode root,List&lt;Integer&gt; postList)&#123;
        if(root.left != null) postorder(root.left,postList);
        if(root.right != null) postorder(root.right,postList);
        postList.add(root.val);
    &#125;
</code></pre>
<blockquote>
<p>「方法二」迭代(还没研究，再嗦)</p>
</blockquote>
<h4 id="LeetCode-102-二叉树的层序遍历"><a href="#LeetCode-102-二叉树的层序遍历" class="headerlink" title="LeetCode 102. 二叉树的层序遍历"></a>LeetCode <a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></h4><blockquote>
<p>使用队列模拟每一层</p>
</blockquote>
<pre><code class="java">/**
 Queue 前面的方法是Queue特有的方法，推荐使用前面的方法操作队列
 offer() add()        添加数据
 poll()  remove()    删除数据
 peek()  element()    返回第一个数据
 */
class Solution &#123;
    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;
        if(root == null) return new ArrayList&lt;&gt;();
        List&lt;List&lt;Integer&gt;&gt; ansList = new ArrayList&lt;&gt;();
        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
        queue.offer(root);
        while(!queue.isEmpty())&#123;
            //获取每次队列长度，因为循环中队列size()会改变
            int n = queue.size();
            List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
            for(int i = 0;i &lt; n;i++)&#123;
                TreeNode node = queue.poll();
                list.add(node.val);
                //入队前要判断是否存在左右节点。
                if(node.left != null)&#123;
                    queue.offer(node.left);
                &#125;
                if(node.right != null)&#123;
                    queue.offer(node.right);
                &#125;
            &#125;
            //将处理好的list加入ansList
            ansList.add(list);
        &#125;
        return ansList;
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>模板题</tag>
        <tag>数据结构</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划刷题指南</title>
    <url>/2021/09/17/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<span id="more"></span>

<h4 id="LeetCode-139-单词拆分"><a href="#LeetCode-139-单词拆分" class="headerlink" title="LeetCode 139. 单词拆分"></a>LeetCode <a href="https://leetcode-cn.com/problems/word-break/">139. 单词拆分</a></h4><ol>
<li><p><code>dp[i*]</code> 表示字符串 <code>s</code> 前 <code>i</code> 个字符组成的字符串 <code>s[0..i-1]</code> 是否能被空格拆分成若干个字典中出现的单词 </p>
</li>
<li><p>在前 <code>i</code> 个字符组成的字符串找个位置 <code>j</code> 将字符串切成  <code>s[0..j-1]</code> 和 <code>s[j...i-1]</code> ,因此只需判断 <code>dp[j]</code> 是否为 <code>true</code> 以及后续单词 <code>s[j...i-1]</code>是否存在于列表中。</p>
</li>
<li><p>得出公式：</p>
<p> ​                <code>dp[i]</code> &#x3D; <code>dp[j]</code> &amp;&amp; <code>checks( s[j...i-1] )</code>;</p>
</li>
<li><p>对于边界条件，我们定义 dp[0]&#x3D;true 表示空串且合法。</p>
</li>
</ol>
<pre><code class="java">    public boolean wordBreak(String s, List&lt;String&gt; wordDict) &#123;
        //dp[i] 表示字符串 s 前 i 个字符组成的字符串 s[0..i-1] 是否能被空格拆分成若干个字典中出现的单词
        HashSet&lt;String&gt; wordDictSet = new HashSet&lt;&gt;(wordDict);
        int n = s.length();
        boolean[] dp = new boolean[n + 1];
        dp[0] = true;
        for(int i = 1;i &lt;= n;i++)&#123;
            for(int j = 0;j &lt; i;j++)&#123;
                if(dp[j] &amp;&amp; wordDictSet.contains(s.substring(j,i)))&#123;
                    dp[i] = true;
                    break;
                &#125;
            &#125;
        &#125;
        return dp[n];
    &#125;
</code></pre>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>位运算刷题指南</title>
    <url>/2021/09/16/%E4%BD%8D%E8%BF%90%E7%AE%97%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<span id="more"></span>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>双指针指南</title>
    <url>/2021/09/13/%E5%8F%8C%E6%8C%87%E9%92%88%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>原题链接：</p>
<p><a href="https://leetcode-cn.com/problems/squares-of-a-sorted-array/">LeetCode 977. 有序数组的平方</a></p>
<p><a href="https://leetcode-cn.com/problems/rotate-array/">LeetCode 189. 旋转数组</a></p>
<span id="more"></span>

<h4 id="LeetCode-977-有序数组的平方"><a href="#LeetCode-977-有序数组的平方" class="headerlink" title="LeetCode 977. 有序数组的平方"></a>LeetCode 977. 有序数组的平方</h4><pre><code class="java">class Solution &#123;
    public int[] sortedSquares(int[] nums) &#123;
        int n = nums.length;
        int[] ans = new int[n];
        int pos = n - 1;
        for(int i = 0,j = n-1;i &lt;= j;pos--)&#123;
            if(nums[i] * nums[i] &gt; nums[j] * nums[j])&#123;
                ans[pos] = nums[i] * nums[i];
                i ++;
            &#125;else&#123;
                ans[pos] = nums[j] * nums[j];
                j --;
            &#125;
        &#125;
        return ans;
    &#125;
&#125;
</code></pre>
<h4 id="LeetCode-189-旋转数组"><a href="#LeetCode-189-旋转数组" class="headerlink" title="LeetCode 189. 旋转数组"></a>LeetCode 189. 旋转数组</h4><blockquote>
<p>方法一：使用额外数组</p>
</blockquote>
<pre><code class="java">    public void rotate(int[] nums, int k) &#123;
        int len = nums.length;
        int[] ans = new int[len];
        for(int i = 0; i &lt; len ;i++)&#123;
            ans[(i + k) % len] = nums[i];
        &#125;
        //复制数组
        System.arraycopy(ans,0,nums,0,len);
    &#125;
</code></pre>
<blockquote>
<p>方法二：环状替换</p>
</blockquote>
<blockquote>
<p>方法三：数组翻转</p>
</blockquote>
<p>原理：</p>
<table>
<thead>
<tr>
<th align="left">操作</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td align="left">原始数组</td>
<td>1 2 3 4 5 6 7</td>
</tr>
<tr>
<td align="left">翻转所有元素</td>
<td>7 6 5 4 3 2 1</td>
</tr>
<tr>
<td align="left">翻转[ 0 , k-1 ]内的元素</td>
<td>5 6 7 4 3 2 1</td>
</tr>
<tr>
<td align="left">翻转[ k-1 , len-1 ]内的元素</td>
<td>5 6 7 1 2 3 4</td>
</tr>
</tbody></table>
<pre><code class="java">    public void rotate(int[] nums, int k) &#123;
        int n = nums.length;
        k %= n;
        reverse(nums,0,n-1);
        reverse(nums,0,k-1);
        reverse(nums,k,n-1);
    &#125;

    public void reverse(int[] nums, int start,int end)&#123;
        while(start &lt; end)&#123;
            int temp = nums[start];
            nums[start] = nums[end];
            nums[end] = temp;
            start++;
            end--;
        &#125;
    &#125;
</code></pre>
<h4 id="LeetCode-283-移动零"><a href="#LeetCode-283-移动零" class="headerlink" title="LeetCode 283. 移动零"></a>LeetCode 283. 移动零</h4><blockquote>
<p>方法一：覆盖前面的值，后续补零</p>
</blockquote>
<pre><code class="java">    public void moveZeroes(int[] nums) &#123;
        int j = 0;
        for(int i = 0;i &lt; nums.length;i++)&#123;
            if(nums[i] != 0)&#123;
                nums[j++] = nums[i];
            &#125;
        &#125;
        for(int i = j;i &lt; nums.length;i++)&#123;
            nums[i] = 0;
        &#125;
    &#125;
</code></pre>
<blockquote>
<p>方法二：双指针</p>
</blockquote>
<pre><code class="java">    public void moveZeroes(int[] nums) &#123;
        //left指向已处理好的序列尾部
        //right指向待处理的序列头部
        int n = nums.length,left = 0,right = 0;
        while(right &lt; n)&#123;
            if(nums[right] != 0)&#123;
                swap(nums,left,right);
                left++;
            &#125;
            right++;
        &#125;
    &#125;

    public void swap(int[] nums,int i,int j)&#123;
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    &#125;
</code></pre>
<h4 id="LeetCode-167-两数之和-II-输入有序数组"><a href="#LeetCode-167-两数之和-II-输入有序数组" class="headerlink" title="LeetCode 167. 两数之和 II - 输入有序数组"></a>LeetCode 167. 两数之和 II - 输入有序数组</h4><pre><code class="java">    public int[] twoSum(int[] numbers, int target) &#123;
        if(numbers.length == 2) return new int[]&#123;1,2&#125;;
        int n = numbers.length;
        int[] ans = new int[2];
        int left = 0;
        int right = n-1;
        while(left &lt; right)&#123;
            if(numbers[left] + numbers[right] == target)&#123;
                ans[0] = left+1;
                ans[1] = right+1;
                return ans;
            &#125;else if(numbers[left] + numbers[right] &gt; target)&#123;
                right --;
            &#125;else&#123;
                left ++;
            &#125;
        &#125;
        return ans;
    &#125;
</code></pre>
<h4 id="LeetCode-344-反转字符串"><a href="#LeetCode-344-反转字符串" class="headerlink" title="LeetCode 344. 反转字符串"></a>LeetCode 344. 反转字符串</h4><pre><code class="java">    public void reverseString(char[] s) &#123;
        int left = 0;
        int right = s.length - 1;
        while(left &lt; right)&#123;
            swap(s,left++,right--);
        &#125;
    &#125;

    public void swap(char[] s,int i,int j)&#123;
        char temp = s[i];
        s[i] = s[j];
        s[j] = temp;
    &#125;
</code></pre>
<h4 id="LeetCode-557-反转字符串中的单词-III"><a href="#LeetCode-557-反转字符串中的单词-III" class="headerlink" title="LeetCode 557. 反转字符串中的单词 III"></a>LeetCode 557. 反转字符串中的单词 III</h4><h4 id="LeetCode-876-链表的中间结点"><a href="#LeetCode-876-链表的中间结点" class="headerlink" title="LeetCode 876. 链表的中间结点"></a>LeetCode <a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/">876. 链表的中间结点</a></h4><blockquote>
<p>快慢指针</p>
</blockquote>
<pre><code class="java">    public ListNode middleNode(ListNode head) &#123;
        if(head == null) return null;
        ListNode fast = head,slow = head;
        //当链表长度是偶数时，需要判断fast.next,如果fast.next == null 说明fast已经走到链表尾端
        while(fast != null &amp;&amp; fast.next != null)&#123;
            fast = fast.next.next;
            slow = slow.next;
        &#125;
        return slow;
    &#125;
</code></pre>
<h4 id="LeetCode-19-删除链表的倒数第-N-个结点"><a href="#LeetCode-19-删除链表的倒数第-N-个结点" class="headerlink" title="LeetCode 19. 删除链表的倒数第 N 个结点"></a>LeetCode <a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></h4><blockquote>
<p>快慢指针</p>
<ol>
<li>将快指针start、慢指针end指向预先节点dummy</li>
<li>start先走n个节点，然后start，end一起走</li>
<li>当start走到链表最后一个节点时，end就到了链表倒数第 n + 1 个节点。</li>
</ol>
</blockquote>
<pre><code class="java">    public ListNode removeNthFromEnd(ListNode head, int n) &#123;
        if(head.next == null) return null;
        //防止head节点被删除，设置预先节点指向head
        ListNode dummy = new ListNode();
        dummy.next = head;
        ListNode start = dummy;
        ListNode end = dummy;
        for(int i = 0;i &lt; n;i++)&#123;
            start = start.next;
        &#125;
        while(start.next != null)&#123;
            start = start.next;
            end = end.next;
        &#125;
        end.next = end.next.next;
        return dummy.next;
    &#125;
</code></pre>
<h4 id="LeetCode-11-盛最多水的容器"><a href="#LeetCode-11-盛最多水的容器" class="headerlink" title="LeetCode 11. 盛最多水的容器"></a>LeetCode <a href="https://leetcode-cn.com/problems/container-with-most-water/">11. 盛最多水的容器</a></h4><blockquote>
<p>双指针</p>
<ol>
<li>初始化： 双指针 i , j 分列水槽左右两端；</li>
<li>循环收窄： 直至双指针相遇时跳出；</li>
<li>更新面积最大值 res ；</li>
<li>选定两板高度中的短板，向中间收窄一格；</li>
<li>返回值： 返回面积最大值 res 即可；</li>
</ol>
</blockquote>
<pre><code class="java">    public int maxArea(int[] height) &#123;
        int res = 0;        //结果
        int S = 0;            //每次循环时的面积
        int i = 0,j = height.length - 1;
        while(i &lt; j)&#123;
            S = Math.min(height[i],height[j]) * (j - i);
            res = Math.max(res,S);
            //选择移动的指针
            if(height[i] &lt; height[j])&#123;
                i++;
            &#125;else&#123;
                j--;
            &#125;
        &#125;
        return res;
    &#125;
</code></pre>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>双指针</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>我的第一篇博客文章</title>
    <url>/2021/09/07/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<p>#第一章<br>hhh</p>
<hr>
<p>#第二章<br>hhh</p>
<hr>
<p>#第三章<br><a href="http://www.baidu.com/">www.baidu.com</a></p>
]]></content>
      <categories>
        <category>test</category>
      </categories>
      <tags>
        <tag>test1</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统面经</title>
    <url>/2021/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E7%BB%8F/</url>
    <content><![CDATA[<!--mroe-->
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>岛屿问题专栏</title>
    <url>/2021/09/23/%E5%B2%9B%E5%B1%BF%E9%97%AE%E9%A2%98%E4%B8%93%E6%A0%8F/</url>
    <content><![CDATA[<p>针对岛屿问题的专栏</p>
<span id="more"></span>

<h4 id="LeetCode-733-图像渲染"><a href="#LeetCode-733-图像渲染" class="headerlink" title="LeetCode 733. 图像渲染"></a>LeetCode <a href="https://leetcode-cn.com/problems/flood-fill/">733. 图像渲染</a></h4><p><strong>做岛屿前可以先品一品这题，思路和解法都与岛屿问题很像。</strong></p>
<blockquote>
<p>「方法一」DFS</p>
</blockquote>
<pre><code class="java">class Solution &#123;
    int[] dx = &#123;1,0,0,-1&#125;;
    int[] dy = &#123;0,1,-1,0&#125;;

    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) &#123;
        if(newColor == image[sr][sc]) return image;
        int pastColor = image[sr][sc];
        dfs(image,sr,sc,newColor,pastColor);
        return image;
    &#125;

    public void dfs(int[][] image, int sr, int sc, int newColor,int pastColor)&#123;
        if(sr &lt; 0 || sr &gt;= image.length || sc &lt; 0 || sc &gt;= image[0].length || image[sr][sc] != pastColor) return;
        image[sr][sc] = newColor;
        for(int i = 0;i &lt; 4;i++)&#123;
            dfs(image,sr + dx[i],sc + dy[i],newColor,pastColor);
        &#125;
    &#125;
&#125;
</code></pre>
<blockquote>
<p>「方法二」BFS</p>
</blockquote>
<pre><code class="java">class Solution &#123;
    int[] dx = &#123;1,0,0,-1&#125;;
    int[] dy = &#123;0,1,-1,0&#125;;

    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) &#123;
        if(newColor == image[sr][sc]) return image;
        int pastColor = image[sr][sc];
        image[sr][sc] = newColor;
        Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;();
        queue.offer(new int[]&#123;sr,sc&#125;);
        while(!queue.isEmpty())&#123;
            int[] cell = queue.poll();
            for(int i = 0;i &lt; 4;i++)&#123;
                int x = cell[0] + dx[i];
                int y = cell[1] + dy[i];
                if(x &gt;= 0 &amp;&amp; x &lt; image.length &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; image[0].length &amp;&amp; image[x][y] == pastColor)&#123;
                    queue.offer(new int[]&#123;x,y&#125;);
                    image[x][y] = newColor;
                &#125;
            &#125;
        &#125;
        return image;
    &#125;
&#125;
</code></pre>
<h4 id="LeetCode-200-岛屿数量"><a href="#LeetCode-200-岛屿数量" class="headerlink" title="LeetCode 200. 岛屿数量"></a>LeetCode <a href="https://leetcode-cn.com/problems/number-of-islands/">200. 岛屿数量</a></h4><blockquote>
<p>「方法一」DFS</p>
</blockquote>
<pre><code class="java">class Solution &#123;
    public int numIslands(char[][] grid) &#123;
        int ans = 0;
        int rn = grid.length;
        int cn = grid[0].length;
        for(int i = 0; i &lt; rn ; i++)&#123;
            for(int j = 0 ; j &lt; cn ; j++)&#123;
                if(grid[i][j] == &#39;1&#39;)&#123;
                    ++ans;
                    dfs(grid,i,j);
                &#125;

            &#125;
        &#125;
        return ans;
    &#125;

    public void dfs(char[][] grid,int row,int col)&#123;
        if(row &lt; 0 || row &gt;= grid.length || col &lt; 0 || col &gt;=grid[0].length || grid[row][col] == &#39;0&#39;) return;

        grid[row][col] = &#39;0&#39;;
        dfs(grid,row + 1,col);
        dfs(grid,row - 1,col);
        dfs(grid,row,col + 1);
        dfs(grid,row,col - 1);
    &#125;
&#125;
</code></pre>
<blockquote>
<p>「方法二」BFS</p>
</blockquote>
<blockquote>
<p>「方法三」并查集（还没研究，再嗦）</p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>DFS/BFS</tag>
        <tag>LeetCode</tag>
        <tag>岛屿问题</tag>
      </tags>
  </entry>
  <entry>
    <title>滑动窗口刷题指南</title>
    <url>/2021/09/17/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>出现以下情况时，考虑滑动窗口：</p>
<ol>
<li>涉及到子串</li>
</ol>
<span id="more"></span>

<h4 id="LeetCode-3-无重复字符的最长子串"><a href="#LeetCode-3-无重复字符的最长子串" class="headerlink" title="LeetCode 3. 无重复字符的最长子串"></a>LeetCode <a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h4><h4 id="LeetCode-30-串联所有单词的子串"><a href="#LeetCode-30-串联所有单词的子串" class="headerlink" title="LeetCode 30. 串联所有单词的子串"></a>LeetCode <a href="https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/">30. 串联所有单词的子串</a></h4><h4 id="LeetCode-76-最小覆盖子串"><a href="#LeetCode-76-最小覆盖子串" class="headerlink" title="LeetCode 76. 最小覆盖子串"></a>LeetCode <a href="https://leetcode-cn.com/problems/minimum-window-substring/">76. 最小覆盖子串</a></h4><h4 id="LeetCode-159-至多包含两个不同字符的最长子串"><a href="#LeetCode-159-至多包含两个不同字符的最长子串" class="headerlink" title="LeetCode 159. 至多包含两个不同字符的最长子串"></a>LeetCode <a href="https://leetcode-cn.com/problems/longest-substring-with-at-most-two-distinct-characters/">159. 至多包含两个不同字符的最长子串</a></h4><h4 id="LeetCode-209-长度最小的子数组"><a href="#LeetCode-209-长度最小的子数组" class="headerlink" title="LeetCode 209. 长度最小的子数组"></a>LeetCode <a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/">209. 长度最小的子数组</a></h4><h4 id="LeetCode-239-滑动窗口最大值"><a href="#LeetCode-239-滑动窗口最大值" class="headerlink" title="LeetCode 239. 滑动窗口最大值"></a>LeetCode <a href="https://leetcode-cn.com/problems/sliding-window-maximum/">239. 滑动窗口最大值</a></h4><h4 id="LeetCode-567-字符串的排列"><a href="#LeetCode-567-字符串的排列" class="headerlink" title="LeetCode 567. 字符串的排列"></a>LeetCode <a href="https://leetcode-cn.com/problems/permutation-in-string/">567. 字符串的排列</a></h4><h4 id="LeetCode-632-最小区间"><a href="#LeetCode-632-最小区间" class="headerlink" title="LeetCode 632. 最小区间"></a>LeetCode <a href="https://leetcode-cn.com/problems/smallest-range/">632. 最小区间</a></h4><h4 id="LeetCode-727-最小窗口子序列"><a href="#LeetCode-727-最小窗口子序列" class="headerlink" title="LeetCode 727. 最小窗口子序列"></a>LeetCode <a href="https://leetcode-cn.com/problems/minimum-window-subsequence/">727. 最小窗口子序列</a></h4>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>背包问题</title>
    <url>/2021/10/24/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>程序员节刷<a href="https://leetcode-cn.com/problems/shopping-offers/">LeetCode每日一题(638)</a>，发现是个背包问题，无从下笔，决定仔细研究一番背包问题</p>
<span id="more"></span>

<h4 id="ACWing-2-01背包问题"><a href="#ACWing-2-01背包问题" class="headerlink" title="ACWing 2. 01背包问题"></a><a href="https://www.acwing.com/problem/content/2/">ACWing 2. 01背包问题</a></h4><p><img src="C:\Users\yangyi\Desktop\工作\images\1（7）.png" alt="1（7）"></p>
<pre><code class="java">import java.util.*;

public class Main&#123;
    final static int N = 1010;
    static int n,m;
    static int[] v = new int[N];//体积列表
    static int[] w = new int[N];//价值列表
    static int[][] dp = new int[N][N];
    
    public static void main(String[] args)&#123;
        Scanner sc = new Scanner(System.in);
        n = sc.nextInt();
        m = sc.nextInt();
        for(int i = 1 ; i &lt;= n; i++)&#123;
            v[i] = sc.nextInt();
            w[i] = sc.nextInt();
        &#125;
        for(int i = 1; i &lt;= n; i++)&#123;
            for(int j = 0; j &lt;= m; j++)&#123;
                if(j &lt; v[i])&#123;
                    dp[i][j] = dp[i-1][j];
                &#125;else&#123;
                    dp[i][j] = Math.max(dp[i-1][j],dp[i-1][j-v[i]] + w[i]);
                &#125;
            &#125;
        &#125;
        System.out.println(dp[n][m]);
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>模板题</tag>
        <tag>背包问题</tag>
        <tag>DP</tag>
        <tag>ACWing</tag>
      </tags>
  </entry>
  <entry>
    <title>数组刷题指南</title>
    <url>/2021/09/14/%E6%95%B0%E7%BB%84%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>原题链接：</p>
<p><a href="https://leetcode-cn.com/problems/contains-duplicate/">LeetCode 217. 存在重复元素</a></p>
<p><a href="https://leetcode-cn.com/problems/maximum-subarray/">LeetCode 53. 最大子序和</a></p>
<span id="more"></span>

<h4 id="LeetCode-217-存在重复元素"><a href="#LeetCode-217-存在重复元素" class="headerlink" title="LeetCode 217. 存在重复元素"></a>LeetCode 217. 存在重复元素</h4><blockquote>
<p>方法一：排序后查找</p>
</blockquote>
<pre><code class="java">    public boolean containsDuplicate(int[] nums) &#123;
        Arrays.sort(nums);
        for(int i = 0;i &lt; nums.length - 1;i++)&#123;
            if(nums[i] == nums[i+1])&#123;
                return true;
            &#125;
        &#125;
        return false;
    &#125;
</code></pre>
<blockquote>
<p>方法二：HashMap方法</p>
</blockquote>
<pre><code class="java">    public boolean containsDuplicate(int[] nums) &#123;
        Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();
        for(int num:nums)&#123;
            if(map.get(num) == null)&#123;
                map.put(num,1);
            &#125;else&#123;
                return true;
            &#125;
        &#125;
        return false;
    &#125;
</code></pre>
<h4 id="LeetCode-53-最大子序和"><a href="#LeetCode-53-最大子序和" class="headerlink" title="LeetCode 53. 最大子序和"></a>LeetCode 53. 最大子序和</h4><blockquote>
<p>方法一：动态规划</p>
</blockquote>
<pre><code class="java">    //原始递归
    public int maxSubArray(int[] nums) &#123;
        int ans = Integer.MIN_VALUE;
        for(int i = 0;i &lt; nums.length;i++)&#123;
            ans = Math.max(ans,dp(nums,i));
        &#125;
        return ans;
    &#125;
    //dp(i)表示以第i个数结尾的「连续子数组的最大和」
    public int dp(int[] nums,int i)&#123;
        if(i == 0) return nums[0];
        return Math.max(dp(nums,i - 1) + nums[i] , nums[i]);
    &#125;
</code></pre>
<pre><code class="java">    //改良版
    public int maxSubArray(int[] nums) &#123;
        int pre = 0;
        int ans = Integer.MIN_VALUE;
        for(int num:nums)&#123;
            pre = Math.max(pre + num , num );
            ans = Math.max(pre,ans);
        &#125;
        return ans;
    &#125;
</code></pre>
<blockquote>
<p>方法二：分治（还没研究，再嗦）</p>
</blockquote>
<h4 id="LeetCode-1-两数之和"><a href="#LeetCode-1-两数之和" class="headerlink" title="LeetCode 1. 两数之和"></a>LeetCode 1. 两数之和</h4><blockquote>
<p>使用HashMap存储数据查找第二个数</p>
</blockquote>
<pre><code class="java">    public int[] twoSum(int[] nums, int target) &#123;
        Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();
        for(int i = 0;i &lt; nums.length;i++)&#123;
            if(map.containsKey(target - nums[i]))&#123;
                return new int[]&#123;map.get(target - nums[i]),i&#125;;
            &#125;
            map.put(nums[i],i);
        &#125;
        return new int[]&#123;0,1&#125;;
    &#125;
</code></pre>
<h4 id="LeetCode-88-合并两个有序数组"><a href="#LeetCode-88-合并两个有序数组" class="headerlink" title="LeetCode 88. 合并两个有序数组"></a>LeetCode 88. 合并两个有序数组</h4><blockquote>
<p>使用双指针指向两个数组，开辟一个新数组，将数据存到新数组中。</p>
</blockquote>
<pre><code>    public void merge(int[] nums1, int m, int[] nums2, int n) &#123;
        int[] sorted = new int[m + n];
        int p1 = 0,p2 = 0;
        int cur;
        while(p1 &lt; m || p2 &lt; n)&#123;
            if(p1 == m)&#123;
                cur = nums2[p2++];
            &#125;else if(p2 == n)&#123;
                cur = nums1[p1++];
            &#125;else if(nums1[p1] &lt; nums2[p2])&#123;
                cur = nums1[p1++];
            &#125;else&#123;
                cur = nums2[p2++];
            &#125;
            sorted[p1 + p2 - 1] = cur;
        &#125;
        System.arraycopy(sorted,0,nums1,0,m+n);
    &#125;
</code></pre>
<h4 id="LeetCode-73-矩阵置零"><a href="#LeetCode-73-矩阵置零" class="headerlink" title="LeetCode 73. 矩阵置零"></a>LeetCode 73. 矩阵置零</h4><blockquote>
<p>使用matrix数组的第0行、第0列存储二维数组中的0的标志信息，但是在这之前要先判断第0行或第0列是否存在0，如果存在后续还需处理第0行、第0列。</p>
<p>时间复杂度：O(nm)</p>
<p>空间复杂度：O(1)</p>
</blockquote>
<pre><code class="java">class Solution &#123;
    public void setZeroes(int[][] matrix) &#123;
        //第0行或第0列是否存在0；
        Boolean flag_row0 = false;
        Boolean flag_col0 = false;
        int row = matrix.length;
        int col = matrix[0].length;
        //先判断第0行或第0列是否存在0
        for(int i = 0;i &lt; row;i++)&#123;
            if(matrix[i][0] == 0)&#123;
                flag_col0 = true;
            &#125;
        &#125;
        for(int j = 0;j &lt; col;j++)&#123;
            if(matrix[0][j] == 0)&#123;
                flag_row0 = true;
            &#125;
        &#125;
        //使用第0行，第0列标记
        for(int i = 1; i &lt; row;i++)&#123;
            for(int j = 1; j &lt; col;j++)&#123;
                if(matrix[i][j] == 0)&#123;
                    matrix[i][0] = matrix[0][j] = 0;
                &#125;
            &#125;
        &#125;
        //赋值0；
        for(int i = 1; i &lt; row;i++)&#123;
            for(int j = 1; j &lt; col;j++)&#123;
                if(matrix[i][0] == 0 || matrix[0][j] == 0)&#123;
                    matrix[i][j] = 0;
                &#125;
            &#125;
        &#125;
        if(flag_row0)&#123;
            for(int j = 0;j &lt; col;j++)&#123;
                matrix[0][j] = 0;
            &#125;
        &#125;
        if(flag_col0)&#123;
            for(int i = 0;i &lt; row;i++)&#123;
                matrix[i][0] = 0;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="LeetCode-121-买卖股票的最佳时机"><a href="#LeetCode-121-买卖股票的最佳时机" class="headerlink" title="LeetCode 121. 买卖股票的最佳时机"></a>LeetCode <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></h4><blockquote>
<p>方法一：和LeetCode 53. 最大子序和有点像。</p>
</blockquote>
<pre><code>    public int maxProfit(int[] prices) &#123;
        int maxAns = 0;
        //f(i)表示第i天买出可获得的最大利润
        int fi = 0;
        for(int i = 1;i &lt; prices.length;i++)&#123;
            if(i == 1)&#123;
                fi = Math.max(0,prices[i] - prices[i-1]);
            &#125;else&#123;
                fi = Math.max(fi+prices[i] - prices[i-1],prices[i] - prices[i-1]);
            &#125;
            maxAns = Math.max(fi,maxAns);
        &#125;
        return maxAns;
    &#125;
</code></pre>
<blockquote>
<p>方法二：前i天的最大收益 &#x3D; max{前i-1天的最大收益，第i天的价格-前i-1天中的最小价格}</p>
<ol>
<li>记录【今天之前买入的最小值】</li>
<li>计算【今天之前最小值买入，今天卖出的获利】，也即【今天卖出的最大获利】</li>
<li>比较【每天的最大获利】，取最大值即可</li>
</ol>
</blockquote>
<pre><code class="java">    public int maxProfit(int[] prices) &#123;
        int maxAns = 0;
        //记录【今天之前买入的最小值】
        int min = prices[0];
        for(int i = 1; i &lt; prices.length;i++)&#123;
            maxAns = Math.max(maxAns,prices[i] - min);
            min = Math.min(min,prices[i]);
        &#125;
        return maxAns;
    &#125;
</code></pre>
<h4 id="LeetCode-350-两个数组的交集-II"><a href="#LeetCode-350-两个数组的交集-II" class="headerlink" title="LeetCode 350. 两个数组的交集 II"></a>LeetCode <a href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/">350. 两个数组的交集 II</a></h4><blockquote>
<p>方法一：HashMap存储数组</p>
</blockquote>
<pre><code class="java">    public int[] intersect(int[] nums1, int[] nums2) &#123;
        Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();
        for(int num1:nums1)&#123;
            if(!map.containsKey(num1))&#123;
                map.put(num1,1);
            &#125;else&#123;
                map.put(num1,map.get(num1) + 1);
            &#125;
        &#125;
        List&lt;Integer&gt; ansList = new ArrayList&lt;&gt;();
        for(int num2:nums2)&#123;
            if(map.containsKey(num2) &amp;&amp; map.get(num2) &gt; 0)&#123;
                ansList.add(num2);
                map.put(num2,map.get(num2) - 1);
            &#125;
        &#125;
        int[] arr = new int[ansList.size()];
        for(int i = 0;i &lt; ansList.size();i++)&#123;
            arr[i] = ansList.get(i);
        &#125;
        return arr;
    &#125;
</code></pre>
<blockquote>
<p>方法二：排序+双指针</p>
</blockquote>
<pre><code>class Solution &#123;
    public int[] intersect(int[] nums1, int[] nums2) &#123;
        Arrays.sort(nums1);
        Arrays.sort(nums2);
        int p1 = 0,p2 = 0;
        ArrayList&lt;Integer&gt; ansList = new ArrayList&lt;&gt;();
        while(p1 &lt; nums1.length &amp;&amp; p2 &lt; nums2.length)&#123;
            if(nums1[p1] == nums2[p2])&#123;
                ansList.add(nums1[p1]);
                p1++;
                p2++;
            &#125;else if(nums1[p1] &lt; nums2[p2])&#123;
                p1++;
            &#125;else&#123;
                p2++;
            &#125;
        &#125;
        int[] ans = new int[ansList.size()];
        int i = 0;
        for(int an:ansList)&#123;
            ans[i++] = an;
        &#125;
        return ans;
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数据结构</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>算法工具函数汇总</title>
    <url>/2021/09/13/%E7%AE%97%E6%B3%95%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<p>将刷算法题中的遇到和用到的工具函数汇总。</p>
<span id="more"></span>

<h3 id="一、数学"><a href="#一、数学" class="headerlink" title="一、数学"></a>一、数学</h3><h4 id="判断一个数是否是2的n次方"><a href="#判断一个数是否是2的n次方" class="headerlink" title="判断一个数是否是2的n次方"></a>判断一个数是否是2的n次方</h4><pre><code class="java">    public boolean isPowerOfTwo(int n) &#123;
        return n &gt; 0 &amp;&amp; (n &amp; (n - 1)) == 0;
    &#125;
</code></pre>
<h4 id="求最大公约数和最小公倍数"><a href="#求最大公约数和最小公倍数" class="headerlink" title="求最大公约数和最小公倍数"></a>求最大公约数和最小公倍数</h4><pre><code class="java">    //最大公约数
    public int gcd(int x,int y)&#123;
        return y &gt; 0 ? gcd(y , x % y) : x;
    &#125;
    //最小公倍数
    public int lcm(int x,int y)&#123;
            return x / gdc(x, y) * y;
    &#125;
</code></pre>
<h3 id="二、数组操作"><a href="#二、数组操作" class="headerlink" title="二、数组操作"></a>二、数组操作</h3><h4 id="复制数组内容"><a href="#复制数组内容" class="headerlink" title="复制数组内容"></a>复制数组内容</h4><pre><code class="java">    //复制数组
    System.arraycopy(fromArr,0,toArr,0,len);
</code></pre>
<h4 id="排序二维数组"><a href="#排序二维数组" class="headerlink" title="排序二维数组"></a>排序二维数组</h4><pre><code class="java">    Arrays.sort(arr, (o1, o2) -&gt; Integer.compare(o1[0], o2[0]));
</code></pre>
<h4 id="List-lt-int-gt-转换为int"><a href="#List-lt-int-gt-转换为int" class="headerlink" title="List&lt;int[ ]&gt;转换为int[ ][ ]"></a>List&lt;int[ ]&gt;转换为int[ ][ ]</h4><pre><code class="java">    arr.toArray(new int[arr.size()][]);
</code></pre>
<h4 id="List-lt-String-gt-转换为String"><a href="#List-lt-String-gt-转换为String" class="headerlink" title="List&lt;String&gt;转换为String[]"></a>List&lt;String&gt;转换为String[]</h4><pre><code class="java">    arr.toArray(new String[arr.size()]);
</code></pre>
<h3 id="三、字符串操作"><a href="#三、字符串操作" class="headerlink" title="三、字符串操作"></a>三、字符串操作</h3><h4 id="String类型转换大小写"><a href="#String类型转换大小写" class="headerlink" title="String类型转换大小写"></a>String类型转换大小写</h4><pre><code class="java">    s = s.toLowerCase();//转小写
    s = s.toUpperCase();//转大写
</code></pre>
<h4 id="Character类型转换大小写"><a href="#Character类型转换大小写" class="headerlink" title="Character类型转换大小写"></a>Character类型转换大小写</h4><pre><code class="java">    ch = Character.toLowerCase(ch);
    ch = Character.toUpperCase(ch);
</code></pre>
<h3 id="四、位运算"><a href="#四、位运算" class="headerlink" title="四、位运算"></a>四、位运算</h3><h4 id="Java位运算相加-C-和Python需要额外处理负数"><a href="#Java位运算相加-C-和Python需要额外处理负数" class="headerlink" title="Java位运算相加(C++和Python需要额外处理负数)"></a>Java位运算相加(C++和Python需要额外处理负数)</h4><pre><code class="java">    public int add(int a, int b) &#123;
        return b == 0 ? a : add(a ^ b, (a &amp; b) &lt;&lt; 1);
    &#125;
</code></pre>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>工具函数</tag>
        <tag>汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络面经</title>
    <url>/2021/09/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E7%BB%8F/</url>
    <content><![CDATA[<span id="more"></span>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>谈谈对面向对象思想的理解</title>
    <url>/2021/09/25/%E8%B0%88%E8%B0%88%E5%AF%B9%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/52368590">原文链接</a></p>
<span id="more"></span>

<p>这个问题，通常会让很多人有点不知所措，感觉我一直在编码，但是说到思想很难去阐述。</p>
<p>下面，我说说自己的想法，</p>
<p>首先，谈谈“面向过程”vs“面向对象”</p>
<p>我觉得这两者是思考角度的差异，面向过程更多是以“执行者”的角度来思考问题，而面向对象更多是以“组织者”的角度来思考问题，举个例子，比如我要产生一个0-10之间的随机数，如果以“面向过程”的思维，那我更多是关注如何去设计一个算法，然后保证比较均衡产生0-10的随机数，而面向对象的思维会更多关注，我找谁来帮我们做这件事，比如Random类，调用其中提供的方法即可。</p>
<p>所以，面向对象的思维更多的是考虑如何去选择合适的工具，然后组织到一起干一件事。</p>
<p>好比一个导演，要拍一场电影，那么首先要有男猪脚和女猪脚，然后还有其他等等，最后把这些资源组织起来，拍成一场电影。</p>
<p>再说回我们的程序世界，这个组织者的思维无处不在，比如，我们要开发项目，以三层架构的模式来开发，那么这个时候，我们不需要重复造轮子，只需要选择市面上主流的框架即可，比如SpringMVC，Spring，MyBatis，这些都是各层的主流框架。</p>
<p>好了，今天就到这，大家可以自己再想很多这样的例子出来，每天一篇，持续更新</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo+Next个人博客优化</title>
    <url>/2021/09/13/Hexo+Next%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>Hexo版本：4.3.0</p>
<p>NexT版本：7.8.0</p>
<p>整合了网上的一些资料，写了这篇在上述版本能修改优化的文章，大家根据自身的环境进行修改。</p>
<span id="more"></span>

<h3 id="设置（更换）主题风格"><a href="#设置（更换）主题风格" class="headerlink" title="设置（更换）主题风格"></a>设置（更换）主题风格</h3><p>打开 <code>themes/next/_config.yml</code> 文件，搜索  <code>scheme</code> 关键字，将你需用启用的 <code>scheme</code> 前面注释 # 去除即可。</p>
<pre><code class="bash"># ---------------------------------------------------------------
# Scheme Settings
# ---------------------------------------------------------------

# Schemes
#scheme: Muse # 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白
#scheme: Mist # Muse 的紧凑版本，整洁有序的单栏外观
scheme: Pisces # 双栏 Scheme，小家碧玉似的清新
#scheme: Gemini # 类似 Pisces
</code></pre>
<h3 id="设置菜单项的显示文本和图标"><a href="#设置菜单项的显示文本和图标" class="headerlink" title="设置菜单项的显示文本和图标"></a>设置菜单项的显示文本和图标</h3><p>NexT 使用的是 <a href="http://fontawesome.dashgame.com/">Font Awesome</a>  提供的图标， <a href="http://fontawesome.dashgame.com/">Font Awesome</a> 提供了 600+ 的图标，可以满足绝大的多数的场景，同时无须担心在 Retina 屏幕下图标模糊的问题。</p>
<h4 id="设置菜单项的显示中文文本："><a href="#设置菜单项的显示中文文本：" class="headerlink" title="设置菜单项的显示中文文本："></a>设置菜单项的显示中文文本：</h4><p>打开 <code>themes/next/languages/zh-CN.yml</code> 文件,搜索 <code>menu</code> 关键字，修改对应中文或者新增。</p>
<pre><code class="bash">menu:
  home: 首页
  archives: 归档
  categories: 分类
  tags: 标签
  about: 关于
  search: 搜索
  schedule: 日程表
  sitemap: 站点地图
  commonweal: 公益404
  # 新增menu
  catalogue: 目录
</code></pre>
<p>修改<code>themes/next/_config.yml</code>文件，找到<code>language</code>项改为<code>zh-CN</code>。</p>
<p>同时回到博客根目录，打开<code>_config.yml</code>文件，找到<code>language</code>项改为<code>zh-CN</code>。</p>
<h4 id="设定菜单项的文件目录和对应图标（新版两项合并）"><a href="#设定菜单项的文件目录和对应图标（新版两项合并）" class="headerlink" title="设定菜单项的文件目录和对应图标（新版两项合并）"></a>设定菜单项的文件目录和对应图标（新版两项合并）</h4><p>打开 <code>themes/next/_config.yml</code> 文件，搜索    <code>menu_icons</code> 关键字，修改对应图标名称或者新增对应 <code>menu</code> 的图标。</p>
<pre><code class="yaml"># ---------------------------------------------------------------
# Menu Settings
# ---------------------------------------------------------------

# Usage: `Key: /link/ || icon`
# Key is the name of menu item. If the translation for this item is available, the translated text will be loaded, otherwise the Key name will be used. Key is case-senstive.
# Value before `||` delimiter is the target link, value after `||` delimiter is the name of Font Awesome icon.
# When running the site in a subdirectory (e.g. yoursite.com/blog), remove the leading slash from link value (/archives -&gt; archives).
# External url should start with http:// or https://
menu:
  home: / || fa fa-home
  about: /about/ || fa fa-user
  tags: /tags/ || fa fa-tags
  categories: /categories/ || fa fa-th
  archives: /archives/ || fa fa-archive
  #schedule: /schedule/ || fa fa-calendar
  #sitemap: /sitemap.xml || fa fa-sitemap
  commonweal: /404/ || fa fa-heartbeat

# Enable / Disable menu icons / item badges.
menu_settings:
  icons: true
  badges: false
</code></pre>
<p>除了 <code>home</code>， <code>archives</code> , <code>/</code>后面都需要手动创建这个页面</p>
<p><a href="https://blog.csdn.net/Awt_FuDongLai/article/details/107314881">如何创建新的页面？</a></p>
<h4 id="创建菜单项对应文件目录-以分类为例"><a href="#创建菜单项对应文件目录-以分类为例" class="headerlink" title="创建菜单项对应文件目录,以分类为例"></a>创建菜单项对应文件目录,以分类为例</h4><p>在终端窗口下，定位到 <code>Hexo</code> 站点目录下。使用 <code>hexo new page</code> 新建一个页面，命名为 categories ：</p>
<pre><code class="ruby">$ cd your-hexo-site
$ hexo new page categories
</code></pre>
<p>编辑刚新建的页面,设置分类</p>
<pre><code class="bash">---
title: 分类
date: 2014-12-22 12:39:04
categories: Testing #分类名 ??不理解什么意思
type: &quot;categories&quot;
---
</code></pre>
<h3 id="头像设置"><a href="#头像设置" class="headerlink" title="头像设置"></a>头像设置</h3><h4 id="添加头像"><a href="#添加头像" class="headerlink" title="添加头像"></a>添加头像</h4><p>打开 <code>themes/next/_config.yml</code> 文件，搜索  <code>Sidebar Avatar</code> 关键字，去掉 <code>avatar</code> 前面的<code>#</code>：</p>
<pre><code class="csharp"># Sidebar Avatar
# in theme directory(source/images): /images/avatar.jpg
# in site  directory(source/uploads): /uploads/avatar.jpg
avatar: http://example.com/avatar.png
</code></pre>
<p>或者使用本地图片,把图片放入 <code>themes/next/source/images</code> 下,修改 <code>avatar</code>：</p>
<pre><code class="jsx">avatar: /images/avatar.gif
</code></pre>
<h4 id="设置头像为圆形并且触碰旋转"><a href="#设置头像为圆形并且触碰旋转" class="headerlink" title="设置头像为圆形并且触碰旋转"></a>设置头像为圆形并且触碰旋转</h4><p>打开主题配置文件</p>
<blockquote>
<p>themes&#x2F;next&#x2F;_config.yml</p>
</blockquote>
<pre><code class="yaml"># Sidebar Avatar
avatar:
  # Replace the default image and set the url here.
  url: /images/avatar.gif
  # 新版本Hexo将下面下个设置为true，代码判断自动生效
  # If true, the avatar will be dispalyed in circle.
  rounded: true 
  # If true, the avatar will be rotated with the cursor.
  rotated: true
</code></pre>
<p><a href="https://crayonnew.github.io/2018/11/05/Hexo-NexT%E4%B8%BB%E9%A2%98-%E8%AE%BE%E7%BD%AE%E5%9C%86%E5%BD%A2%E5%A4%B4%E5%83%8F%E5%B9%B6%E6%97%8B%E8%BD%AC/">旧版Hexo设置</a></p>
<p>新版主题配置文件更换了位置(“&#x2F;themes&#x2F;next&#x2F;source&#x2F;css&#x2F;_common&#x2F;outline&#x2F;sidebar&#x2F;sidebar-author.styl”)</p>
<h3 id="浏览页面的时候显示当前浏览进度"><a href="#浏览页面的时候显示当前浏览进度" class="headerlink" title="浏览页面的时候显示当前浏览进度"></a>浏览页面的时候显示当前浏览进度</h3><p>打开 <code>themes/next/_config.yml</code> ,搜索关键字 <code>scrollpercent</code> ,把 <code>false</code> 改为 <code>true</code>。</p>
<pre><code class="bash">  # Scroll percent label in b2t button
  scrollpercent: true
</code></pre>
<p>如果想把 <code>top</code>按钮放在侧边栏,打开 <code>themes/next/_config.yml</code> ,搜索关键字 <code>b2t</code> ,把 <code>false</code> 改为 <code>true</code>。</p>
<pre><code class="bash"> # Back to top in sidebar
  b2t: true

  # Scroll percent label in b2t button
  scrollpercent: true
</code></pre>
<h3 id="侧边栏设置"><a href="#侧边栏设置" class="headerlink" title="侧边栏设置"></a>侧边栏设置</h3><h4 id="设置侧边栏社交链接"><a href="#设置侧边栏社交链接" class="headerlink" title="设置侧边栏社交链接"></a>设置侧边栏社交链接</h4><p>打开 <code>themes/next/_config.yml</code> 文件,搜索关键字 <code>social</code> ,然后添加社交站点名称与地址即可。</p>
<pre><code class="ruby"># ---------------------------------------------------------------
# Sidebar Settings
# ---------------------------------------------------------------

# Social Links.
# Usage: `Key: permalink || icon`
# Key is the link label showing to end users.
# Value before `||` delimeter is the target permalink.
# Value after `||` delimeter is the name of FontAwesome icon. If icon (with or without delimeter) is not specified, globe icon will be loaded.
social:
  E-Mail: mailto:yourname@gmail.com || envelope
  Google: https://plus.google.com/yourname || google
  Twitter: https://twitter.com/yourname || twitter
  FB Page: https://www.facebook.com/yourname || facebook
  # 等等
</code></pre>
<h4 id="设置侧边栏社交图标"><a href="#设置侧边栏社交图标" class="headerlink" title="设置侧边栏社交图标"></a>设置侧边栏社交图标</h4><p>打开 <code>themes/next/_config.yml</code> 文件,搜索关键字 <code>social_icons</code> ，添加社交站点名称（注意大小写）图标，<a href="http://fontawesome.dashgame.com/">Font Awesome</a>图标地。</p>
<h4 id="RSS"><a href="#RSS" class="headerlink" title="RSS"></a>RSS</h4><p>在你 <code>Hexo</code> 站点目录下：</p>
<pre><code class="ruby">$ npm install hexo-generator-feed --save
</code></pre>
<p>打开 <code>Hexo</code> 站点下的 <code>_config.yml</code> ,添加如下配置：</p>
<pre><code class="bash"># feed
# Dependencies: https://github.com/hexojs/hexo-generator-feed
feed:
  type: atom
  path: atom.xml
  limit: 20
  hub:
  content:
</code></pre>
<h4 id="友情链接"><a href="#友情链接" class="headerlink" title="友情链接"></a>友情链接</h4><p>打开 <code>themes/next/_config.yml</code> 文件,搜索关键字 <code>Blog rolls</code>：</p>
<pre><code class="csharp"># Blog rolls
links_title: 友情链接 #标题
links_layout: block #布局，一行一个连接
#links_layout: inline
links: #连接
  baidu: http://example.com/
  google: http://example.com/
</code></pre>
<h3 id="主页文章添加边框阴影效果"><a href="#主页文章添加边框阴影效果" class="headerlink" title="主页文章添加边框阴影效果"></a>主页文章添加边框阴影效果</h3><p>打开 <code>themes/next/source/css/_custom/custom.styl</code> ,向里面加代码:（旧版本NexT）</p>
<pre><code class="cpp">// 主页文章添加阴影效果
.post &#123;
   margin-top: 0px;
   margin-bottom: 60px;
   padding: 25px;
   -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5);
   -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);
&#125;
</code></pre>
<p>打开<code>themes\next\source\css\_common\components\post\post.styl</code>文件，将<code>post-block</code>代码进行如下更改：（新版本NexT）</p>
<pre><code>if (hexo-config(&#39;motion.transition.post_block&#39;)) &#123;
    .post-block&#123;
        margin-top: 60px;
        margin-bottom: 60px;
        padding: 25px;
        background:rgba(255,255,255,0.9) none repeat scroll !important; //添加透明效果
        -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5);
        -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);
    &#125;
    .pagination, .comments &#123;
      opacity: 0;
    &#125;
  &#125;
</code></pre>
<h3 id="修改文章间分割线"><a href="#修改文章间分割线" class="headerlink" title="修改文章间分割线"></a>修改文章间分割线</h3><blockquote>
<p>新版NexT已配置好</p>
</blockquote>
<p>打开 <code>themes/next/source/css/_common/components/post/post-eof.styl</code> ,修改：</p>
<pre><code class="ruby">.posts-expand &#123;
  .post-eof &#123;
    display: block;
  //  margin: $post-eof-margin-top auto $post-eof-margin-bottom;  
    width: 0%; //分割线长度
    height: 0px; // 分割线高度
    background: $grey-light;
    text-align: center;
  &#125;
&#125;
</code></pre>
<h3 id="代码块自定义样式"><a href="#代码块自定义样式" class="headerlink" title="代码块自定义样式"></a>代码块自定义样式</h3><blockquote>
<p>不知道是啥</p>
</blockquote>
<pre><code class="css">// Custom styles.
code &#123;
    color: #ff7600;
    background: #fbf7f8;
    margin: 2px;
&#125;
// 边框的自定义样式
.highlight, pre &#123;
    margin: 5px 0;
    padding: 5px;
    border-radius: 3px;
&#125;
.highlight, code, pre &#123;
    border: 1px solid #d6d6d6;
&#125;
</code></pre>
<h3 id="开启版权声明"><a href="#开启版权声明" class="headerlink" title="开启版权声明"></a>开启版权声明</h3><blockquote>
<p>旧版本NexT</p>
</blockquote>
<p>主题配置文件下,搜索关键字 <code>post_copyright</code> , <code>enable</code> 改为 <code>true</code>：</p>
<pre><code class="yaml"># Declare license on posts
post_copyright:
  enable: true
  license: CC BY-NC-SA 4.0
  license_url: https://creativecommons.org/licenses/by-nc-sa/4.0/
</code></pre>
<blockquote>
<p>新版本NexT</p>
</blockquote>
<p>主题配置文件下,搜索关键字 <code>creative_commons</code> , <code>post</code> 改为 <code>true</code>：</p>
<pre><code class="yaml"># Creative Commons 4.0 International License.
# See: https://creativecommons.org/share-your-work/licensing-types-examples
# Available values of license: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zero
# You can set a language value if you prefer a translated version of CC license, e.g. deed.zh
# CC licenses are available in 39 languages, you can find the specific and correct abbreviation you need on https://creativecommons.org
creative_commons:
  license: by-nc-sa
  sidebar: false
  post: true     # 默认显示版权信息
  language:
</code></pre>
<blockquote>
<p><a href="https://blog.pangao.vip/Hexo%E5%8D%9A%E5%AE%A2NexT%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E6%96%87%E7%AB%A0%E5%BA%95%E9%83%A8%E7%89%88%E6%9D%83%E5%A3%B0%E6%98%8E/">自定义版权声明文件内容</a></p>
</blockquote>
<h3 id="设置页面加载动画"><a href="#设置页面加载动画" class="headerlink" title="设置页面加载动画"></a>设置页面加载动画</h3><p><a href="https://tding.top/archives/dfac1e9c.html">原文链接</a></p>
<p>主题配置文件下,<code>enable</code>改为<code>true</code>：</p>
<pre><code class="yaml">pace:
  enable: true
  # Themes list:
  # big-counter | bounce | barber-shop | center-atom | center-circle | center-radar | center-simple
  # corner-indicator | fill-left | flat-top | flash | loading-bar | mac-osx | material | minimal
  theme: minimal
</code></pre>
<p>但是这个加载动画需要安装依赖，地址：<a href="https://github.com/theme-next/theme-next-pace">Progress bar for NexT</a>。</p>
<ul>
<li>方法 1：安装文件</li>
</ul>
<pre><code># 进入主题目录
cd themes/next

# 从GitHub下载依赖文件
git clone https://github.com/theme-next/theme-next-pace source/lib/pace
</code></pre>
<ul>
<li>方法 2：启用 CDN(未使用过)</li>
</ul>
<p>我们可以在主题配置文件<code>_config.yml</code> 中修改：</p>
<pre><code>vendors:
  pace: //cdn.jsdelivr.net/npm/pace-js@1/pace.min.js
  pace_css: //cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.min.css
</code></pre>
<h3 id="在右上角或者左上角实现fork-me-on-github"><a href="#在右上角或者左上角实现fork-me-on-github" class="headerlink" title="在右上角或者左上角实现fork me on github"></a>在右上角或者左上角实现fork me on github</h3><p>1.首先到<a href="http://tholman.com/github-corners/">GitHub Corners</a>或者<a href="https://github.blog/2008-12-19-github-ribbons/">GitHub Ribbons</a>选择自己喜欢的图标，然后copy相应的代码</p>
<p>2.然后将刚才复制的代码粘贴到<code>themes/next/layout/_layout.swig</code>文件中<div class="headband"></div>下面一行</p>
<p>3.把代码中的href后面的值替换成你要跳转的地址，比如你的GitHub主页</p>
<h3 id="顶部阅读进度条"><a href="#顶部阅读进度条" class="headerlink" title="顶部阅读进度条"></a>顶部阅读进度条</h3><p>在主题配置文件中修改<code>enable</code>为<code>true</code></p>
<pre><code class="yaml">reading_progress:
  enable: true
  # Available values: top | bottom
  position: top
  color: &quot;#37c6c0&quot;
  height: 3px
</code></pre>
<h3 id="修改文章底部的那个带-号的标签"><a href="#修改文章底部的那个带-号的标签" class="headerlink" title="修改文章底部的那个带#号的标签"></a>修改文章底部的那个带#号的标签</h3><p>打开配置文件<code>themes\next\layout\_macro\post.swg</code>，观察代码</p>
<pre><code class="html">    &#123;%- if post.tags and post.tags.length %&#125;
        &lt;!--这里判断theme.tag_icon是否为true--&gt;
          &#123;%- if theme.tag_icon %&#125;
            &lt;!--如果是则使用fa fa-tag图标--&gt;
            &#123;%- set tag_indicate = '<i class="fa fa-tag"></i>' %&#125;
          &#123;% else %&#125;
            &lt;!--如果不是则使用&#39;#&#39;--&gt;
            &#123;%- set tag_indicate = '#' %&#125;
          &#123;%- endif %&#125;
          &lt;div class=&quot;post-tags&quot;&gt;
            &#123;%- for tag in post.tags.toArray() %&#125;
              &lt;a href=&quot;&#123;&#123; url_for(tag.path) &#125;&#125;&quot; rel=&quot;tag&quot;&gt;&#123;&#123; tag_indicate &#125;&#125; &#123;&#123; tag.name &#125;&#125;&lt;/a&gt;
            &#123;%- endfor %&#125;
          &lt;/div&gt;
    &#123;%- endif %&#125;
</code></pre>
<p>因此，在主题配置文件<code>_config.yml</code>，将<code>tag_icon</code>设置为<code>true</code>。</p>
<pre><code class="yaml"># Use icon instead of the symbol # to indicate the tag at the bottom of the post
tag_icon: true
</code></pre>
<h3 id="本地搜索"><a href="#本地搜索" class="headerlink" title="本地搜索"></a>本地搜索</h3><p>在你站点的根目录下</p>
<pre><code class="ruby">$ npm install hexo-generator-searchdb --save
</code></pre>
<p>打开 <code>Hexo</code> 站点的 <code>_config.yml</code>,添加配置</p>
<pre><code class="bash">search:
  path: search.xml
  field: post
  format: html
  limit: 10000
</code></pre>
<p>打开 <code>themes/next/_config.yml</code> ,搜索关键字 <code>local_search</code> ,设置为 <code>true</code>：</p>
<pre><code class="bash"># Local search
# Dependencies: https://github.com/flashlab/hexo-generator-search
local_search:
  enable: true
  # if auto, trigger search by changing input
  # if manual, trigger search by pressing enter key or search button
  trigger: auto
  # show top n results per article, show all results by setting to -1
  top_n_per_article: 1
</code></pre>
<h3 id="修改网页底部"><a href="#修改网页底部" class="headerlink" title="修改网页底部"></a>修改网页底部</h3><ol>
<li>在图标库中找到你自己喜欢的图标，修改桃心,打开 <code>themes/next/_config.yml</code> ,搜索关键字 <code>footer</code>,在<code>icon</code>中替换图标名</li>
<li>隐藏网页底部 <code>Hexo 强力驱动</code>，打开主题配置文件,搜索关键字 <code>copyright</code> ，将<code>powered</code>设置为<code>false</code>:</li>
</ol>
<pre><code class="objectivec">footer:
  # Specify the date when the site was setup. If not defined, current year will be used.
  #since: 2015

  # Icon between year and copyright info.
  icon:
    # Icon name in Font Awesome. See: https://fontawesome.com/icons
    name: fa fa-star
    # If you want to animate the icon, set it to true.
    animated: false
    # Change the color of icon, using Hex Code.
    color: &quot;#ff0000&quot;

  # If not defined, `author` from Hexo `_config.yml` will be used.设置作者名称
  copyright: false
    
  # Powered by Hexo &amp; NexT
  powered: true
</code></pre>
<h3 id="统计功能，统计功能-显示文章字数统计-阅读时长-总字数"><a href="#统计功能，统计功能-显示文章字数统计-阅读时长-总字数" class="headerlink" title="统计功能，统计功能,显示文章字数统计,阅读时长,总字数"></a>统计功能，统计功能,显示文章字数统计,阅读时长,总字数</h3><h4 id="首页文章属性"><a href="#首页文章属性" class="headerlink" title="首页文章属性"></a>首页文章属性</h4><pre><code>post_meta:
  item_text: false    # 设为true 可以一行显示，文章的所有属性
  created_at: true    # 显示创建时间
  updated_at:
    enabled: true     # 显示修改的时间
    another_day: true # 设true时，如果创建时间和修改时间一样则显示一个时间
  categories: true    # 显示分类信息
</code></pre>
<h4 id="页面阅读统计"><a href="#页面阅读统计" class="headerlink" title="页面阅读统计"></a>页面阅读统计</h4><pre><code>busuanzi_count:
  enable: false              # 设true 开启
  total_visitors: true       # 总阅读人数（uv数）
  total_visitors_icon: user  # 阅读总人数的图标
  total_views: true          # 总阅读次数（pv数）
  total_views_icon: eye      # 阅读总次数的图标
  post_views: true           # 开启内容阅读次数
  post_views_icon: eye       # 内容页阅读数的图标
</code></pre>
<h4 id="字数统计、阅读时长"><a href="#字数统计、阅读时长" class="headerlink" title="字数统计、阅读时长"></a>字数统计、阅读时长</h4><p>首先安装插件：</p>
<pre><code>npm install hexo-symbols-count-time --save
</code></pre>
<p>主题配置文件<code>_config.yml</code> 修改如下：</p>
<pre><code class="yaml">symbols_count_time:
  separated_meta: true  # false会显示一行
  item_text_post: true  # 显示属性名称,设为false后只显示图标和统计数字,不显示属性的文字
  item_text_total: true # 底部footer是否显示字数统计属性文字
  awl: 4                # 计算字数的一个设置,没设置过
  wpm: 275              # 一分钟阅读的字数
</code></pre>
<p>站点配置文件<code>_config.yml</code> 新增如下：</p>
<pre><code class="yaml">symbols_count_time:
 #文章内是否显示
  symbols: true
  time: true
 # 网页底部是否显示
  total_symbols: true
  total_time: true
</code></pre>
<h3 id="首页文章不展示全文显示摘要"><a href="#首页文章不展示全文显示摘要" class="headerlink" title="首页文章不展示全文显示摘要"></a>首页文章不展示全文显示摘要</h3><p>我们可以在主题配置文件中设置：</p>
<pre><code>scroll_to_more: true      # 点击阅读全文后是否跳到&lt;!--more--&gt;标记处,设为false时点击阅读全文可以从头阅读

save_scroll: false        # 自动保存每篇文章或页面上一次滚动的地方

excerpt_description: true # 自动在首页对文章进行摘要描述作为前言文本

auto_excerpt:   # 是否自动截取摘要
  enable: false # 设置为true则自动截取150字当做首页摘要
  length: 150   # 自动截取的字数
</code></pre>
<blockquote>
<p>官方公告：<code>auto_excerpt</code> 可以自动截断文章内容作为摘要。此功能不是一个 Hexo 主题应当负责的，这为主题的维护者带来了太大压力。自 7.6.0 版本开始，此功能被移除，请自行安装第三方插件，或阅读 Hexo 有关文档。当然，我们仍然建议通过 <code>&lt;!-- more --&gt;</code> 来精确控制 Read More 的位置。</p>
</blockquote>
<p><strong>因此，这个功能在新版的 NexT 已经被废弃了，大家可以直接在文章中添加 <code>&lt;!-- more --&gt;</code> 来精确控制摘要内容</strong>。</p>
<h3 id="添加Live2D看板娘"><a href="#添加Live2D看板娘" class="headerlink" title="添加Live2D看板娘"></a>添加Live2D看板娘</h3><h4 id="普通版"><a href="#普通版" class="headerlink" title="普通版"></a>普通版</h4><p>输入如下命令获取 live2d ：</p>
<pre><code>cnpm install --save hexo-helper-live2d
</code></pre>
<p>输入以下命令，下载相应的模型，将 packagename 更换成模型名称即可，更多模型选择请<a href="https://github.com/xiazeyu/live2d-widget-models">点击此处</a>，各个模型的预览请<a href="https://huaji8.top/post/live2d-plugin-2.0/">访问原作者的博客</a></p>
<pre><code>$ npm install packagename
</code></pre>
<p>打开站点目录下的 _config.yml 文件，添加如下代码：</p>
<pre><code>复制live2d:
  enable: true
  scriptFrom: local
  model:
    use: live2d-widget-model-haruto #模型选择
  display:
    position: right  #模型位置
    width: 150       #模型宽度
    height: 300      #模型高度
  mobile:
    show: false      #是否在手机端显示
</code></pre>
<p>取消看板娘</p>
<pre><code>cnpm uninstall hexo-helper-live2d
</code></pre>
<h4 id="进阶版"><a href="#进阶版" class="headerlink" title="进阶版"></a><a href="https://blog.csdn.net/qq_39610915/article/details/90679768">进阶版</a></h4><h3 id="文章打赏功能"><a href="#文章打赏功能" class="headerlink" title="文章打赏功能"></a>文章打赏功能</h3><p>主题配置文件下：</p>
<pre><code class="yaml"># Reward (Donate)
# Front-matter variable (unsupport animation).
reward_settings:
  # If true, reward will be displayed in every article by default.
  enable: true
  animation: false
  #comment: Donate comment here.

reward:
  wechatpay: /images/wechatpay.png
  alipay: /images/alipay.png
  #paypal: /images/paypal.png
  #bitcoin: /images/bitcoin.png
</code></pre>
<h3 id="内容页里的代码块新增复制按钮"><a href="#内容页里的代码块新增复制按钮" class="headerlink" title="内容页里的代码块新增复制按钮"></a>内容页里的代码块新增复制按钮</h3><p>主题配置文件下：</p>
<pre><code class="yaml">codeblock:
  # Code Highlight theme
  # Available values: normal | night | night eighties | night blue | night bright | solarized | solarized dark | galactic
  # See: https://github.com/chriskempson/tomorrow-theme
  highlight_theme: normal    #代码块色彩主题
  # Add copy button on codeblock
  copy_button:
    enable: true            #是否开启复制按钮
    # Show text copy result.
    show_result: true        #是否显示复制成功信息
    # Available values: default | flat | mac
    style: mac                #代码块主题
</code></pre>
<h3 id="去除页面最上面的黑线"><a href="#去除页面最上面的黑线" class="headerlink" title="去除页面最上面的黑线"></a>去除页面最上面的黑线</h3><p>个人觉得看着很闹心。</p>
<blockquote>
<p>方法一：打开<code>themes\next\layout\_layout.swig</code></p>
</blockquote>
<pre><code class="html">&lt;div class=&quot;container&#123;%- if theme.motion.enable %&#125; use-motion&#123;%- endif %&#125;&quot;&gt;
    &lt;!--
        &lt;div class=&quot;headband&quot;&gt;&lt;/div&gt; 注释或者删除这句
    --&gt;
    ......
&lt;/div&gt;
</code></pre>
<blockquote>
<p>方法二：打开<code>themes\next\source\css\_variables\base.syl</code></p>
</blockquote>
<pre><code>// Headband  将像素设置为0px
// --------------------------------------------------
$headband-height                = 3px;
$headband-bg                    = $black-deep;
</code></pre>
<h3 id="设置背景图片-博客内容透明化"><a href="#设置背景图片-博客内容透明化" class="headerlink" title="设置背景图片+博客内容透明化"></a>设置背景图片+博客内容透明化</h3><p>将<code>styles.styl</code>文件放入<code>themes\next\source\_data</code>以及<code>hexoblog\_data</code>中（没有文件、文件夹需要创建）</p>
<p><code>styles.styl</code>文件内容：</p>
<pre><code class="css">body &#123;
    background:url(/images/background_pink.jpg); // 可以是路径也可以是链接
    background-repeat: no-repeat; // 不重复
    background-attachment:fixed; // 固定住背景图片
    background-position:50% 50%; // 图片位置：居中
    background-size: 100% 100%; // 图片长宽扩充为100%
&#125;


//博客内容透明化
//文章内容的透明度设置
.content-wrap &#123;
  opacity: 0.9;
&#125;

//侧边框的透明度设置
.sidebar &#123;
  opacity: 0.9;
&#125;

//菜单栏的透明度设置
.header-inner &#123;
  background: rgba(255,255,255,0.9);
&#125;

//搜索框（local-search）的透明度设置
.popup &#123;
  opacity: 0.9;
&#125;
</code></pre>
<p>打开<code>themes\next\source\css\main.styl</code>，添加最下面这句</p>
<pre><code>// Custom Layer
// --------------------------------------------------
for $inject_style in hexo-config(&#39;injects.style&#39;)
  @import $inject_style;
  @import &quot;../_data/styles.styl&quot;
</code></pre>
<p>打开主题配置文件</p>
<pre><code class="yaml"># Define custom file paths.
# Create your custom files in site directory `source/_data` and uncomment needed files below.
custom_file_path:
  #head: source/_data/head.swig
  #header: source/_data/header.swig
  #sidebar: source/_data/sidebar.swig
  #postMeta: source/_data/post-meta.swig
  #postBodyEnd: source/_data/post-body-end.swig
  #footer: source/_data/footer.swig
  #bodyEnd: source/_data/body-end.swig
  #variable: source/_data/variables.styl
  #mixin: source/_data/mixins.styl
  style: source/_data/styles.styl  #取消这个注释  
</code></pre>
<h3 id="每篇文章末尾统一添加“本文结束”标记"><a href="#每篇文章末尾统一添加“本文结束”标记" class="headerlink" title="每篇文章末尾统一添加“本文结束”标记"></a>每篇文章末尾统一添加“本文结束”标记</h3><p>在路径 <code>/themes/next/layout/_macro</code> 中新建  <code>passage-end-tag.swig</code> 文件,并添加以下内容：</p>
<pre><code class="xml">&lt;div&gt;
    &#123;% if not is_index %&#125;
        <div style="text-align:center;color: #ccc;font-size:14px;">------ 本文结束------</div>
    &#123;% endif %&#125;
&lt;/div&gt;
</code></pre>
<p>打开 <code>themes/next/layout/_macro/post.swig</code> 文件,添加：</p>
<pre><code class="php">&lt;div&gt;
    &#123;% if not is_index %&#125;
    &#123;% include 'passage-end-tag.swig' %&#125;
    &#123;% endif %&#125;
 &lt;/div&gt;
</code></pre>
<p>然后打开主题配置文件 <code>_config.yml</code>,在末尾添加：</p>
<pre><code class="yaml"># 文章末尾添加“本文结束”标记
passage_end_tag:
enabled: true
</code></pre>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>个人博客</tag>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
</search>
