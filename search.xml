<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>DFS/BFS刷题指南</title>
    <url>/2021/09/24/DFS-BFS%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>总结：</p>
<ol>
<li>BFS问题与<code>队列Queue</code>分不开。</li>
<li>DFS问题与<code>栈Stack</code>分不开。</li>
</ol>
<span id="more"></span>

<h4 id="LeetCode-617-合并二叉树"><a href="#LeetCode-617-合并二叉树" class="headerlink" title="LeetCode 617. 合并二叉树"></a>LeetCode <a href="https://leetcode-cn.com/problems/merge-two-binary-trees/">617. 合并二叉树</a></h4><blockquote>
<p>「方法一」DFS</p>
</blockquote>
<pre><code class="java">class Solution &#123;
    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) &#123;
        if(root1 == null) return root2;
        if(root2 == null) return root1;
        root1.val = root1.val+root2.val;
        root1.left = mergeTrees(root1.left,root2.left);
        root1.right = mergeTrees(root1.right,root2.right);
        return root1;
    &#125;
&#125;
</code></pre>
<h4 id="LeetCode-116-填充每个节点的下一个右侧节点指针"><a href="#LeetCode-116-填充每个节点的下一个右侧节点指针" class="headerlink" title="LeetCode 116. 填充每个节点的下一个右侧节点指针"></a>LeetCode <a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/">116. 填充每个节点的下一个右侧节点指针</a></h4><blockquote>
<p>「方法一」DFS</p>
</blockquote>
<pre><code class="java">class Solution &#123;
    public Node connect(Node root) &#123;
        if(root == null) return null;
        dfs(root);
        return root;
    &#125;

    public void dfs(Node node)&#123;
        if(node.left != null)&#123;
            node.left.next = node.right;
            if(node.next != null)&#123;
                node.right.next = node.next.left;
            &#125;
        &#125;
        if(node.left != null) dfs(node.left);
        if(node.right != null) dfs(node.right);
    &#125;
&#125;
</code></pre>
<blockquote>
<p>「方法二」BFS</p>
</blockquote>
<pre><code class="java">class Solution &#123;
    public Node connect(Node root) &#123;
        if(root == null) return null;
        Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;();
        queue.offer(root);
        while(!queue.isEmpty())&#123;
            int n = queue.size();

            for(int i = 0;i &lt; n;i++)&#123;
                Node node = queue.poll();
                if(i &lt; n - 1)&#123;
                    node.next = queue.peek();
                &#125;
                if(node.left != null)&#123;
                    queue.offer(node.left);
                &#125;
                if(node.right != null)&#123;
                    queue.offer(node.right);
                &#125;
            &#125;
            
        &#125;
        return root;
    &#125;
&#125;
</code></pre>
<h4 id="LeetCode-542-01-矩阵"><a href="#LeetCode-542-01-矩阵" class="headerlink" title="LeetCode 542. 01 矩阵"></a>LeetCode <a href="https://leetcode-cn.com/problems/01-matrix/">542. 01 矩阵</a></h4><blockquote>
<p>「方法一」BFS</p>
</blockquote>
<pre><code class="java">class Solution &#123;
    public int[][] updateMatrix(int[][] mat) &#123;

        int[] dx = &#123;1,0,0,-1&#125;;
        int[] dy = &#123;0,1,-1,0&#125;;
        //模拟队列
        Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;();

        int rn = mat.length;
        int cn = mat[0].length;

        //初始化队列、二维数组
        for(int i = 0; i &lt; rn; i++)&#123;
            for(int j = 0; j &lt; cn; j++)&#123;
                if(mat[i][j] == 0)&#123;
                    queue.offer(new int[]&#123;i,j&#125;);
                &#125;else&#123;
                    mat[i][j] = -1;
                &#125;
            &#125;
        &#125;

        while(!queue.isEmpty())&#123;
            int[] cell = queue.poll();
            int x = cell[0];
            int y = cell[1];
            for(int i = 0; i &lt; 4; i++)&#123;
                int newX = x + dx[i];
                int newY = y + dy[i];
                //当遇到未处理的位置
                if(newX &gt;= 0 &amp;&amp; newX &lt; rn &amp;&amp; newY &gt;= 0 &amp;&amp; newY &lt; cn &amp;&amp; mat[newX][newY] == -1)&#123;
                    //设置位置信息并且将该位置加入队列
                    queue.offer(new int[]&#123;newX,newY&#125;);
                    mat[newX][newY] = mat[x][y] + 1;
                &#125;
            &#125;
        &#125;
        return mat;

    &#125;
&#125;
</code></pre>
<blockquote>
<p>「方法二」DP（还没研究，再嗦）</p>
</blockquote>
<h4 id="LeetCode-994-腐烂的橘子"><a href="#LeetCode-994-腐烂的橘子" class="headerlink" title="LeetCode 994. 腐烂的橘子"></a>LeetCode <a href="https://leetcode-cn.com/problems/rotting-oranges/">994. 腐烂的橘子</a></h4><blockquote>
<p>「方法一」BFS</p>
</blockquote>
<pre><code class="java">class Solution &#123;
    public int orangesRotting(int[][] grid) &#123;
        int[] dx = &#123;1,0,0,-1&#125;;
        int[] dy = &#123;0,1,-1,0&#125;;

        int rn = grid.length;
        int cn = grid[0].length;

        Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();
        Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();

        for(int i = 0; i &lt; rn; i++)&#123;
            for(int j = 0; j &lt; cn; j++)&#123;
                if(grid[i][j] == 2)&#123;
                    int rc = i * cn + j;
                    queue.offer(rc);
                    map.put(rc,0);
                &#125;
            &#125;
        &#125;

        int ans = 0;
        while(!queue.isEmpty())&#123;
            int rc = queue.poll();
            int x = rc / cn;
            int y = rc % cn;
            for(int i = 0; i &lt; 4; i++)&#123;
                int newX = x + dx[i];
                int newY = y + dy[i];
                if(newX &gt;= 0 &amp;&amp; newX &lt; rn &amp;&amp; newY &gt;= 0 &amp;&amp; newY &lt; cn &amp;&amp; grid[newX][newY] == 1 )&#123;
                    int newRc = newX * cn + newY;
                    queue.offer(newRc);
                    grid[newX][newY] = 2;
                    map.put(newRc ,map.get(rc) + 1);      
                    ans = map.get(newRc);         
                &#125;
            &#125;
        &#125;

        for(int[] nums:grid)&#123;
            for(int num: nums)&#123;
                if(num == 1)   return -1;
            &#125;
        &#125;

        return ans;
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>DFS/BFS</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap-Hashtable-ConcurrentHashMap</title>
    <url>/2021/09/24/HashMap-Hashtable-ConcurrentHashMap/</url>
    <content><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/58621094">原文链接</a></p>
<span id="more"></span>

]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo基本使用</title>
    <url>/2021/09/07/Hexo%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="初始化博客"><a href="#初始化博客" class="headerlink" title="初始化博客"></a>初始化博客</h2><p> <code>hexo init</code> 文件夹名称</p>
<h2 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h2><p> <code>hexo new</code> 文章名称<br>(或者)<br> <code>hexo n</code> 文章名称</p>
<h2 id="在线预览"><a href="#在线预览" class="headerlink" title="在线预览"></a>在线预览</h2><p> <code>hexo server</code><br>(或者)<br><code>hexo s</code></p>
<h2 id="一键部署"><a href="#一键部署" class="headerlink" title="一键部署"></a>一键部署</h2><p> <code>hexo deploy</code><br>(或者)<br> <code>hexo d</code></p>
<h2 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h2><p>git clone <a href="https://github.com/litten/hexo-theme-yilia.git">https://github.com/litten/hexo-theme-yilia.git</a> themes&#x2F;yilia</p>
<p>hexo clean</p>
<p>hexo g</p>
<p>hexo s  localhost:4000查看</p>
<p><code>hexo d</code> 推到GitHub远端</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>—    #安装Nodejs<br>node -v    #查看node版本<br>npm -v    #查看npm版本<br>npm install -g cnpm –registry&#x3D;<a href="http://registry.npm.taobao.org/">http://registry.npm.taobao.org</a>    #安装淘宝的cnpm 管理器<br>cnpm -v    #查看cnpm版本<br>cnpm install -g hexo-cli    #安装hexo框架<br>hexo -v    #查看hexo版本<br>mkdir blog    #创建blog目录<br>cd blog     #进入blog目录<br>sudo hexo init     #生成博客 初始化博客<br>hexo s    #启动本地博客服务<br><a href="http://localhost:4000/">http://localhost:4000/</a>    #本地访问地址<br>hexo n 我的第一篇文章 #创建新的文章<br>#返回blog目录<br>hexo clean #清理<br>hexo g #生成<br>#Github创建一个新的仓库 YourGithubName.github.io<br>cnpm install –save hexo-deployer-git #在blog目录下安装git部署插件</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo的基本使用</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客图片显示</title>
    <url>/2022/02/24/Hexo%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87%E6%98%BE%E7%A4%BA/</url>
    <content><![CDATA[<p>设置个人博客的图片实现问题。</p>
<p>这里本人图片显示使用的是相对路径，其它问题自行百度。</p>
<p><a href="https://zhuanlan.zhihu.com/p/265077468">原文链接</a></p>
<span id="more"></span>

<h3 id="更改配置"><a href="#更改配置" class="headerlink" title="更改配置"></a>更改配置</h3><p>打开<code>_config.yml</code>文件，更改配置：</p>
<pre><code class="yaml">post_asset_folder: true
</code></pre>
<pre><code class="shell">#重启Hexo,git中输入
hexo clean
hexo g
</code></pre>
<p>当该配置被应用后，使用<code>hexo new</code>命令创建新文章时，会生成相同名字的文件夹，也就是文章资源文件夹。</p>
<h3 id="下载图片插件hexo-renderer-marked"><a href="#下载图片插件hexo-renderer-marked" class="headerlink" title="下载图片插件hexo-renderer-marked"></a>下载图片插件hexo-renderer-marked</h3><pre><code class="shell">cnpm install hexo-renderer-marked
</code></pre>
<p>之后在<code>config.yml</code>中更改配置如下：</p>
<pre><code class="yaml">post_asset_folder: true
marked:
  prependRoot: true
  postAsset: true
</code></pre>
<p>全部设置完成后便可以方便的在Hexo中设置显示图片。</p>
<ol>
<li>使用<code>![图片描述](文章名/图片名称)</code>可以在本地编辑器中查看图片；</li>
<li>但是在Hexo中需要使用<code>![图片描述](图片名称)</code>才可以查看，因此想要在Hexo上显示图片，本地编辑器就会显示不了图片。</li>
</ol>
<h3 id="Typora提供的便利操作"><a href="#Typora提供的便利操作" class="headerlink" title="Typora提供的便利操作"></a>Typora提供的便利操作</h3><h4 id="1-偏好设置"><a href="#1-偏好设置" class="headerlink" title="1.偏好设置"></a>1.偏好设置</h4><p>Typora对于插入图片的支持做得非常好，在<code>文件-&gt;偏好设置</code>或者<code>Ctrl+逗号</code>进入设置。</p>
<p><img src="/2022/02/24/Hexo%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87%E6%98%BE%E7%A4%BA/image-20220224151507587.png" alt="image-20220224151507587"></p>
<p>使用该配置后，可以直接复制网页中的图片地址，粘贴到Typora中后，<strong>会直接复制该图片到文章资源文件夹，同时自动更改路径</strong>。</p>
<p>如复制网络路径的图片<code>https://...../image.jpg</code>粘贴到Typora中叫<code>文章名</code>的文章后，图片会自动变为<code>![](文章名/image.jpg)</code>。</p>
<h4 id="2-图片路径问题"><a href="#2-图片路径问题" class="headerlink" title="2.图片路径问题"></a>2.图片路径问题</h4><p>但我们知道部署后，想要在Hexo上显示，图片文件路径还需要更改，所以当我们插入完所有的图片后，我们还需要删除每个图片路径中的<code>文件名/</code>。不慌，也很简单。</p>
<blockquote>
<p>这里发现一个bug，使用查找和替换时，字符串若为”文章名&#x2F;“ 查询失效，目前还没搞清楚为什么。</p>
</blockquote>
<p>在Typora编辑器中，使用快捷键<code>Ctrl+h</code>，将所有的<code>文章名/image</code>替换为<code>image</code>即可删除。</p>
<p><img src="/2022/02/24/Hexo%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87%E6%98%BE%E7%A4%BA/image-20220224152016217.png" alt="image-20220224152016217"></p>
<p>然后再将博客上传，图片就会随着文章一起打包。在网页中就可以看到正常显示的图片，大功告成。</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>技术问题解决</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM知识点</title>
    <url>/2022/04/02/JVM%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<span id="more"></span>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
        <tag>八股文</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA使用小技巧</title>
    <url>/2022/04/08/IDEA%E4%BD%BF%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<p>汇总IDEA项目中有用、有趣的使用技巧</p>
<span id="more"></span>

<h3 id="隐藏项目文件及文件夹"><a href="#隐藏项目文件及文件夹" class="headerlink" title="隐藏项目文件及文件夹"></a>隐藏项目文件及文件夹</h3><p><strong>步骤①</strong>：打开设置，【Files】→【Settings】</p>
<img src="image-20211122173835517.png" alt="image-20211122173835517" style="zoom:80%;" />

<p><strong>步骤②</strong>：打开文件类型设置界面，【Editor】→【File Types】→【Ignored Files and Folders】，忽略文件或文件夹显示</p>
<img src="image-20211122174020028.png" alt="image-20211122174020028" style="zoom: 67%;" />

<p><strong>步骤③</strong>：添加你要隐藏的文件名称或文件夹名称，可以使用*号通配符，表示任意，设置完毕即可</p>
<p>​    到这里就做完了，其实就是Idea的一个小功能</p>
<p><strong>总结</strong></p>
<ol>
<li>Idea中隐藏指定文件或指定类型文件<ol>
<li>【Files】→【Settings】</li>
<li>【Editor】→【File Types】→【Ignored Files and Folders】</li>
<li>输入要隐藏的名称，支持*号通配符</li>
<li>回车确认添加</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>IDEA</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/09/07/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;
</code></pre>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server
</code></pre>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate
</code></pre>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy
</code></pre>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>Hello</category>
      </categories>
  </entry>
  <entry>
    <title>img-test.md</title>
    <url>/2022/02/24/img-test-md/</url>
    <content><![CDATA[<p>图片测试</p>
<span id="more"></span>

<p><img src="/2022/02/24/img-test-md/1%EF%BC%887%EF%BC%89.png" alt="图片测试"></p>
<p><img src="/2022/02/24/img-test-md/v2-52220b2dba6901ee2181b72951d25a7b_r.jpg" alt="preview"></p>
]]></content>
      <categories>
        <category>img</category>
      </categories>
  </entry>
  <entry>
    <title>【Hexo】github开启令牌验证后无法更新Blog的问题</title>
    <url>/2022/02/10/%E3%80%90Hexo%E3%80%91github%E5%BC%80%E5%90%AF%E4%BB%A4%E7%89%8C%E9%AA%8C%E8%AF%81%E5%90%8E%E6%97%A0%E6%B3%95%E6%9B%B4%E6%96%B0Blog%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>从2021年8月13日起， github不再支持帐号密码验证Git操作，改用token(令牌)或SSH密钥。</p>
<p><a href="https://nokiasonic.github.io/2021/08/30/%E3%80%90Hexo%E3%80%91github%E5%BC%80%E5%90%AF%E4%BB%A4%E7%89%8C%E9%AA%8C%E8%AF%81%E5%90%8E%E6%97%A0%E6%B3%95%E6%9B%B4%E6%96%B0Blog%E7%9A%84%E9%97%AE%E9%A2%98/">原文链接</a></p>
<span id="more"></span>

<p><img src="https://gitee.com/nokiasonic/pic/raw/master/img/20210830140625.png" alt="img"></p>
<p><strong>解决方案</strong></p>
<ol>
<li>在<code>github</code>中注册一个<code>token令牌</code>：首先登入Github 账户，<code>Setting - Developer settings - Personal access tokens - Generate new token</code>, Note 填写 Hexo 或 Blog 之类，勾选第一项 repo，然后 Generate token；为Hexo项目生成一个令牌。</li>
<li>在<code>Hexo配置文件</code>中修改<code>_config.yml</code>：</li>
</ol>
<pre><code class="yaml"># Deployment
## Docs: https://hexo.io/docs/one-command-deployment
deploy:
  type: &#39;git&#39;
  repo: https://[复制生成的token]@github.com/nokiasonic/nokiasonic.github.io.git
  branch: main
</code></pre>
<p>即可正常hexo d更新blog。</p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>技术问题解决</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title>【JavaSE】Java基础2</title>
    <url>/2022/03/22/%E3%80%90JavaSE%E3%80%91Java%E5%9F%BA%E7%A1%802/</url>
    <content><![CDATA[<p>将以往学习Java的笔记2转移到个人博客</p>
<span id="more"></span>

<h1 id="Java基础-2"><a href="#Java基础-2" class="headerlink" title="Java基础 2"></a>Java基础 2</h1><h2 id="7-方法"><a href="#7-方法" class="headerlink" title="7 方法"></a>7 方法</h2><h3 id="7-1-方法概述"><a href="#7-1-方法概述" class="headerlink" title="7.1 方法概述"></a>7.1 方法概述</h3><h3 id="7-2-方法的定义和调用"><a href="#7-2-方法的定义和调用" class="headerlink" title="7.2 方法的定义和调用"></a>7.2 方法的定义和调用</h3><h4 id="7-2-1-方法定义："><a href="#7-2-1-方法定义：" class="headerlink" title="7.2.1 方法定义："></a>7.2.1 方法定义：</h4><ul>
<li>格式<br>  public static void 方法名(){<br>  方法体；<br>  }</li>
<li>范例：<pre><code class="java">  public static void main(String[] args) &#123;
      HelloWorld();
  &#125;
  public static void HelloWorld()&#123; 
      System.out.println(&quot;hello&quot;);
  &#125;
</code></pre>
</li>
</ul>
<h3 id="7-3-带参数方法的定义和调用"><a href="#7-3-带参数方法的定义和调用" class="headerlink" title="7.3 带参数方法的定义和调用"></a>7.3 带参数方法的定义和调用</h3><pre><code class="java">    public static void main(String[] args) &#123;
        getMax(2,3);
    &#125;
    public static void getMax(int a,int b)&#123;
        if (a&gt;b)&#123;
            System.out.println(a);
        &#125;else &#123;
            System.out.println(b);
        &#125;
    &#125;
</code></pre>
<h3 id="7-4-带返回值方法的定义和调用"><a href="#7-4-带返回值方法的定义和调用" class="headerlink" title="7.4 带返回值方法的定义和调用"></a>7.4 带返回值方法的定义和调用</h3><pre><code class="java">    public static int max(int[] a)&#123;
        int max = a[0];   
        for (int i = 1; i &lt; a.length; i++) &#123;        
            max = a[i]&gt;max?a[i]:max; 
        &#125;    
        return max;
    &#125;
</code></pre>
<h3 id="7-5-方法的注意事项"><a href="#7-5-方法的注意事项" class="headerlink" title="7.5 方法的注意事项"></a>7.5 方法的注意事项</h3><ul>
<li>方法不能<strong>嵌套定义</strong></li>
<li>![Image [3]](【JavaSE】Java基础2&#x2F;Image [3].png)</li>
</ul>
<h3 id="7-6-方法的重载"><a href="#7-6-方法的重载" class="headerlink" title="7.6 方法的重载"></a>7.6 方法的重载</h3><h4 id="7-6-1-方法重载概述"><a href="#7-6-1-方法重载概述" class="headerlink" title="7.6.1 方法重载概述"></a>7.6.1 方法重载概述</h4><ul>
<li>多个方法在<strong>同一个类中</strong></li>
<li>多个方法具有<strong>相同的方法名</strong></li>
<li>多个方法的<strong>参数不相同，类型不同或者数量不同</strong><h3 id="7-7-方法的参数传递"><a href="#7-7-方法的参数传递" class="headerlink" title="7.7 方法的参数传递"></a>7.7 方法的参数传递</h3><h4 id="7-7-1-方法参数传递-基本类型"><a href="#7-7-1-方法参数传递-基本类型" class="headerlink" title="7.7.1 方法参数传递(基本类型)"></a>7.7.1 方法参数传递(基本类型)</h4></li>
</ul>
<p>![Image [4]](【JavaSE】Java基础2&#x2F;Image [4].png)</p>
<h4 id="7-7-2-方法参数传递-引用类型"><a href="#7-7-2-方法参数传递-引用类型" class="headerlink" title="7.7.2 方法参数传递(引用类型)"></a>7.7.2 方法参数传递(引用类型)</h4><p>![Image [5]](【JavaSE】Java基础2&#x2F;Image [5].png)</p>
<h2 id="8-Debug"><a href="#8-Debug" class="headerlink" title="8 Debug"></a>8 Debug</h2><h3 id="8-1-Debug概述"><a href="#8-1-Debug概述" class="headerlink" title="8.1 Debug概述"></a>8.1 Debug概述</h3><ul>
<li><strong>Debug</strong>：是供程序员使用的程序调式功能，它可以用于<strong>查看程序的执行流程</strong>，也可以用于追踪程序执行过程来<strong>调试程序</strong>。<h3 id="8-2-Debug操作流程"><a href="#8-2-Debug操作流程" class="headerlink" title="8.2 Debug操作流程"></a>8.2 Debug操作流程</h3>Debug调试，又被称为断点调试，</li>
</ul>
<ol>
<li>如何加断点</li>
<li>如何运行加了断点的程序</li>
<li>看哪里<ul>
<li>看Debugger窗口</li>
<li>看Console窗口</li>
</ul>
</li>
<li>点哪里<ul>
<li>F7往下执行</li>
<li>点stop结束</li>
</ul>
</li>
<li>如何删除断点</li>
</ol>
<h2 id="9-面向对象基础"><a href="#9-面向对象基础" class="headerlink" title="9 面向对象基础"></a>9 面向对象基础</h2><h3 id="9-1-类和对象"><a href="#9-1-类和对象" class="headerlink" title="9.1 类和对象"></a>9.1 类和对象</h3><pre><code>* 对象：万物皆对象，客观存在的事实皆为对象。
* 类是对现实生活中一类具有**共同属性和行为**的事物的抽象
</code></pre>
<hr>
<p>  <strong>类的特点:</strong></p>
<ul>
<li>类是对象的数据类型</li>
<li>类是具有相同属性和行为的一组对象的集合。</li>
</ul>
<hr>
<p> <strong>对象的属性：</strong><br>         对象具有的各种特征，每个对象的每个<strong>属性</strong>都拥有特定的<strong>值</strong></p>
<hr>
<p> <strong>对象的行为：</strong><br>          对象能够执行的操作</p>
<hr>
<p> <em><strong>类是对象的抽象，对象是类的实体</strong></em></p>
<p>![Image [6]](【JavaSE】Java基础2&#x2F;Image [6].png)</p>
<hr>
<ul>
<li><p>类的定义：<br>&#96;&#96;&#96;java<br>&#x2F;&#x2F;手机类<br>public class Phone {</p>
<p>  &#x2F;&#x2F;成员变量：品牌，价格<br>  String brand;<br>  int price;</p>
<p>  &#x2F;&#x2F;成员方法：打电话，发送信息<br>  public void call(){<br>  System.out.println(“打电话”);<br>  }</p>
<p>  public void sendMessage(){<br>  System.out.println(“发送信息”);<br>  }</p>
</li>
</ul>
<p>}</p>
<pre><code>******************

* 对象的使用

![Image [7]](【JavaSE】Java基础2/Image [7].png)

### 9.2 对象内存图
#### 9.2.1 对象内存图(单个对象)

![Image [8]](【JavaSE】Java基础2/Image [8].png)

#### 9.2.2 对象内存图(多个对象)

![Image [9]](【JavaSE】Java基础2/Image [9].png)

#### 9.2.3 对象内存图(多个对象指向相同)

![Image [10]](【JavaSE】Java基础2/Image [10].png)
</code></pre>
]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>【JavaSE】Java基础1</title>
    <url>/2022/03/21/%E3%80%90JavaSE%E3%80%91Java%E5%9F%BA%E7%A1%801/</url>
    <content><![CDATA[<p>将以往学习Java的笔记1转移到个人博客</p>
<span id="more"></span>

<h1 id="Java基础-1"><a href="#Java基础-1" class="headerlink" title="Java基础 1"></a>Java基础 1</h1><h2 id="1-1-数据类型"><a href="#1-1-数据类型" class="headerlink" title="1.1 数据类型"></a>1.1 数据类型</h2><p>给一个整数，默认为<strong>int</strong>类型<br>给一个浮点数，默认为<strong>double</strong>类型</p>
<h2 id="1-2-变量使用的注意事项："><a href="#1-2-变量使用的注意事项：" class="headerlink" title="1.2 变量使用的注意事项："></a>1.2 变量使用的注意事项：</h2><ol>
<li><p>名字不能重复；</p>
</li>
<li><p>变量未赋值，不能使用；</p>
</li>
<li><p><strong>long</strong>类型的变量定义的时候，为了防止整数过大，后面要加<strong>L</strong></p>
</li>
<li><p><strong>float</strong>类型的变量定义的时候，为了防止类型不兼容，后面要加<strong>F</strong></p>
<pre><code class="java">public class string1 &#123;
    public static void main(String[] args) &#123;
          long l=10000000000000L;
          System.out.println(l);
          float f=3.14F;
          System.out.println(f);
    &#125;
&#125;
</code></pre>
<h2 id="1-3-标识符"><a href="#1-3-标识符" class="headerlink" title="1.3 标识符"></a>1.3 标识符</h2><h3 id="1-3-1-标识符定义规则"><a href="#1-3-1-标识符定义规则" class="headerlink" title="1.3.1 标识符定义规则"></a>1.3.1 标识符定义规则</h3></li>
<li><p>由 <strong>数字、字母、下划线和美元符($)</strong> 组成</p>
</li>
<li><p>不能以数字开头</p>
</li>
<li><p>不能是关键字</p>
</li>
<li><p>区分大小写</p>
<h3 id="1-3-2-常见命名规则"><a href="#1-3-2-常见命名规则" class="headerlink" title="1.3.2 常见命名规则"></a>1.3.2 常见命名规则</h3></li>
</ol>
<p><strong>小驼峰命名法：</strong> 方法、变量<br><strong>大驼峰命名法：</strong> 类</p>
<h2 id="1-4-类型转换"><a href="#1-4-类型转换" class="headerlink" title="1.4 类型转换"></a>1.4 类型转换</h2><h3 id="1-4-1-自动类型转换"><a href="#1-4-1-自动类型转换" class="headerlink" title="1.4.1 自动类型转换"></a>1.4.1 自动类型转换</h3><p>把一个表示数据<strong>范围小的数值或者变量</strong>赋值给另一个表示数据<strong>范围大的变量。</strong></p>
<p><img src="/2022/03/21/%E3%80%90JavaSE%E3%80%91Java%E5%9F%BA%E7%A1%801/Image.png" alt="Image"></p>
<pre><code class="java">public class ConversionDemo 
       public static void main(String[] args) &#123;

             double d = 10;

             System.out.println(d);
             System.out.println(getType(d));

             byte b = 10;
             
             //byte 不可以转换成char
             //char c=b;
             
             
             //自动类型转换
             short s = b;
             int i = s;
             
             
             //强制类型转换
             i = (int)88.88;

             System.out.println(i);

             long l = i;
             float f = l;
             double dd = f;      
       &#125;
       public static String getType(Object d) &#123;

             return d.getClass().toString();
       &#125;
&#125;
</code></pre>
<h3 id="1-4-2-强制类型转换"><a href="#1-4-2-强制类型转换" class="headerlink" title="1.4.2 强制类型转换"></a>1.4.2 强制类型转换</h3><p>把一个表示数据<strong>范围大的数值或者变量</strong>赋值给另一个表示数据<strong>范围小的变量。</strong></p>
<ul>
<li>格式：<strong>目标数据类型  变量名&#x3D;（目标数据类型）&#x2F;值或变量；</strong></li>
<li>范例：<strong>int i&#x3D;(int) 88.88；</strong></li>
</ul>
<h1 id="2-运算符"><a href="#2-运算符" class="headerlink" title="2 运算符"></a>2 运算符</h1><h2 id="2-1-算术运算符"><a href="#2-1-算术运算符" class="headerlink" title="2.1 算术运算符"></a>2.1 算术运算符</h2><p>算术表达式中<strong>包含多个基本数据类型</strong>的值的时候，整个算术表达式的<strong>类型会进行自动提升。</strong></p>
<h3 id="2-1-1-字符的“-”操作"><a href="#2-1-1-字符的“-”操作" class="headerlink" title="2.1.1 字符的“+”操作"></a>2.1.1 字符的“+”操作</h3><p>提升规则：</p>
<ul>
<li>byte类型，short类型和char类型会自动提升到int类型</li>
<li>整个表达式的类型会自动提升到表达式最高等级操作数同样的类型</li>
</ul>
<pre><code class="java">public class OperatorDemo &#123;
       public static void main(String[] args) &#123;
             char c=&#39;A&#39;;
             int i=10;
             //char ch=c+i;
             int ch=c+i;
             System.out.println(ch);
             
             //int ii=1+1.2;
             float f=1+1.2f;
             System.out.println(f);
       &#125;
&#125;
</code></pre>
<h3 id="2-1-2-字符串的“-”操作"><a href="#2-1-2-字符串的“-”操作" class="headerlink" title="2.1.2 字符串的“+”操作"></a>2.1.2 字符串的“+”操作</h3><p>当“+”操作中出现字符串时，这个“+”是<strong>字符串连接符</strong>，而不是算术运算符</p>
<ul>
<li><strong>“yangyi”+666</strong><br>在“+”操作中，如果出现了字符串，就是连接运算符，否则就是算术运算符。当连续进行“+”操作时，从左到右逐个执行。</li>
<li><strong>1+2+”yanngyi”</strong><br>&#96;&#96;&#96;java<br>      System.out.println(1+11+”A”+’A’);<br>       &#x2F;&#x2F;结果是12AA<br><br>       System.out.println(“asd”+1+11+”A”+’A’);<br>       &#x2F;&#x2F;结果是 asd111AA</li>
</ul>
<pre><code>## 2.2 赋值运算符
**注意：** 扩展的赋值运算符底层隐含了强制类型转换
```java
             short i=10;
             //    i=(short) (i+10);
             i+=10;
             System.out.println(i);

             float f=10.2f;
             //   f=(float) (f+10.3);
             f+=10.3;
             System.out.println(f);
</code></pre>
<h2 id="2-3-自增自减运算符"><a href="#2-3-自增自减运算符" class="headerlink" title="2.3 自增自减运算符"></a>2.3 自增自减运算符</h2><ul>
<li><p>单独使用时，++和–无论是放在变量的前边还是后边，结果都是一样的。</p>
</li>
<li><p>参与操作时，如果放在变量的后边，先拿变量参与操作，后拿变量做++或–；</p>
</li>
<li><p>参与操作时，如果放在变量的前边，先拿变量做++或-，后-拿变量参与操作。</p>
<h2 id="2-4-关系运算符"><a href="#2-4-关系运算符" class="headerlink" title="2.4 关系运算符"></a>2.4 关系运算符</h2></li>
<li><p>关系运算符的<strong>结果</strong>都是<strong>Boolean</strong>类型，要么是true，要么是false。</p>
<h2 id="2-5-逻辑运算符"><a href="#2-5-逻辑运算符" class="headerlink" title="2.5 逻辑运算符"></a>2.5 逻辑运算符</h2><table>
<thead>
<tr>
<th align="center">符号</th>
<th>作用</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&amp;</td>
<td>逻辑与</td>
<td></td>
</tr>
<tr>
<td align="center">|</td>
<td>逻辑或</td>
<td></td>
</tr>
<tr>
<td align="center">^</td>
<td>逻辑异或</td>
<td>a^b,a和b结果不同为true，相同为false</td>
</tr>
<tr>
<td align="center">!</td>
<td>逻辑非</td>
<td></td>
</tr>
</tbody></table>
<h2 id="2-6-短路逻辑运算符"><a href="#2-6-短路逻辑运算符" class="headerlink" title="2.6 短路逻辑运算符"></a>2.6 短路逻辑运算符</h2><table>
<thead>
<tr>
<th align="center">符号</th>
<th>作用</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&amp;&amp;</td>
<td>短路与</td>
<td>作用和 &amp; 相同，但是有短路效果</td>
</tr>
<tr>
<td align="center">||</td>
<td>短路或</td>
<td>作用和 | 相同，但是有短路效果</td>
</tr>
</tbody></table>
</li>
<li><p>最常用的逻辑运算符：**&amp;&amp;，||，！。**</p>
<h2 id="2-7-三元运算符"><a href="#2-7-三元运算符" class="headerlink" title="2.7 三元运算符"></a>2.7 三元运算符</h2></li>
<li><p>格式：关系表达式？表达式1：表达式2</p>
</li>
<li><p>范例：<strong>a&gt;b?a:b;</strong><br>计算规则：<br>  首先计算<strong>关系表达式的值</strong><br>  如果值为<strong>true，表达式1的值</strong>就是运算结果；<br>  如果值为<strong>false，表达式2的值</strong>就是运算结果；</p>
</li>
</ul>
<h1 id="3-数据输入"><a href="#3-数据输入" class="headerlink" title="3 数据输入"></a>3 数据输入</h1><pre><code class="java">        Scanner sc = new Scanner(System.in)
        int i = sc.nextInt();
</code></pre>
<h1 id="4-分支语句"><a href="#4-分支语句" class="headerlink" title="4 分支语句"></a>4 分支语句</h1><h2 id="4-1-流程控制"><a href="#4-1-流程控制" class="headerlink" title="4.1 流程控制"></a>4.1 流程控制</h2><h2 id="4-2-if语句"><a href="#4-2-if语句" class="headerlink" title="4.2 if语句"></a>4.2 if语句</h2><h2 id="4-3-switch语句"><a href="#4-3-switch语句" class="headerlink" title="4.3 switch语句"></a>4.3 switch语句</h2><h3 id="4-3-1-switch语句格式"><a href="#4-3-1-switch语句格式" class="headerlink" title="4.3.1 switch语句格式"></a>4.3.1 switch语句格式</h3><pre><code class="java">       switch ( i ) &#123;
             case 1:
             case 2:
             case 12:
                    System.out.println(&quot;冬天&quot;);
                    break;     
                    
             case 3:
             case 4:
             case 5:
                    System.out.println(&quot;春天&quot;);
                    break;              

             case 6:
             case 7:
             case 8:
                    System.out.println(&quot;夏天&quot;);
                    break;

             case 9:
             case 10:
             case 11:
                    System.out.println(&quot;秋天&quot;);       
                    break;

             default:
                    System.out.println(&quot;有误&quot;);
                   
             &#125;
</code></pre>
<h1 id="5-循环语句"><a href="#5-循环语句" class="headerlink" title="5 循环语句"></a>5 循环语句</h1><h2 id="5-1-for循环语句"><a href="#5-1-for循环语句" class="headerlink" title="5.1 for循环语句"></a>5.1 for循环语句</h2><ul>
<li><strong>for循环语句格式：</strong><br>  for(初始化语句；条件判断语句；条件控制语句){<br>  循环语句体；<br>  }</li>
<li><strong>执行流程</strong>：</li>
</ul>
<ol>
<li>执行初始化语句</li>
<li>执行条件判断语句，看其结果是true还是false<br> 如果是true，继续执行<br> 如果是flase，循环结束</li>
<li>执行循环语句体</li>
<li>执行条件控制语句</li>
<li>回到 2 继续</li>
</ol>
<blockquote>
<p>任意数字的指定位上的数值如何求？</p>
</blockquote>
<p>先使用整除操作将要求的数字移动到个位上，在使用取余操作取出最后一位上的值。<br>1234<u><strong>5</strong></u>6789    先整除10000得到12345，再对10取余得到5.</p>
<h2 id="5-2-while循环语句"><a href="#5-2-while循环语句" class="headerlink" title="5.2 while循环语句"></a>5.2 while循环语句</h2><ul>
<li><strong>while完整格式：</strong><br>  初始化语句；<br>  while(条件判断语句){<br>  循环体语句；<br>  条件控制语句；<br>  }<h2 id="5-3-do…while循环语句"><a href="#5-3-do…while循环语句" class="headerlink" title="5.3 do…while循环语句"></a>5.3 do…while循环语句</h2></li>
<li><strong>do…while完整格式：</strong><br>  初始化语句；<br>  do{<br>  循环体语句；<br>  条件控制语句；<br>  }while(条件判断语句)<h2 id="5-4-控制跳转语句"><a href="#5-4-控制跳转语句" class="headerlink" title="5.4 控制跳转语句"></a>5.4 控制跳转语句</h2><h3 id="5-4-1-跳转控制语句概述"><a href="#5-4-1-跳转控制语句概述" class="headerlink" title="5.4.1 跳转控制语句概述"></a>5.4.1 跳转控制语句概述</h3></li>
<li><strong>continue</strong> 用在循环中，基于条件控制，跳过某次循环体内容的执行，继续下一次的执行；</li>
<li><strong>break</strong> 用在循环中，基于条件控制，终止循环体内容的执行，也就是说结束当前的整个循环。<h2 id="5-5-循环嵌套"><a href="#5-5-循环嵌套" class="headerlink" title="5.5 循环嵌套"></a>5.5 循环嵌套</h2><pre><code class="java">  for(int h=0;h&lt;24;h++) &#123;
      for(int m=0;m&lt;60;m++) &#123;
          System.out.println(h+&quot;时&quot;+m+&quot;分&quot;);
      &#125;
  &#125;
</code></pre>
</li>
</ul>
<h2 id="5-6-Random"><a href="#5-6-Random" class="headerlink" title="5.6 Random"></a>5.6 Random</h2><pre><code class="java">    Random random = new Random();
 //  获取数据范围：[0,10) 包括0， 不包括10
    int ii = random.nextInt(10);
//  获取一个1~100的随机数
    int i=random.nextInt(100)+1;
</code></pre>
<h1 id="6-数组"><a href="#6-数组" class="headerlink" title="6 数组"></a>6 数组</h1><h2 id="6-1-数组定义格式"><a href="#6-1-数组定义格式" class="headerlink" title="6.1 数组定义格式"></a>6.1 数组定义格式</h2><ul>
<li>数组（array）是一种用于存储<strong>多个相同类型</strong>数据的存储模型。</li>
</ul>
<hr>
<ul>
<li>格式一：数据类型[] 变量名</li>
<li>范例：int[] arr（推荐）</li>
<li>定义了一个int类型的数组，数组名是arr</li>
</ul>
<hr>
<ul>
<li>格式二：数据类型 变量名[]</li>
<li>范例：int arr[]</li>
<li>定义了一个int类型的变量，变量名是arr数组<h2 id="6-2-数组初始化之动态初始化"><a href="#6-2-数组初始化之动态初始化" class="headerlink" title="6.2 数组初始化之动态初始化"></a>6.2 数组初始化之动态初始化</h2></li>
</ul>
<pre><code class="java">        int[ ] arr = new int[5];
        //初始化时指定数组长度，由系统决定每个数组元素的初始值
        
        System.out.println(arr);    //     [I@10f87f48（内存地址）
</code></pre>
<h2 id="6-3-数组元素访问"><a href="#6-3-数组元素访问" class="headerlink" title="6.3 数组元素访问"></a>6.3 数组元素访问</h2><pre><code class="java">    int[ ] arr = new int[3];

    for (int i = 0 ;i &lt; arr.length;i++)&#123;
        System.out.println(arr[i]);
        &#125;
</code></pre>
<h2 id="6-4-内存分配"><a href="#6-4-内存分配" class="headerlink" title="6.4 内存分配"></a>6.4 内存分配</h2><p>数组在初始化时，会为存储空间添加默认值</p>
<hr>
<ul>
<li>整数：默认值为0</li>
<li>浮点数：默认值为0.0</li>
<li>布尔值：默认值为false</li>
<li>字符：默认值时空字符</li>
<li>引用数据类型：默认值是null<br>![Image [2]](Image [2].png)</li>
</ul>
<h2 id="6-5-数组初始化之静态初始化"><a href="#6-5-数组初始化之静态初始化" class="headerlink" title="6.5 数组初始化之静态初始化"></a>6.5 数组初始化之静态初始化</h2><pre><code class="java">int[ ] arr = new int[ ]&#123;1,2,3&#125;;
//初始化时指定每个数组元素的初始值，由系统决定数组长度
</code></pre>
<h2 id="6-6-数组操作的两个常见小问题"><a href="#6-6-数组操作的两个常见小问题" class="headerlink" title="6.6 数组操作的两个常见小问题"></a>6.6 数组操作的两个常见小问题</h2><ul>
<li>索引越界</li>
</ul>
<p><strong>ArrayIndexOutOfBoundsException</strong></p>
<pre><code class="java">int[] arr=new int[3];

System.out.println(arr[3]);
</code></pre>
<ul>
<li>空指针异常</li>
</ul>
<p><strong>NullPointerException</strong></p>
<pre><code class="java">int[] arr&#123;1,2,3&#125;;
arr=null;

System.out.println(arr);        //null
System.out.println(arr[2]);
//  报错
</code></pre>
<h2 id="6-7-数组常见小操作"><a href="#6-7-数组常见小操作" class="headerlink" title="6.7 数组常见小操作"></a>6.7 数组常见小操作</h2><ul>
<li>遍历<br>&#96;&#96;&#96;java<br>int[] arr1&#x3D;new int[5];</li>
</ul>
<p>for (int i &#x3D; 0; i &lt; arr1.length; i++) {<br>    System.out.println(arr1[i]);<br>}</p>
<pre><code>* 获取最值
```java
int[] arr_max=&#123;2,4,5,1,2,6,7,10&#125;;
int max=arr_max[0];

for (int i = 1; i &lt; arr_max.length; i++) &#123;    

    max = arr_max[i]&gt;max?arr_max[i]:max;
    
&#125;
System.out.println(&quot;max=&quot;+max);
</code></pre>
]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>【计算机网络】HTTP知识</title>
    <url>/2022/02/20/%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%91HTTP%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>二叉树遍历详解</title>
    <url>/2021/09/15/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<span id="more"></span>

<h4 id="LeetCode-144-二叉树的前序遍历"><a href="#LeetCode-144-二叉树的前序遍历" class="headerlink" title="LeetCode 144. 二叉树的前序遍历"></a>LeetCode <a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a></h4><blockquote>
<p>「方法一」递归</p>
</blockquote>
<pre><code class="java">    public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;
        List&lt;Integer&gt; preArr = new ArrayList&lt;&gt;();
        preorder(root,preArr);
        return preArr;
    &#125;

    public void preorder(TreeNode root,List&lt;Integer&gt; preArr)&#123;
        if(root == null) return;
        arr.add(root.val);
        preorder(root.left,preArr);
        preorder(root.right,preArr);
    &#125;
</code></pre>
<blockquote>
<p>「方法二」迭代</p>
</blockquote>
<pre><code class="java">    public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;
        if(root == null) return new ArrayList&lt;&gt;();
        List&lt;Integer&gt; preList = new ArrayList&lt;&gt;();
        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();
        stack.push(root);
        while(!stack.isEmpty())&#123;
            TreeNode node = stack.pop();
            preList.add(node.val);
            //因为出栈顺序是左子树，右子树
            //所以入栈时右子树应该先进，左子树后进。
            if(node.right != null)&#123;
                stack.push(node.right);
            &#125;
            if(node.left != null)&#123;
                stack.push(node.left);
            &#125;
        &#125;
        return preList;
    &#125;
</code></pre>
<h4 id="LeetCode-94-二叉树的中序遍历"><a href="#LeetCode-94-二叉树的中序遍历" class="headerlink" title="LeetCode 94. 二叉树的中序遍历"></a>LeetCode <a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></h4><blockquote>
<p>「方法一」递归</p>
</blockquote>
<pre><code class="java">    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;
        List&lt;Integer&gt; inList = new ArrayList&lt;&gt;();
        inorder(root,inList);
        return inList;
    &#125;

    public void inorder(TreeNode root,List&lt;Integer&gt; inList)&#123;
        if(root == null) return;
        if(root.left != null) inorder(root.left,inList);
        inList.add(root.val);
        inorder(root.right,inList);
    &#125;
</code></pre>
<blockquote>
<p>「方法二」迭代</p>
<ol>
<li>创建一个Stack，然后按 左 中 右的顺序输出节点。</li>
<li>尽可能的将这个节点的左子树压入Stack，此时栈顶的元素是最左侧的元素，其目的是找到一个最小单位的子树(也就是最左侧的一个节点)，并且在寻找的过程中记录了来源，才能返回上层,同时在返回上层的时候已经处理完毕左子树了。。</li>
<li>当处理完最小单位的子树时，返回到上层处理了中间节点。（如果把整个左中右的遍历都理解成子树的话，就是处理完 左子树-&gt;中间(就是一个节点)-&gt;右子树）</li>
<li>如果有右节点，其也要进行中序遍历。当整个左子树退栈的时候这个时候输出了该子树的根节点 2，之后输出中间节点 1。然后处理根节点为3右子树。</li>
</ol>
</blockquote>
<pre><code class="java">    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;
        if (root == null) return new ArrayList&lt;&gt;();
        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();
        TreeNode cur = root;
        while(!stack.isEmpty() || cur != null)&#123;
            while(cur != null)&#123;
                stack.push(cur);
                cur = cur.left;
            &#125;
            TreeNode node = stack.pop();
            list.add(node.val);
            if(node.right != null)&#123;
                cur = node.right;
            &#125;
        &#125;
        return list;
    &#125;
</code></pre>
<h4 id="LeetCode-145-二叉树的后序遍历"><a href="#LeetCode-145-二叉树的后序遍历" class="headerlink" title="LeetCode 145. 二叉树的后序遍历"></a>LeetCode <a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历</a></h4><blockquote>
<p>「方法一」递归</p>
</blockquote>
<pre><code class="java">    public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;
        if(root == null) return new ArrayList&lt;&gt;();
        List&lt;Integer&gt; postList = new ArrayList&lt;&gt;();
        postorder(root,postList);
        return postList;
    &#125;
    public void postorder(TreeNode root,List&lt;Integer&gt; postList)&#123;
        if(root.left != null) postorder(root.left,postList);
        if(root.right != null) postorder(root.right,postList);
        postList.add(root.val);
    &#125;
</code></pre>
<blockquote>
<p>「方法二」迭代(还没研究，再嗦)</p>
</blockquote>
<h4 id="LeetCode-102-二叉树的层序遍历"><a href="#LeetCode-102-二叉树的层序遍历" class="headerlink" title="LeetCode 102. 二叉树的层序遍历"></a>LeetCode <a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></h4><blockquote>
<p>使用队列模拟每一层</p>
</blockquote>
<pre><code class="java">/**
 Queue 前面的方法是Queue特有的方法，推荐使用前面的方法操作队列
 offer() add()        添加数据
 poll()  remove()    删除数据
 peek()  element()    返回第一个数据
 */
class Solution &#123;
    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;
        if(root == null) return new ArrayList&lt;&gt;();
        List&lt;List&lt;Integer&gt;&gt; ansList = new ArrayList&lt;&gt;();
        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
        queue.offer(root);
        while(!queue.isEmpty())&#123;
            //获取每次队列长度，因为循环中队列size()会改变
            int n = queue.size();
            List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
            for(int i = 0;i &lt; n;i++)&#123;
                TreeNode node = queue.poll();
                list.add(node.val);
                //入队前要判断是否存在左右节点。
                if(node.left != null)&#123;
                    queue.offer(node.left);
                &#125;
                if(node.right != null)&#123;
                    queue.offer(node.right);
                &#125;
            &#125;
            //将处理好的list加入ansList
            ansList.add(list);
        &#125;
        return ansList;
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数据结构</tag>
        <tag>二叉树</tag>
        <tag>模板题</tag>
      </tags>
  </entry>
  <entry>
    <title>【设计模式】单例模式</title>
    <url>/2022/03/30/%E3%80%90%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><strong>重点</strong></p>
<ul>
<li>五种单例模式的实现方式</li>
<li>为何 DCL 实现时要使用 volatile 修饰静态变量</li>
<li>jdk 中用到单例的场景</li>
</ul>
<span id="more"></span>

<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h3 id="三种破坏单例模式的方法"><a href="#三种破坏单例模式的方法" class="headerlink" title="三种破坏单例模式的方法"></a>三种破坏单例模式的方法</h3><p><strong>反射破解单例</strong></p>
<p><strong>反序列化破解单例</strong></p>
<p><strong>unsafe破解单例</strong></p>
<h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a><strong>饿汉式</strong></h3><pre><code class="java">public class Singleton1 implements Serializable &#123;
    private Singleton1() &#123;
        if (INSTANCE != null) &#123;
            throw new RuntimeException(&quot;单例对象不能重复创建&quot;);
        &#125;
        System.out.println(&quot;private Singleton1()&quot;);
    &#125;

    //给静态成员赋值这个操作相当于放在静态代码块中执行
    //静态代码块中的线程安全 jvm 会进行处理，因此饿汉式是线程安全的。
    private static final Singleton1 INSTANCE = new Singleton1();

    public static Singleton1 getInstance() &#123;
        return INSTANCE;
    &#125;

    public static void otherMethod() &#123;
        System.out.println(&quot;otherMethod()&quot;);
    &#125;

    public Object readResolve() &#123;
        return INSTANCE;
    &#125;
&#125;
</code></pre>
<ul>
<li>构造方法抛出异常是防止反射破坏单例</li>
<li><code>readResolve()</code> 是防止反序列化破坏单例</li>
</ul>
<h3 id="枚举饿汉式"><a href="#枚举饿汉式" class="headerlink" title="枚举饿汉式"></a><strong>枚举饿汉式</strong></h3><pre><code class="java">public enum Singleton2 &#123;
    INSTANCE;

    private Singleton2() &#123;
        System.out.println(&quot;private Singleton2()&quot;);
    &#125;

    @Override
    public String toString() &#123;
        return getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());
    &#125;

    public static Singleton2 getInstance() &#123;
        return INSTANCE;
    &#125;

    public static void otherMethod() &#123;
        System.out.println(&quot;otherMethod()&quot;);
    &#125;
&#125;
</code></pre>
<ul>
<li>枚举饿汉式能天然防止反射、反序列化破坏单例</li>
</ul>
<h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a><strong>懒汉式</strong></h3><pre><code class="java">public class Singleton3 implements Serializable &#123;
    private Singleton3() &#123;
        System.out.println(&quot;private Singleton3()&quot;);
    &#125;

    private static Singleton3 INSTANCE = null;

    // Singleton3.class
    public static synchronized Singleton3 getInstance() &#123;
        if (INSTANCE == null) &#123;
            INSTANCE = new Singleton3();
        &#125;
        return INSTANCE;
    &#125;

    public static void otherMethod() &#123;
        System.out.println(&quot;otherMethod()&quot;);
    &#125;

&#125;
</code></pre>
<ul>
<li>其实只有首次创建单例对象时才需要同步，但该代码实际上每次调用都会同步</li>
<li>因此有了下面的双检锁改进</li>
</ul>
<h3 id="双检锁懒汉式"><a href="#双检锁懒汉式" class="headerlink" title="双检锁懒汉式"></a><strong>双检锁懒汉式</strong></h3><pre><code class="java">public class Singleton4 implements Serializable &#123;
    private Singleton4() &#123;
        System.out.println(&quot;private Singleton4()&quot;);
    &#125;

    private static volatile Singleton4 INSTANCE = null; // 可见性，有序性

    public static Singleton4 getInstance() &#123;
        if (INSTANCE == null) &#123;
            synchronized (Singleton4.class) &#123;
                if (INSTANCE == null) &#123;
                    INSTANCE = new Singleton4();
                &#125;
            &#125;
        &#125;
        return INSTANCE;
    &#125;

    public static void otherMethod() &#123;
        System.out.println(&quot;otherMethod()&quot;);
    &#125;
&#125;
</code></pre>
<p>为何必须加 volatile：</p>
<ul>
<li><code>INSTANCE = new Singleton4()</code> 不是原子的，分成 3 步：创建对象、调用构造、给静态变量赋值，其中后两步可能被指令重排序优化，变成先赋值、再调用构造</li>
<li>如果线程1 先执行了赋值，线程2 执行到第一个 <code>INSTANCE == null</code> 时发现 INSTANCE 已经不为 null，此时就会返回一个未完全构造的对象</li>
</ul>
<h3 id="内部类懒汉式"><a href="#内部类懒汉式" class="headerlink" title="内部类懒汉式"></a><strong>内部类懒汉式</strong></h3><pre><code class="java">public class Singleton5 implements Serializable &#123;
    private Singleton5() &#123;
        System.out.println(&quot;private Singleton5()&quot;);
    &#125;

    private static class Holder &#123;
        static Singleton5 INSTANCE = new Singleton5();
    &#125;

    public static Singleton5 getInstance() &#123;
        return Holder.INSTANCE;
    &#125;

    public static void otherMethod() &#123;
        System.out.println(&quot;otherMethod()&quot;);
    &#125;
&#125;
</code></pre>
<ul>
<li>避免了双检锁的缺点</li>
</ul>
<p><strong>JDK 中单例的体现</strong></p>
<ul>
<li>Runtime 体现了饿汉式单例</li>
<li>Console 体现了双检锁懒汉式单例</li>
<li>Collections 中的 EmptyNavigableSet 内部类懒汉式单例</li>
<li>ReverseComparator.REVERSE_ORDER 内部类懒汉式单例</li>
<li>Comparators.NaturalOrderComparator.INSTANCE 枚举饿汉式单例</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>单例模式</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找详解</title>
    <url>/2021/09/12/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/binary-search/solution/er-fen-cha-zhao-xiang-jie-by-labuladong/">原文链接:二分查找细节详解  –LeetCode labuladong</a></p>
<p>相关题目:</p>
<p><a href="https://leetcode-cn.com/problems/binary-search/">LeetCode 704. 二分查找</a></p>
<p><a href="https://leetcode-cn.com/problems/first-bad-version/">LeetCode 278. 第一个错误的版本</a></p>
<p><a href="https://leetcode-cn.com/problems/search-insert-position/">LeetCode 35. 搜索插入位置</a></p>
<p><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">LeetCode 34. 在排序数组中查找元素的第一个和最后一个位置</a></p>
<p><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/">LeetCode 153. 寻找旋转排序数组中的最小值</a></p>
<p><a href="https://leetcode-cn.com/problems/find-peak-element/">LeetCode 162. 寻找峰值</a></p>
<p>注意：</p>
<ol>
<li>模板的左右初始值细节很重要，但是<strong>应用时要注意根据具体情况取左右初始值和循环条件</strong>！！</li>
</ol>
<span id="more"></span>

<p>本人懒狗一枚，详解可以看看上面链接，hhhhh。</p>
<h4 id="寻找一个数（基本的二分搜索）"><a href="#寻找一个数（基本的二分搜索）" class="headerlink" title="寻找一个数（基本的二分搜索）"></a>寻找一个数（基本的二分搜索）</h4><pre><code class="java">class Solution &#123;
    public int search(int[] nums, int target) &#123;
        int left = 0;
        int right = nums.length - 1;    //这里-1时，while循环条件得加上=
        while(left &lt;= right)&#123;            //注意
            int mid = left + (right - left) / 2; //防止了 left 和 right 太大直接相加导致溢出
            if(target == nums[mid])&#123;
                return mid;
            &#125;else if(target &lt; nums[mid])&#123;
                //如果right初始化为nums.length - 1，这里应该为mid-1;
                right = mid - 1;        
            &#125;else if(target &gt; nums[mid])&#123;
                left = mid + 1;            //注意
            &#125;
        &#125;
        return -1;
    &#125;
&#125;
</code></pre>
<h4 id="寻找左侧边界的二分搜索"><a href="#寻找左侧边界的二分搜索" class="headerlink" title="寻找左侧边界的二分搜索"></a>寻找左侧边界的二分搜索</h4><pre><code class="java">public int search(int[] nums, int target) &#123;
        int left = 0,right = nums.length;
        while(left &lt; right)&#123;
            int mid = left + (right - left) / 2;
            //寻找左、右侧边界的二分搜索要注意
            //收紧边界时的条件很重要，
            //这里right = mid ，并且循环结束的条件是 right = left
            //所以循环结束是 right = mid = left
            if(target == nums[mid])&#123;
                right = mid;
            &#125;else if(target &lt; nums[mid])&#123;
                right = mid;
            &#125;else if(target &gt; nums[mid])&#123;
                left = mid + 1;
            &#125;
        &#125;
        if(left &gt;= nums.length || nums[left] != target) return -1;
        return left;
    &#125;
</code></pre>
<h4 id="寻找右侧边界的二分搜索"><a href="#寻找右侧边界的二分搜索" class="headerlink" title="寻找右侧边界的二分搜索"></a>寻找右侧边界的二分搜索</h4><pre><code class="java">public int search(int[] nums, int target) &#123;
        int left = 0,right = nums.length;
        while(left &lt; right)&#123;
            int mid = left + (right - left) / 2;
            if(target == nums[mid])&#123;
                //收紧边界时的条件很重要，
                //这里left = mid + 1;并且循环结束的条件是 right = left
                //所以循环结束是 mid = left - 1 = right - 1；
                left = mid + 1;
            &#125;else if(target &lt; nums[mid])&#123;
                right = mid;
            &#125;else if(target &gt; nums[mid])&#123;
                left = mid + 1;
            &#125;
        &#125;
        if(right - 1 &lt; 0 || nums[right - 1] != target) return -1;
        return right -1;
    &#125;
</code></pre>
<h4 id="LeetCode-153-寻找旋转排序数组中的最小值"><a href="#LeetCode-153-寻找旋转排序数组中的最小值" class="headerlink" title="LeetCode 153. 寻找旋转排序数组中的最小值"></a>LeetCode 153. 寻找旋转排序数组中的最小值</h4><blockquote>
<p>思路：根据左值，中值，右值的大小关系分类讨论.</p>
<p>其中符合数组规律的大小关系如下:</p>
</blockquote>
<blockquote>
<p>​        右            中值 &lt; 右值 ， 缩小右边界</p>
<p>​    中</p>
<p>左    </p>
<hr>
<p>​    中                中值 &gt; 右值 ， 缩小左边界</p>
<p>左</p>
<p>​        右</p>
<hr>
<p>左                    中值 &lt; 右值 ,    缩小右边界</p>
<p>​        右</p>
<p>​    中</p>
</blockquote>
<pre><code class="java">class Solution &#123;
    public int findMin(int[] nums) &#123;
        int left = 0,right = nums.length - 1;
        while(left &lt; right)&#123;
            int mid = (left + right) / 2;
            if(nums[mid] &lt; nums[right])&#123;
                right = mid;
            &#125;else&#123;
                left = mid + 1;
            &#125;
        &#125;
        return nums[left];
    &#125;
&#125;
</code></pre>
<h4 id="LeetCode-162-寻找峰值"><a href="#LeetCode-162-寻找峰值" class="headerlink" title="LeetCode 162. 寻找峰值"></a>LeetCode 162. 寻找峰值</h4><blockquote>
<p>根据左右指针计算中间位置 m，并比较 m 与 m+1 的值，如果 m 较大，则左侧存在峰值，r &#x3D; m，如果 m + 1 较大，则右侧存在峰值，l &#x3D; m + 1.</p>
</blockquote>
<pre><code class="java">class Solution &#123;
    public int findPeakElement(int[] nums) &#123;
        int left = 0,right = nums.length - 1;
        while(left &lt; right)&#123;
            int mid = (left + right) / 2;
            if(nums[mid] &gt; nums[mid + 1])&#123;
                right = mid;
            &#125;else&#123;
                left = mid + 1;
            &#125;
        &#125;
        return left;

    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>模板题</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>位运算刷题指南</title>
    <url>/2021/09/16/%E4%BD%8D%E8%BF%90%E7%AE%97%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<span id="more"></span>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>双指针指南</title>
    <url>/2021/09/13/%E5%8F%8C%E6%8C%87%E9%92%88%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>原题链接：</p>
<p><a href="https://leetcode-cn.com/problems/squares-of-a-sorted-array/">LeetCode 977. 有序数组的平方</a></p>
<p><a href="https://leetcode-cn.com/problems/rotate-array/">LeetCode 189. 旋转数组</a></p>
<span id="more"></span>

<h4 id="LeetCode-977-有序数组的平方"><a href="#LeetCode-977-有序数组的平方" class="headerlink" title="LeetCode 977. 有序数组的平方"></a>LeetCode 977. 有序数组的平方</h4><pre><code class="java">class Solution &#123;
    public int[] sortedSquares(int[] nums) &#123;
        int n = nums.length;
        int[] ans = new int[n];
        int pos = n - 1;
        for(int i = 0,j = n-1;i &lt;= j;pos--)&#123;
            if(nums[i] * nums[i] &gt; nums[j] * nums[j])&#123;
                ans[pos] = nums[i] * nums[i];
                i ++;
            &#125;else&#123;
                ans[pos] = nums[j] * nums[j];
                j --;
            &#125;
        &#125;
        return ans;
    &#125;
&#125;
</code></pre>
<h4 id="LeetCode-189-旋转数组"><a href="#LeetCode-189-旋转数组" class="headerlink" title="LeetCode 189. 旋转数组"></a>LeetCode 189. 旋转数组</h4><blockquote>
<p>方法一：使用额外数组</p>
</blockquote>
<pre><code class="java">    public void rotate(int[] nums, int k) &#123;
        int len = nums.length;
        int[] ans = new int[len];
        for(int i = 0; i &lt; len ;i++)&#123;
            ans[(i + k) % len] = nums[i];
        &#125;
        //复制数组
        System.arraycopy(ans,0,nums,0,len);
    &#125;
</code></pre>
<blockquote>
<p>方法二：环状替换</p>
</blockquote>
<blockquote>
<p>方法三：数组翻转</p>
</blockquote>
<p>原理：</p>
<table>
<thead>
<tr>
<th align="left">操作</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td align="left">原始数组</td>
<td>1 2 3 4 5 6 7</td>
</tr>
<tr>
<td align="left">翻转所有元素</td>
<td>7 6 5 4 3 2 1</td>
</tr>
<tr>
<td align="left">翻转[ 0 , k-1 ]内的元素</td>
<td>5 6 7 4 3 2 1</td>
</tr>
<tr>
<td align="left">翻转[ k-1 , len-1 ]内的元素</td>
<td>5 6 7 1 2 3 4</td>
</tr>
</tbody></table>
<pre><code class="java">    public void rotate(int[] nums, int k) &#123;
        int n = nums.length;
        k %= n;
        reverse(nums,0,n-1);
        reverse(nums,0,k-1);
        reverse(nums,k,n-1);
    &#125;

    public void reverse(int[] nums, int start,int end)&#123;
        while(start &lt; end)&#123;
            int temp = nums[start];
            nums[start] = nums[end];
            nums[end] = temp;
            start++;
            end--;
        &#125;
    &#125;
</code></pre>
<h4 id="LeetCode-283-移动零"><a href="#LeetCode-283-移动零" class="headerlink" title="LeetCode 283. 移动零"></a>LeetCode 283. 移动零</h4><blockquote>
<p>方法一：覆盖前面的值，后续补零</p>
</blockquote>
<pre><code class="java">    public void moveZeroes(int[] nums) &#123;
        int j = 0;
        for(int i = 0;i &lt; nums.length;i++)&#123;
            if(nums[i] != 0)&#123;
                nums[j++] = nums[i];
            &#125;
        &#125;
        for(int i = j;i &lt; nums.length;i++)&#123;
            nums[i] = 0;
        &#125;
    &#125;
</code></pre>
<blockquote>
<p>方法二：双指针</p>
</blockquote>
<pre><code class="java">    public void moveZeroes(int[] nums) &#123;
        //left指向已处理好的序列尾部
        //right指向待处理的序列头部
        int n = nums.length,left = 0,right = 0;
        while(right &lt; n)&#123;
            if(nums[right] != 0)&#123;
                swap(nums,left,right);
                left++;
            &#125;
            right++;
        &#125;
    &#125;

    public void swap(int[] nums,int i,int j)&#123;
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    &#125;
</code></pre>
<h4 id="LeetCode-167-两数之和-II-输入有序数组"><a href="#LeetCode-167-两数之和-II-输入有序数组" class="headerlink" title="LeetCode 167. 两数之和 II - 输入有序数组"></a>LeetCode 167. 两数之和 II - 输入有序数组</h4><pre><code class="java">    public int[] twoSum(int[] numbers, int target) &#123;
        if(numbers.length == 2) return new int[]&#123;1,2&#125;;
        int n = numbers.length;
        int[] ans = new int[2];
        int left = 0;
        int right = n-1;
        while(left &lt; right)&#123;
            if(numbers[left] + numbers[right] == target)&#123;
                ans[0] = left+1;
                ans[1] = right+1;
                return ans;
            &#125;else if(numbers[left] + numbers[right] &gt; target)&#123;
                right --;
            &#125;else&#123;
                left ++;
            &#125;
        &#125;
        return ans;
    &#125;
</code></pre>
<h4 id="LeetCode-344-反转字符串"><a href="#LeetCode-344-反转字符串" class="headerlink" title="LeetCode 344. 反转字符串"></a>LeetCode 344. 反转字符串</h4><pre><code class="java">    public void reverseString(char[] s) &#123;
        int left = 0;
        int right = s.length - 1;
        while(left &lt; right)&#123;
            swap(s,left++,right--);
        &#125;
    &#125;

    public void swap(char[] s,int i,int j)&#123;
        char temp = s[i];
        s[i] = s[j];
        s[j] = temp;
    &#125;
</code></pre>
<h4 id="LeetCode-557-反转字符串中的单词-III"><a href="#LeetCode-557-反转字符串中的单词-III" class="headerlink" title="LeetCode 557. 反转字符串中的单词 III"></a>LeetCode 557. 反转字符串中的单词 III</h4><h4 id="LeetCode-876-链表的中间结点"><a href="#LeetCode-876-链表的中间结点" class="headerlink" title="LeetCode 876. 链表的中间结点"></a>LeetCode <a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/">876. 链表的中间结点</a></h4><blockquote>
<p>快慢指针</p>
</blockquote>
<pre><code class="java">    public ListNode middleNode(ListNode head) &#123;
        if(head == null) return null;
        ListNode fast = head,slow = head;
        //当链表长度是偶数时，需要判断fast.next,如果fast.next == null 说明fast已经走到链表尾端
        while(fast != null &amp;&amp; fast.next != null)&#123;
            fast = fast.next.next;
            slow = slow.next;
        &#125;
        return slow;
    &#125;
</code></pre>
<h4 id="LeetCode-19-删除链表的倒数第-N-个结点"><a href="#LeetCode-19-删除链表的倒数第-N-个结点" class="headerlink" title="LeetCode 19. 删除链表的倒数第 N 个结点"></a>LeetCode <a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></h4><blockquote>
<p>快慢指针</p>
<ol>
<li>将快指针start、慢指针end指向预先节点dummy</li>
<li>start先走n个节点，然后start，end一起走</li>
<li>当start走到链表最后一个节点时，end就到了链表倒数第 n + 1 个节点。</li>
</ol>
</blockquote>
<pre><code class="java">    public ListNode removeNthFromEnd(ListNode head, int n) &#123;
        if(head.next == null) return null;
        //防止head节点被删除，设置预先节点指向head
        ListNode dummy = new ListNode();
        dummy.next = head;
        ListNode start = dummy;
        ListNode end = dummy;
        for(int i = 0;i &lt; n;i++)&#123;
            start = start.next;
        &#125;
        while(start.next != null)&#123;
            start = start.next;
            end = end.next;
        &#125;
        end.next = end.next.next;
        return dummy.next;
    &#125;
</code></pre>
<h4 id="LeetCode-11-盛最多水的容器"><a href="#LeetCode-11-盛最多水的容器" class="headerlink" title="LeetCode 11. 盛最多水的容器"></a>LeetCode <a href="https://leetcode-cn.com/problems/container-with-most-water/">11. 盛最多水的容器</a></h4><blockquote>
<p>双指针</p>
<ol>
<li>初始化： 双指针 i , j 分列水槽左右两端；</li>
<li>循环收窄： 直至双指针相遇时跳出；</li>
<li>更新面积最大值 res ；</li>
<li>选定两板高度中的短板，向中间收窄一格；</li>
<li>返回值： 返回面积最大值 res 即可；</li>
</ol>
</blockquote>
<pre><code class="java">    public int maxArea(int[] height) &#123;
        int res = 0;        //结果
        int S = 0;            //每次循环时的面积
        int i = 0,j = height.length - 1;
        while(i &lt; j)&#123;
            S = Math.min(height[i],height[j]) * (j - i);
            res = Math.max(res,S);
            //选择移动的指针
            if(height[i] &lt; height[j])&#123;
                i++;
            &#125;else&#123;
                j--;
            &#125;
        &#125;
        return res;
    &#125;
</code></pre>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>双指针</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>创建线程的方式</title>
    <url>/2021/09/24/%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/58821827">原文链接</a></p>
<span id="more"></span>

<p>我们常说的方式有以下三种：</p>
<blockquote>
<p>继承Thread<br>实现Runable接口<br>实现Callable接口（可以获取线程执行之后的返回值）</p>
</blockquote>
<p>但实际后两种，更准确的理解是创建了一个可执行的任务，要采用多线程的方式执行，</p>
<p>还需要通过创建Thread对象来执行，比如 new Thread(new Runnable(){}).start();这样的方式来执行。</p>
<p>在实际开发中，我们通常采用线程池的方式来完成Thread的创建，更好管理线程资源。</p>
<p>案例：如何正确启动线程</p>
<pre><code class="java">class MyThread extends Thread&#123;
    @Override
    public void run() &#123;
        System.out.println(Thread.currentThread().getName()+&quot;:running......&quot;);
    &#125;
&#125;

public static void main(String[] args) &#123;
    MyThread thread = new MyThread();
    //正确启动线程的方式
    //thread.run();     //调用run方法并非开启线程
    thread.start();
&#125;
</code></pre>
<p>案例：实现runnable只是创建了一个可执行任务，并不是一个线程</p>
<pre><code class="java">class MyTask implements Runnable&#123;
    @Override
    public void run() &#123;
        System.out.println(Thread.currentThread().getName()+&quot;:running......&quot;);
    &#125;
&#125;

public static void main(String[] args) &#123;
    MyTask task = new MyTask();
    //task.start();     //并不能直接以线程的方式来启动
    new Thread(task).start();
&#125;
</code></pre>
<p>案例三：runnable vs callable</p>
<pre><code class="java">class MyTask2 implements Callable&lt;String&gt;&#123;
    @Override
    public String call() throws Exception &#123;
        return Thread.currentThread().getName() + &quot;:running......&quot;;
    &#125;
&#125;
// java5提供了Future接口来代表Callable接口里的call()方法的返回值，并为Future接口提供了一个FutureTask实现类，该实现类实现了Future接口，并实现了Runnable接口，所以这样可以作为Thread的target。
//通过FutuerTask类的对象的get()方法来获取线程结束后的返回值
public static void main(String[] args) &#123;
    MyTask2 task2 = new MyTask2();
    FutureTask&lt;String&gt; futureTask = new FutureTask&lt;&gt;(task2);

    Thread thread1 = new Thread(futureTask,&quot;我是futureTask线程&quot;);
    thread1.start();
    try &#123;
        System.out.println(futureTask.get());
    &#125; catch (Exception e) &#123;
        e.printStackTrace();
    &#125;
&#125;
</code></pre>
<p>明确一点：</p>
<p><strong>本质上来说创建线程的方式就是继承Thread，就是线程池，内部也是创建好线程对象来执行任务。</strong></p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划刷题指南</title>
    <url>/2021/09/17/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<span id="more"></span>

<h4 id="LeetCode-139-单词拆分"><a href="#LeetCode-139-单词拆分" class="headerlink" title="LeetCode 139. 单词拆分"></a>LeetCode <a href="https://leetcode-cn.com/problems/word-break/">139. 单词拆分</a></h4><ol>
<li><p><code>dp[i*]</code> 表示字符串 <code>s</code> 前 <code>i</code> 个字符组成的字符串 <code>s[0..i-1]</code> 是否能被空格拆分成若干个字典中出现的单词 </p>
</li>
<li><p>在前 <code>i</code> 个字符组成的字符串找个位置 <code>j</code> 将字符串切成  <code>s[0..j-1]</code> 和 <code>s[j...i-1]</code> ,因此只需判断 <code>dp[j]</code> 是否为 <code>true</code> 以及后续单词 <code>s[j...i-1]</code>是否存在于列表中。</p>
</li>
<li><p>得出公式：</p>
<p> ​                <code>dp[i]</code> &#x3D; <code>dp[j]</code> &amp;&amp; <code>checks( s[j...i-1] )</code>;</p>
</li>
<li><p>对于边界条件，我们定义 dp[0]&#x3D;true 表示空串且合法。</p>
</li>
</ol>
<pre><code class="java">    public boolean wordBreak(String s, List&lt;String&gt; wordDict) &#123;
        //dp[i] 表示字符串 s 前 i 个字符组成的字符串 s[0..i-1] 是否能被空格拆分成若干个字典中出现的单词
        HashSet&lt;String&gt; wordDictSet = new HashSet&lt;&gt;(wordDict);
        int n = s.length();
        boolean[] dp = new boolean[n + 1];
        dp[0] = true;
        for(int i = 1;i &lt;= n;i++)&#123;
            for(int j = 0;j &lt; i;j++)&#123;
                if(dp[j] &amp;&amp; wordDictSet.contains(s.substring(j,i)))&#123;
                    dp[i] = true;
                    break;
                &#125;
            &#125;
        &#125;
        return dp[n];
    &#125;
</code></pre>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>复制SpringBoot基础模块</title>
    <url>/2022/04/08/%E5%A4%8D%E5%88%B6SpringBoot%E5%9F%BA%E7%A1%80%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<p>复制SpringBoot基础模块以便后续练习使用。</p>
<span id="more"></span>

<h3 id="复制SpringBoot基础模块"><a href="#复制SpringBoot基础模块" class="headerlink" title="复制SpringBoot基础模块"></a>复制SpringBoot基础模块</h3><p><strong>步骤一：</strong>创建一个SpringBoot项目（springboot_base）</p>
<p><strong>步骤二：</strong>在工作空间中复制对应的工程，并修改工程名称</p>
<p><img src="/2022/04/08/%E5%A4%8D%E5%88%B6SpringBoot%E5%9F%BA%E7%A1%80%E6%A8%A1%E5%9D%97/image-20220408204922686.png" alt="image-20220408204922686"></p>
<p><strong>步骤三：</strong>删除Idea相关配置文件，仅保留src目录与pom.xml文件</p>
<p><img src="/2022/04/08/%E5%A4%8D%E5%88%B6SpringBoot%E5%9F%BA%E7%A1%80%E6%A8%A1%E5%9D%97/image-20220408205055622.png" alt="image-20220408205055622"></p>
<p><strong>步骤四：</strong>修改pom.xml文件中artifactId与新工程&#x2F;模块名相同</p>
<p><strong>步骤五：</strong>删除name标签</p>
<pre><code class="xml">    &lt;groupId&gt;com.yang&lt;/groupId&gt;
    &lt;artifactId&gt;springboot_base&lt;/artifactId&gt;&lt;!-- 修改为新工程/模块名，注意！此处最好在导入Idea前修改 --&gt;
    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
    &lt;!-- 下面两行可以选择删除 --&gt;
    &lt;name&gt;springboot_01_01_quickstart&lt;/name&gt;
    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;
</code></pre>
<p><strong>步骤六：</strong>保留备份工程以便后期使用</p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>IDEA</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>岛屿问题专栏</title>
    <url>/2021/09/23/%E5%B2%9B%E5%B1%BF%E9%97%AE%E9%A2%98%E4%B8%93%E6%A0%8F/</url>
    <content><![CDATA[<p>针对岛屿问题的专栏</p>
<span id="more"></span>

<h4 id="LeetCode-733-图像渲染"><a href="#LeetCode-733-图像渲染" class="headerlink" title="LeetCode 733. 图像渲染"></a>LeetCode <a href="https://leetcode-cn.com/problems/flood-fill/">733. 图像渲染</a></h4><p><strong>做岛屿前可以先品一品这题，思路和解法都与岛屿问题很像。</strong></p>
<blockquote>
<p>「方法一」DFS</p>
</blockquote>
<pre><code class="java">class Solution &#123;
    int[] dx = &#123;1,0,0,-1&#125;;
    int[] dy = &#123;0,1,-1,0&#125;;

    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) &#123;
        if(newColor == image[sr][sc]) return image;
        int pastColor = image[sr][sc];
        dfs(image,sr,sc,newColor,pastColor);
        return image;
    &#125;

    public void dfs(int[][] image, int sr, int sc, int newColor,int pastColor)&#123;
        if(sr &lt; 0 || sr &gt;= image.length || sc &lt; 0 || sc &gt;= image[0].length || image[sr][sc] != pastColor) return;
        image[sr][sc] = newColor;
        for(int i = 0;i &lt; 4;i++)&#123;
            dfs(image,sr + dx[i],sc + dy[i],newColor,pastColor);
        &#125;
    &#125;
&#125;
</code></pre>
<blockquote>
<p>「方法二」BFS</p>
</blockquote>
<pre><code class="java">class Solution &#123;
    int[] dx = &#123;1,0,0,-1&#125;;
    int[] dy = &#123;0,1,-1,0&#125;;

    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) &#123;
        if(newColor == image[sr][sc]) return image;
        int pastColor = image[sr][sc];
        image[sr][sc] = newColor;
        Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;();
        queue.offer(new int[]&#123;sr,sc&#125;);
        while(!queue.isEmpty())&#123;
            int[] cell = queue.poll();
            for(int i = 0;i &lt; 4;i++)&#123;
                int x = cell[0] + dx[i];
                int y = cell[1] + dy[i];
                if(x &gt;= 0 &amp;&amp; x &lt; image.length &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; image[0].length &amp;&amp; image[x][y] == pastColor)&#123;
                    queue.offer(new int[]&#123;x,y&#125;);
                    image[x][y] = newColor;
                &#125;
            &#125;
        &#125;
        return image;
    &#125;
&#125;
</code></pre>
<h4 id="LeetCode-200-岛屿数量"><a href="#LeetCode-200-岛屿数量" class="headerlink" title="LeetCode 200. 岛屿数量"></a>LeetCode <a href="https://leetcode-cn.com/problems/number-of-islands/">200. 岛屿数量</a></h4><blockquote>
<p>「方法一」DFS</p>
</blockquote>
<pre><code class="java">class Solution &#123;
    public int numIslands(char[][] grid) &#123;
        int ans = 0;
        int rn = grid.length;
        int cn = grid[0].length;
        for(int i = 0; i &lt; rn ; i++)&#123;
            for(int j = 0 ; j &lt; cn ; j++)&#123;
                if(grid[i][j] == &#39;1&#39;)&#123;
                    ++ans;
                    dfs(grid,i,j);
                &#125;

            &#125;
        &#125;
        return ans;
    &#125;

    public void dfs(char[][] grid,int row,int col)&#123;
        if(row &lt; 0 || row &gt;= grid.length || col &lt; 0 || col &gt;=grid[0].length || grid[row][col] == &#39;0&#39;) return;

        grid[row][col] = &#39;0&#39;;
        dfs(grid,row + 1,col);
        dfs(grid,row - 1,col);
        dfs(grid,row,col + 1);
        dfs(grid,row,col - 1);
    &#125;
&#125;
</code></pre>
<blockquote>
<p>「方法二」BFS</p>
</blockquote>
<blockquote>
<p>「方法三」并查集（还没研究，再嗦）</p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>DFS/BFS</tag>
        <tag>LeetCode</tag>
        <tag>岛屿问题</tag>
      </tags>
  </entry>
  <entry>
    <title>常见排序解析</title>
    <url>/2022/03/17/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p><img src="/2022/03/17/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E8%A7%A3%E6%9E%90/image-20220314162907253.png" alt="image-20220314162907253"></p>
<span id="more"></span>

<h3 id="一、选择排序"><a href="#一、选择排序" class="headerlink" title="一、选择排序"></a>一、选择排序</h3><blockquote>
<p>思想：</p>
<ul>
<li>每一次遍历寻找最小值，记录最小值以及对应的下标；</li>
<li>交换下标 i 与最小值的位置；</li>
</ul>
</blockquote>
<pre><code class="java">    public int[] selctionSort(int[] arr)&#123;
        int min = arr[0];
        int minPos = 0;
        int n = arr.length;
        for(int i = 0; i &lt; n; i++)&#123;
            min = arr[i];
            minPos = i;
            for(int j = i+1; j &lt; n; j++)&#123;
                if(arr[j] &lt; min)&#123;
                    minPos = j;
                    min = arr[j];
                &#125;
            &#125;
            if(minPos != i)&#123;
                int temp = arr[minPos];
                arr[minPos] = arr[i];
                arr[i] = temp;
            &#125;
        &#125;
        return arr;
    &#125;
</code></pre>
<h3 id="二、冒泡排序"><a href="#二、冒泡排序" class="headerlink" title="二、冒泡排序"></a>二、冒泡排序</h3><blockquote>
<p>思想：</p>
<ul>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ul>
</blockquote>
<pre><code class="java">    public void BubbleSort(int[] arr)&#123;
        int n = arr.length;
        for(int i = 0; i &lt; n; i++)&#123;
            //判断当前循环是否进行了交换，如果没有进行交换，说明数据已经排序好
            boolean flag = false;
            for(int j = 0; j &lt; n - i - 1; j++)&#123;
                if(arr[j] &gt; arr[j+1])&#123;
                    swap(arr,j,j+1);
                    flag = true;
                &#125;
            &#125;
            if(!flag) break;
        &#125;
    &#125;
</code></pre>
<h3 id="三、插入排序"><a href="#三、插入排序" class="headerlink" title="三、插入排序"></a>三、插入排序</h3><blockquote>
<p>思想：</p>
<ul>
<li>将数组分为左、右两个部分</li>
<li>左边部分为已排序，右边部分为未排序</li>
<li>每次取右边部分第一个数，插入在左边部分</li>
</ul>
</blockquote>
<pre><code class="java">    public void InsertionSort(int[] arr)&#123;
        int n = arr.length;
        for(int i = 1; i &lt; n; i++)&#123;
            int temp = arr[i];
            int j = i;
            while(j &gt; 0 &amp;&amp; arr[j-1] &gt; temp)&#123;
                arr[j] = arr[j-1];
                j--;
            &#125;
            if(j != i) arr[j] = temp;
        &#125;
    &#125;
</code></pre>
<h3 id="四、堆排序"><a href="#四、堆排序" class="headerlink" title="四、堆排序"></a>四、堆排序</h3><blockquote>
<p>思想：</p>
<p>* </p>
</blockquote>
<pre><code class="java">
</code></pre>
<h3 id="五、希尔排序"><a href="#五、希尔排序" class="headerlink" title="五、希尔排序"></a>五、希尔排序</h3><blockquote>
<p>思想：</p>
<p>* </p>
</blockquote>
<pre><code class="java">
</code></pre>
<h3 id="六、归并排序"><a href="#六、归并排序" class="headerlink" title="六、归并排序"></a>六、归并排序</h3><blockquote>
<p>思想：</p>
<ul>
<li>把长度为n的输入序列分成两个长度为n&#x2F;2的子序列；</li>
<li>对这两个子序列分别采用归并排序；</li>
<li>将两个排序好的子序列合并成一个最终的排序序列。</li>
</ul>
</blockquote>
<p><strong>动图演示：</strong></p>
<p><img src="/2022/03/17/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E8%A7%A3%E6%9E%90/v2-cdda3f11c6efbc01577f5c29a9066772_b.webp" alt="img"></p>
<pre><code class="java">    public void MergeSort(int[] arr,int left,int right)&#123;
        if(left &gt;= right) return;
        int mid = left + ((right - left) &gt;&gt; 1);
        MergeSort(arr,left,mid);
        MergeSort(arr,mid + 1,right);
        Merge(arr,left,mid,right);
    &#125;

    public void Merge(int[] arr,int left,int mid,int right)&#123;
        int idx = 0;
        int p1 = left;
        int p2 = mid+1;
        int[] temp = new int[right - left + 1];
        while(p1 &lt;= mid &amp;&amp; p2 &lt;= right)&#123;
            temp[idx++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++];
        &#125;
        while(p1 &lt;= mid)&#123;
            temp[idx++] = arr[p1++];
        &#125;
        while(p2 &lt;= right)&#123;
            temp[idx++] = arr[p2++];
        &#125;
        for(int i = 0; i &lt; temp.length; i++)&#123;
            arr[left+i] = temp[i];
        &#125;
    &#125;
</code></pre>
<h3 id="七、快速排序"><a href="#七、快速排序" class="headerlink" title="七、快速排序"></a>七、快速排序</h3><blockquote>
<p>思想：</p>
<ul>
<li>从数列中挑出一个元素，称为 “基准”（pivot）</li>
<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li>
<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</li>
</ul>
</blockquote>
<pre><code class="java">    /**
    快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。
    但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。
    所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。
    */
    public void QuickSort(int[] arr)&#123;
        Quick(arr,0,arr.length-1);
    &#125;

    public void Quick(int[] arr,int left,int right)&#123;
        if(left &gt;= right) return;
        int base = arr[left + ((right - left) &gt;&gt; 1)];
        int l = left - 1;
        int r = right + 1;
        while(l &lt; r)&#123;
            while(arr[++l] &lt; base);
            while(arr[--r] &gt; base);
            if(l &lt; r)&#123;
                swap(arr,l,r);
            &#125;
        &#125;
        Quick(arr,left,r);
        Quick(arr,r+1,right);
    &#125;
</code></pre>
<h3 id="八、桶排序"><a href="#八、桶排序" class="headerlink" title="八、桶排序"></a>八、桶排序</h3><blockquote>
<p>思想：</p>
<p>* </p>
</blockquote>
<pre><code class="java">
</code></pre>
<h3 id="九、计数排序"><a href="#九、计数排序" class="headerlink" title="九、计数排序"></a>九、计数排序</h3><blockquote>
<p>思想：</p>
<ul>
<li>找出待排序的数组中最大和最小的元素</li>
<li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项</li>
<li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）</li>
<li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1</li>
</ul>
</blockquote>
<pre><code class="java">    /**
    当输入的元素是 n 个 0 到 k 之间的整数时，它的运行时间是 Θ(n + k)。
    计数排序不是比较排序，排序的速度快于任何比较排序算法。
    由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。
    例如：计数排序是用来排序0到100之间的数字的最好的算法，但是它不适合按字母顺序排序人名。
    这里计数排序只考虑了数组最小值为0，最小值为负数可以选择其它排序。
    */
    public void CountingSort(int[] arr)&#123;
        int max = arr[0];
        for(int i:arr) max = Math.max(i,max);
        int[] counts = new int[max+1];
        for(int val:arr)&#123;
            counts[val]++;
        &#125;
        int idx = 0;
        for(int i = 0; i &lt;= max; i++)&#123;
            while(counts[i] &gt; 0)&#123;
                arr[idx++] = i;
                counts[i]--;
            &#125;
        &#125;
    &#125;
</code></pre>
<h3 id="十、基数排序"><a href="#十、基数排序" class="headerlink" title="十、基数排序"></a>十、基数排序</h3><blockquote>
<p>思想：</p>
<p>* </p>
</blockquote>
<pre><code class="java">
</code></pre>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统面经</title>
    <url>/2021/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E7%BB%8F/</url>
    <content><![CDATA[<!--mroe-->
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>我的第一篇博客文章</title>
    <url>/2021/09/07/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<p>#第一章<br>hhh</p>
<hr>
<p>#第二章<br>hhh</p>
<hr>
<p>#第三章<br><a href="http://www.baidu.com/">www.baidu.com</a></p>
]]></content>
      <categories>
        <category>test</category>
      </categories>
      <tags>
        <tag>test1</tag>
      </tags>
  </entry>
  <entry>
    <title>滑动窗口刷题指南</title>
    <url>/2021/09/17/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>出现以下情况时，考虑滑动窗口：</p>
<ol>
<li>涉及到子串</li>
</ol>
<span id="more"></span>

<h4 id="LeetCode-3-无重复字符的最长子串"><a href="#LeetCode-3-无重复字符的最长子串" class="headerlink" title="LeetCode 3. 无重复字符的最长子串"></a>LeetCode <a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h4><h4 id="LeetCode-30-串联所有单词的子串"><a href="#LeetCode-30-串联所有单词的子串" class="headerlink" title="LeetCode 30. 串联所有单词的子串"></a>LeetCode <a href="https://leetcode-cn.com/problems/substring-with-concatenation-of-all-words/">30. 串联所有单词的子串</a></h4><h4 id="LeetCode-76-最小覆盖子串"><a href="#LeetCode-76-最小覆盖子串" class="headerlink" title="LeetCode 76. 最小覆盖子串"></a>LeetCode <a href="https://leetcode-cn.com/problems/minimum-window-substring/">76. 最小覆盖子串</a></h4><h4 id="LeetCode-159-至多包含两个不同字符的最长子串"><a href="#LeetCode-159-至多包含两个不同字符的最长子串" class="headerlink" title="LeetCode 159. 至多包含两个不同字符的最长子串"></a>LeetCode <a href="https://leetcode-cn.com/problems/longest-substring-with-at-most-two-distinct-characters/">159. 至多包含两个不同字符的最长子串</a></h4><h4 id="LeetCode-209-长度最小的子数组"><a href="#LeetCode-209-长度最小的子数组" class="headerlink" title="LeetCode 209. 长度最小的子数组"></a>LeetCode <a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/">209. 长度最小的子数组</a></h4><h4 id="LeetCode-239-滑动窗口最大值"><a href="#LeetCode-239-滑动窗口最大值" class="headerlink" title="LeetCode 239. 滑动窗口最大值"></a>LeetCode <a href="https://leetcode-cn.com/problems/sliding-window-maximum/">239. 滑动窗口最大值</a></h4><h4 id="LeetCode-567-字符串的排列"><a href="#LeetCode-567-字符串的排列" class="headerlink" title="LeetCode 567. 字符串的排列"></a>LeetCode <a href="https://leetcode-cn.com/problems/permutation-in-string/">567. 字符串的排列</a></h4><h4 id="LeetCode-632-最小区间"><a href="#LeetCode-632-最小区间" class="headerlink" title="LeetCode 632. 最小区间"></a>LeetCode <a href="https://leetcode-cn.com/problems/smallest-range/">632. 最小区间</a></h4><h4 id="LeetCode-727-最小窗口子序列"><a href="#LeetCode-727-最小窗口子序列" class="headerlink" title="LeetCode 727. 最小窗口子序列"></a>LeetCode <a href="https://leetcode-cn.com/problems/minimum-window-subsequence/">727. 最小窗口子序列</a></h4>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>数组刷题指南</title>
    <url>/2021/09/14/%E6%95%B0%E7%BB%84%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>原题链接：</p>
<p><a href="https://leetcode-cn.com/problems/contains-duplicate/">LeetCode 217. 存在重复元素</a></p>
<p><a href="https://leetcode-cn.com/problems/maximum-subarray/">LeetCode 53. 最大子序和</a></p>
<span id="more"></span>

<h4 id="LeetCode-217-存在重复元素"><a href="#LeetCode-217-存在重复元素" class="headerlink" title="LeetCode 217. 存在重复元素"></a>LeetCode 217. 存在重复元素</h4><blockquote>
<p>方法一：排序后查找</p>
</blockquote>
<pre><code class="java">    public boolean containsDuplicate(int[] nums) &#123;
        Arrays.sort(nums);
        for(int i = 0;i &lt; nums.length - 1;i++)&#123;
            if(nums[i] == nums[i+1])&#123;
                return true;
            &#125;
        &#125;
        return false;
    &#125;
</code></pre>
<blockquote>
<p>方法二：HashMap方法</p>
</blockquote>
<pre><code class="java">    public boolean containsDuplicate(int[] nums) &#123;
        Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();
        for(int num:nums)&#123;
            if(map.get(num) == null)&#123;
                map.put(num,1);
            &#125;else&#123;
                return true;
            &#125;
        &#125;
        return false;
    &#125;
</code></pre>
<h4 id="LeetCode-53-最大子序和"><a href="#LeetCode-53-最大子序和" class="headerlink" title="LeetCode 53. 最大子序和"></a>LeetCode 53. 最大子序和</h4><blockquote>
<p>方法一：动态规划</p>
</blockquote>
<pre><code class="java">    //原始递归
    public int maxSubArray(int[] nums) &#123;
        int ans = Integer.MIN_VALUE;
        for(int i = 0;i &lt; nums.length;i++)&#123;
            ans = Math.max(ans,dp(nums,i));
        &#125;
        return ans;
    &#125;
    //dp(i)表示以第i个数结尾的「连续子数组的最大和」
    public int dp(int[] nums,int i)&#123;
        if(i == 0) return nums[0];
        return Math.max(dp(nums,i - 1) + nums[i] , nums[i]);
    &#125;
</code></pre>
<pre><code class="java">    //改良版
    public int maxSubArray(int[] nums) &#123;
        int pre = 0;
        int ans = Integer.MIN_VALUE;
        for(int num:nums)&#123;
            pre = Math.max(pre + num , num );
            ans = Math.max(pre,ans);
        &#125;
        return ans;
    &#125;
</code></pre>
<blockquote>
<p>方法二：分治（还没研究，再嗦）</p>
</blockquote>
<h4 id="LeetCode-1-两数之和"><a href="#LeetCode-1-两数之和" class="headerlink" title="LeetCode 1. 两数之和"></a>LeetCode 1. 两数之和</h4><blockquote>
<p>使用HashMap存储数据查找第二个数</p>
</blockquote>
<pre><code class="java">    public int[] twoSum(int[] nums, int target) &#123;
        Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();
        for(int i = 0;i &lt; nums.length;i++)&#123;
            if(map.containsKey(target - nums[i]))&#123;
                return new int[]&#123;map.get(target - nums[i]),i&#125;;
            &#125;
            map.put(nums[i],i);
        &#125;
        return new int[]&#123;0,1&#125;;
    &#125;
</code></pre>
<h4 id="LeetCode-88-合并两个有序数组"><a href="#LeetCode-88-合并两个有序数组" class="headerlink" title="LeetCode 88. 合并两个有序数组"></a>LeetCode 88. 合并两个有序数组</h4><blockquote>
<p>使用双指针指向两个数组，开辟一个新数组，将数据存到新数组中。</p>
</blockquote>
<pre><code>    public void merge(int[] nums1, int m, int[] nums2, int n) &#123;
        int[] sorted = new int[m + n];
        int p1 = 0,p2 = 0;
        int cur;
        while(p1 &lt; m || p2 &lt; n)&#123;
            if(p1 == m)&#123;
                cur = nums2[p2++];
            &#125;else if(p2 == n)&#123;
                cur = nums1[p1++];
            &#125;else if(nums1[p1] &lt; nums2[p2])&#123;
                cur = nums1[p1++];
            &#125;else&#123;
                cur = nums2[p2++];
            &#125;
            sorted[p1 + p2 - 1] = cur;
        &#125;
        System.arraycopy(sorted,0,nums1,0,m+n);
    &#125;
</code></pre>
<h4 id="LeetCode-73-矩阵置零"><a href="#LeetCode-73-矩阵置零" class="headerlink" title="LeetCode 73. 矩阵置零"></a>LeetCode 73. 矩阵置零</h4><blockquote>
<p>使用matrix数组的第0行、第0列存储二维数组中的0的标志信息，但是在这之前要先判断第0行或第0列是否存在0，如果存在后续还需处理第0行、第0列。</p>
<p>时间复杂度：O(nm)</p>
<p>空间复杂度：O(1)</p>
</blockquote>
<pre><code class="java">class Solution &#123;
    public void setZeroes(int[][] matrix) &#123;
        //第0行或第0列是否存在0；
        Boolean flag_row0 = false;
        Boolean flag_col0 = false;
        int row = matrix.length;
        int col = matrix[0].length;
        //先判断第0行或第0列是否存在0
        for(int i = 0;i &lt; row;i++)&#123;
            if(matrix[i][0] == 0)&#123;
                flag_col0 = true;
            &#125;
        &#125;
        for(int j = 0;j &lt; col;j++)&#123;
            if(matrix[0][j] == 0)&#123;
                flag_row0 = true;
            &#125;
        &#125;
        //使用第0行，第0列标记
        for(int i = 1; i &lt; row;i++)&#123;
            for(int j = 1; j &lt; col;j++)&#123;
                if(matrix[i][j] == 0)&#123;
                    matrix[i][0] = matrix[0][j] = 0;
                &#125;
            &#125;
        &#125;
        //赋值0；
        for(int i = 1; i &lt; row;i++)&#123;
            for(int j = 1; j &lt; col;j++)&#123;
                if(matrix[i][0] == 0 || matrix[0][j] == 0)&#123;
                    matrix[i][j] = 0;
                &#125;
            &#125;
        &#125;
        if(flag_row0)&#123;
            for(int j = 0;j &lt; col;j++)&#123;
                matrix[0][j] = 0;
            &#125;
        &#125;
        if(flag_col0)&#123;
            for(int i = 0;i &lt; row;i++)&#123;
                matrix[i][0] = 0;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="LeetCode-121-买卖股票的最佳时机"><a href="#LeetCode-121-买卖股票的最佳时机" class="headerlink" title="LeetCode 121. 买卖股票的最佳时机"></a>LeetCode <a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></h4><blockquote>
<p>方法一：和LeetCode 53. 最大子序和有点像。</p>
</blockquote>
<pre><code>    public int maxProfit(int[] prices) &#123;
        int maxAns = 0;
        //f(i)表示第i天买出可获得的最大利润
        int fi = 0;
        for(int i = 1;i &lt; prices.length;i++)&#123;
            if(i == 1)&#123;
                fi = Math.max(0,prices[i] - prices[i-1]);
            &#125;else&#123;
                fi = Math.max(fi+prices[i] - prices[i-1],prices[i] - prices[i-1]);
            &#125;
            maxAns = Math.max(fi,maxAns);
        &#125;
        return maxAns;
    &#125;
</code></pre>
<blockquote>
<p>方法二：前i天的最大收益 &#x3D; max{前i-1天的最大收益，第i天的价格-前i-1天中的最小价格}</p>
<ol>
<li>记录【今天之前买入的最小值】</li>
<li>计算【今天之前最小值买入，今天卖出的获利】，也即【今天卖出的最大获利】</li>
<li>比较【每天的最大获利】，取最大值即可</li>
</ol>
</blockquote>
<pre><code class="java">    public int maxProfit(int[] prices) &#123;
        int maxAns = 0;
        //记录【今天之前买入的最小值】
        int min = prices[0];
        for(int i = 1; i &lt; prices.length;i++)&#123;
            maxAns = Math.max(maxAns,prices[i] - min);
            min = Math.min(min,prices[i]);
        &#125;
        return maxAns;
    &#125;
</code></pre>
<h4 id="LeetCode-350-两个数组的交集-II"><a href="#LeetCode-350-两个数组的交集-II" class="headerlink" title="LeetCode 350. 两个数组的交集 II"></a>LeetCode <a href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/">350. 两个数组的交集 II</a></h4><blockquote>
<p>方法一：HashMap存储数组</p>
</blockquote>
<pre><code class="java">    public int[] intersect(int[] nums1, int[] nums2) &#123;
        Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();
        for(int num1:nums1)&#123;
            if(!map.containsKey(num1))&#123;
                map.put(num1,1);
            &#125;else&#123;
                map.put(num1,map.get(num1) + 1);
            &#125;
        &#125;
        List&lt;Integer&gt; ansList = new ArrayList&lt;&gt;();
        for(int num2:nums2)&#123;
            if(map.containsKey(num2) &amp;&amp; map.get(num2) &gt; 0)&#123;
                ansList.add(num2);
                map.put(num2,map.get(num2) - 1);
            &#125;
        &#125;
        int[] arr = new int[ansList.size()];
        for(int i = 0;i &lt; ansList.size();i++)&#123;
            arr[i] = ansList.get(i);
        &#125;
        return arr;
    &#125;
</code></pre>
<blockquote>
<p>方法二：排序+双指针</p>
</blockquote>
<pre><code>class Solution &#123;
    public int[] intersect(int[] nums1, int[] nums2) &#123;
        Arrays.sort(nums1);
        Arrays.sort(nums2);
        int p1 = 0,p2 = 0;
        ArrayList&lt;Integer&gt; ansList = new ArrayList&lt;&gt;();
        while(p1 &lt; nums1.length &amp;&amp; p2 &lt; nums2.length)&#123;
            if(nums1[p1] == nums2[p2])&#123;
                ansList.add(nums1[p1]);
                p1++;
                p2++;
            &#125;else if(nums1[p1] &lt; nums2[p2])&#123;
                p1++;
            &#125;else&#123;
                p2++;
            &#125;
        &#125;
        int[] ans = new int[ansList.size()];
        int i = 0;
        for(int an:ansList)&#123;
            ans[i++] = an;
        &#125;
        return ans;
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数据结构</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>背包问题</title>
    <url>/2021/10/24/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>程序员节刷<a href="https://leetcode-cn.com/problems/shopping-offers/">LeetCode每日一题(638)</a>，发现是个背包问题，无从下笔，决定仔细研究一番背包问题</p>
<span id="more"></span>

<h4 id="ACWing-2-01背包问题"><a href="#ACWing-2-01背包问题" class="headerlink" title="ACWing 2. 01背包问题"></a><a href="https://www.acwing.com/problem/content/2/">ACWing 2. 01背包问题</a></h4><p><img src="C:\Users\yangyi\Desktop\工作\images\1（7）.png" alt="1（7）"></p>
<pre><code class="java">import java.util.*;

public class Main&#123;
    final static int N = 1010;
    static int n,m;
    static int[] v = new int[N];//体积列表
    static int[] w = new int[N];//价值列表
    static int[][] dp = new int[N][N];
    
    public static void main(String[] args)&#123;
        Scanner sc = new Scanner(System.in);
        n = sc.nextInt();
        m = sc.nextInt();
        for(int i = 1 ; i &lt;= n; i++)&#123;
            v[i] = sc.nextInt();
            w[i] = sc.nextInt();
        &#125;
        for(int i = 1; i &lt;= n; i++)&#123;
            for(int j = 0; j &lt;= m; j++)&#123;
                if(j &lt; v[i])&#123;
                    dp[i][j] = dp[i-1][j];
                &#125;else&#123;
                    dp[i][j] = Math.max(dp[i-1][j],dp[i-1][j-v[i]] + w[i]);
                &#125;
            &#125;
        &#125;
        System.out.println(dp[n][m]);
    &#125;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>模板题</tag>
        <tag>背包问题</tag>
        <tag>DP</tag>
        <tag>ACWing</tag>
      </tags>
  </entry>
  <entry>
    <title>算法工具函数汇总</title>
    <url>/2021/09/13/%E7%AE%97%E6%B3%95%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<p>将刷算法题中的遇到和用到的工具函数汇总。</p>
<span id="more"></span>

<h3 id="一、数学"><a href="#一、数学" class="headerlink" title="一、数学"></a>一、数学</h3><h4 id="判断一个数是否是2的n次方"><a href="#判断一个数是否是2的n次方" class="headerlink" title="判断一个数是否是2的n次方"></a>判断一个数是否是2的n次方</h4><pre><code class="java">    public boolean isPowerOfTwo(int n) &#123;
        return n &gt; 0 &amp;&amp; (n &amp; (n - 1)) == 0;
    &#125;
</code></pre>
<h4 id="求最大公约数和最小公倍数"><a href="#求最大公约数和最小公倍数" class="headerlink" title="求最大公约数和最小公倍数"></a>求最大公约数和最小公倍数</h4><pre><code class="java">    //最大公约数
    public int gcd(int x,int y)&#123;
        return y &gt; 0 ? gcd(y , x % y) : x;
    &#125;
    //最小公倍数
    public int lcm(int x,int y)&#123;
            return x / gdc(x, y) * y;
    &#125;
</code></pre>
<h3 id="二、数组操作"><a href="#二、数组操作" class="headerlink" title="二、数组操作"></a>二、数组操作</h3><h4 id="复制数组内容"><a href="#复制数组内容" class="headerlink" title="复制数组内容"></a>复制数组内容</h4><pre><code class="java">    //复制数组
    System.arraycopy(fromArr,0,toArr,0,len);
</code></pre>
<h4 id="排序二维数组"><a href="#排序二维数组" class="headerlink" title="排序二维数组"></a>排序二维数组</h4><pre><code class="java">    Arrays.sort(arr, (o1, o2) -&gt; Integer.compare(o1[0], o2[0]));
</code></pre>
<h4 id="List-lt-int-gt-转换为int"><a href="#List-lt-int-gt-转换为int" class="headerlink" title="List&lt;int[ ]&gt;转换为int[ ][ ]"></a>List&lt;int[ ]&gt;转换为int[ ][ ]</h4><pre><code class="java">    arr.toArray(new int[arr.size()][]);
</code></pre>
<h4 id="List-lt-String-gt-转换为String"><a href="#List-lt-String-gt-转换为String" class="headerlink" title="List&lt;String&gt;转换为String[]"></a>List&lt;String&gt;转换为String[]</h4><pre><code class="java">    arr.toArray(new String[arr.size()]);
</code></pre>
<h3 id="三、字符串操作"><a href="#三、字符串操作" class="headerlink" title="三、字符串操作"></a>三、字符串操作</h3><h4 id="String类型转换大小写"><a href="#String类型转换大小写" class="headerlink" title="String类型转换大小写"></a>String类型转换大小写</h4><pre><code class="java">    s = s.toLowerCase();//转小写
    s = s.toUpperCase();//转大写
</code></pre>
<h4 id="Character类型转换大小写"><a href="#Character类型转换大小写" class="headerlink" title="Character类型转换大小写"></a>Character类型转换大小写</h4><pre><code class="java">    ch = Character.toLowerCase(ch);
    ch = Character.toUpperCase(ch);
</code></pre>
<h3 id="四、位运算"><a href="#四、位运算" class="headerlink" title="四、位运算"></a>四、位运算</h3><h4 id="Java位运算相加-C-和Python需要额外处理负数"><a href="#Java位运算相加-C-和Python需要额外处理负数" class="headerlink" title="Java位运算相加(C++和Python需要额外处理负数)"></a>Java位运算相加(C++和Python需要额外处理负数)</h4><pre><code class="java">    public int add(int a, int b) &#123;
        return b == 0 ? a : add(a ^ b, (a &amp; b) &lt;&lt; 1);
    &#125;
</code></pre>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>工具函数</tag>
        <tag>汇总</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络【HTTP篇】</title>
    <url>/2022/03/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%90HTTP%E7%AF%87%E3%80%91/</url>
    <content><![CDATA[<p>原文：图解网络-小林coding-v3.0</p>
<span id="more"></span>

<h2 id="一-HTTP常见面试题"><a href="#一-HTTP常见面试题" class="headerlink" title="一. HTTP常见面试题"></a>一. HTTP常见面试题</h2><p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%90HTTP%E7%AF%87%E3%80%91/image-20220314211641570.png" alt="image-20220314211641570"></p>
<h3 id="HTTP基本概念"><a href="#HTTP基本概念" class="headerlink" title="HTTP基本概念"></a>HTTP基本概念</h3><blockquote>
<p>HTTP是什么？描述一下</p>
</blockquote>
<p>HTTP 是超⽂本传输协议，也就是HyperText Transfer Protocol。</p>
<blockquote>
<p>能否详细解释「超⽂本传输协议」？</p>
</blockquote>
<p>HTTP的名字「超⽂本协议传输」，它可以拆成三个部分： </p>
<ul>
<li>超⽂本</li>
<li>传输</li>
<li>协议</li>
</ul>
<p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%90HTTP%E7%AF%87%E3%80%91/image-20220314212056218.png" alt="image-20220314212056218"></p>
<p><strong>HTTP是⼀个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。</strong></p>
<blockquote>
<p>那「HTTP 是⽤于从互联⽹服务器传输超⽂本到本地浏览器的协议 ，这种说法正确吗？</p>
</blockquote>
<p>这种说法是<strong>不正确</strong>的。因为也可以是「服务器&lt; – &gt;服务器」，所以采⽤<strong>两点之间</strong>的描述会更准确。</p>
<blockquote>
<p>HTTP 常⻅的状态码，有哪些？</p>
</blockquote>
<p><img src="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%90HTTP%E7%AF%87%E3%80%91/image-20220314212500099.png" alt="image-20220314212500099"></p>
<p><strong>2XX：</strong></p>
<p>「200 OK」是最常见的成功状态码，表示⼀切正常。如果是非 HEAD 请求，服务器返回的响应头都会有 body数据。<br>「204 No Content」也是常⻅的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。<br>「206 Partial Content」是应⽤于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的⼀部分，也是服务器处理成功的状态。</p>
<p><strong>3XX：</strong></p>
<p>3xx 类状态码表示客户端请求的资源发送了变动，需要客户端⽤新的 URL 新发送请求获取资源，也就是重定向。<br>「301 Moved Permanently」表示永久重定向，说明请求的资源已经不存在了，需改⽤新的 URL 再次访问。<br>「302 Found」表示临时重定向，说明请求的资源还在，但暂时需要⽤另⼀个 URL 来访问。<br>301 和 302 都会在响应头⾥使⽤字段 Location ，指明后续要跳转的 URL，浏览器会⾃动重定向新的 URL。<br>「304 Not Modified」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲⽂件，也称缓存重定向，⽤于缓存控制。</p>
<p><strong>4XX：</strong></p>
<p>4xx 类状态码表示客户端发送的报⽂有误，服务器⽆法处理，也就是错误码的含义。<br>「400 Bad Request」表示客户端请求的报⽂有错误，但只是个笼统的错误。<br>「403 Forbidden」表示服务器禁⽌访问资源，并不是客户端的请求出错。<br>「404 Not Found」表示请求的资源在服务器上不存在或未找到，所以⽆法提供给客户端。</p>
<p><strong>5XX：</strong></p>
<p>5xx 类状态码表示客户端请求报⽂正确，但是服务器处理时内部发⽣了错误，属于服务器端的错误码。<br>「500 Internal Server Error」与 400 类型，是个笼统通⽤的错误码，服务器发⽣了什么错误，我们并不知道。<br>「501 Not Implemented」表示客户端请求的功能还不⽀持，类似“即将开业，敬请期待”的意思。<br>「502 Bad Gateway」通常是服务器作为⽹关或代理时返回的错误码，表示服务器⾃身⼯作正常，访问后端服务器发⽣了错误。<br>「503 Service Unavailable」表示服务器当前很忙，暂时⽆法响应服务器，类似“⽹络服务正忙，请稍后重试”的意思。</p>
<h3 id="GET-与-POST"><a href="#GET-与-POST" class="headerlink" title="GET 与 POST"></a>GET 与 POST</h3><h3 id="HTTP-特性"><a href="#HTTP-特性" class="headerlink" title="HTTP 特性"></a>HTTP 特性</h3><h3 id="HTTP-与-HTTPS"><a href="#HTTP-与-HTTPS" class="headerlink" title="HTTP 与 HTTPS"></a>HTTP 与 HTTPS</h3><h3 id="HTTP-x2F-1-1、HTTP-x2F-2、HTTP-x2F-3-演变"><a href="#HTTP-x2F-1-1、HTTP-x2F-2、HTTP-x2F-3-演变" class="headerlink" title="HTTP&#x2F;1.1、HTTP&#x2F;2、HTTP&#x2F;3 演变"></a>HTTP&#x2F;1.1、HTTP&#x2F;2、HTTP&#x2F;3 演变</h3>]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络面经</title>
    <url>/2021/09/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E7%BB%8F/</url>
    <content><![CDATA[<p>原文：图解网络-小林coding-v3.0</p>
<span id="more"></span>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>面经</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>谈谈对面向对象思想的理解</title>
    <url>/2021/09/25/%E8%B0%88%E8%B0%88%E5%AF%B9%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/52368590">原文链接</a></p>
<span id="more"></span>

<p>这个问题，通常会让很多人有点不知所措，感觉我一直在编码，但是说到思想很难去阐述。</p>
<p>下面，我说说自己的想法，</p>
<p>首先，谈谈“面向过程”vs“面向对象”</p>
<p>我觉得这两者是思考角度的差异，面向过程更多是以“执行者”的角度来思考问题，而面向对象更多是以“组织者”的角度来思考问题，举个例子，比如我要产生一个0-10之间的随机数，如果以“面向过程”的思维，那我更多是关注如何去设计一个算法，然后保证比较均衡产生0-10的随机数，而面向对象的思维会更多关注，我找谁来帮我们做这件事，比如Random类，调用其中提供的方法即可。</p>
<p>所以，面向对象的思维更多的是考虑如何去选择合适的工具，然后组织到一起干一件事。</p>
<p>好比一个导演，要拍一场电影，那么首先要有男猪脚和女猪脚，然后还有其他等等，最后把这些资源组织起来，拍成一场电影。</p>
<p>再说回我们的程序世界，这个组织者的思维无处不在，比如，我们要开发项目，以三层架构的模式来开发，那么这个时候，我们不需要重复造轮子，只需要选择市面上主流的框架即可，比如SpringMVC，Spring，MyBatis，这些都是各层的主流框架。</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo+Next个人博客优化</title>
    <url>/2021/09/13/Hexo+Next%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>Hexo版本：4.3.0</p>
<p>NexT版本：7.8.0</p>
<p>整合了网上的一些资料，写了这篇在上述版本能修改优化的文章，大家根据自身的环境进行修改。</p>
<span id="more"></span>

<h3 id="设置（更换）主题风格"><a href="#设置（更换）主题风格" class="headerlink" title="设置（更换）主题风格"></a>设置（更换）主题风格</h3><p>打开 <code>themes/next/_config.yml</code> 文件，搜索  <code>scheme</code> 关键字，将你需用启用的 <code>scheme</code> 前面注释 # 去除即可。</p>
<pre><code class="bash"># ---------------------------------------------------------------
# Scheme Settings
# ---------------------------------------------------------------

# Schemes
#scheme: Muse # 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白
#scheme: Mist # Muse 的紧凑版本，整洁有序的单栏外观
scheme: Pisces # 双栏 Scheme，小家碧玉似的清新
#scheme: Gemini # 类似 Pisces
</code></pre>
<h3 id="设置菜单项的显示文本和图标"><a href="#设置菜单项的显示文本和图标" class="headerlink" title="设置菜单项的显示文本和图标"></a>设置菜单项的显示文本和图标</h3><p>NexT 使用的是 <a href="http://fontawesome.dashgame.com/">Font Awesome</a>  提供的图标， <a href="http://fontawesome.dashgame.com/">Font Awesome</a> 提供了 600+ 的图标，可以满足绝大的多数的场景，同时无须担心在 Retina 屏幕下图标模糊的问题。</p>
<h4 id="设置菜单项的显示中文文本："><a href="#设置菜单项的显示中文文本：" class="headerlink" title="设置菜单项的显示中文文本："></a>设置菜单项的显示中文文本：</h4><p>打开 <code>themes/next/languages/zh-CN.yml</code> 文件,搜索 <code>menu</code> 关键字，修改对应中文或者新增。</p>
<pre><code class="bash">menu:
  home: 首页
  archives: 归档
  categories: 分类
  tags: 标签
  about: 关于
  search: 搜索
  schedule: 日程表
  sitemap: 站点地图
  commonweal: 公益404
  # 新增menu
  catalogue: 目录
</code></pre>
<p>修改<code>themes/next/_config.yml</code>文件，找到<code>language</code>项改为<code>zh-CN</code>。</p>
<p>同时回到博客根目录，打开<code>_config.yml</code>文件，找到<code>language</code>项改为<code>zh-CN</code>。</p>
<h4 id="设定菜单项的文件目录和对应图标（新版两项合并）"><a href="#设定菜单项的文件目录和对应图标（新版两项合并）" class="headerlink" title="设定菜单项的文件目录和对应图标（新版两项合并）"></a>设定菜单项的文件目录和对应图标（新版两项合并）</h4><p>打开 <code>themes/next/_config.yml</code> 文件，搜索    <code>menu_icons</code> 关键字，修改对应图标名称或者新增对应 <code>menu</code> 的图标。</p>
<pre><code class="yaml"># ---------------------------------------------------------------
# Menu Settings
# ---------------------------------------------------------------

# Usage: `Key: /link/ || icon`
# Key is the name of menu item. If the translation for this item is available, the translated text will be loaded, otherwise the Key name will be used. Key is case-senstive.
# Value before `||` delimiter is the target link, value after `||` delimiter is the name of Font Awesome icon.
# When running the site in a subdirectory (e.g. yoursite.com/blog), remove the leading slash from link value (/archives -&gt; archives).
# External url should start with http:// or https://
menu:
  home: / || fa fa-home
  about: /about/ || fa fa-user
  tags: /tags/ || fa fa-tags
  categories: /categories/ || fa fa-th
  archives: /archives/ || fa fa-archive
  #schedule: /schedule/ || fa fa-calendar
  #sitemap: /sitemap.xml || fa fa-sitemap
  commonweal: /404/ || fa fa-heartbeat

# Enable / Disable menu icons / item badges.
menu_settings:
  icons: true
  badges: false
</code></pre>
<p>除了 <code>home</code>， <code>archives</code> , <code>/</code>后面都需要手动创建这个页面</p>
<p><a href="https://blog.csdn.net/Awt_FuDongLai/article/details/107314881">如何创建新的页面？</a></p>
<h4 id="创建菜单项对应文件目录-以分类为例"><a href="#创建菜单项对应文件目录-以分类为例" class="headerlink" title="创建菜单项对应文件目录,以分类为例"></a>创建菜单项对应文件目录,以分类为例</h4><p>在终端窗口下，定位到 <code>Hexo</code> 站点目录下。使用 <code>hexo new page</code> 新建一个页面，命名为 categories ：</p>
<pre><code class="ruby">$ cd your-hexo-site
$ hexo new page categories
</code></pre>
<p>编辑刚新建的页面,设置分类</p>
<pre><code class="bash">---
title: 分类
date: 2014-12-22 12:39:04
categories: Testing #分类名 ??不理解什么意思
type: &quot;categories&quot;
---
</code></pre>
<h3 id="头像设置"><a href="#头像设置" class="headerlink" title="头像设置"></a>头像设置</h3><h4 id="添加头像"><a href="#添加头像" class="headerlink" title="添加头像"></a>添加头像</h4><p>打开 <code>themes/next/_config.yml</code> 文件，搜索  <code>Sidebar Avatar</code> 关键字，去掉 <code>avatar</code> 前面的<code>#</code>：</p>
<pre><code class="csharp"># Sidebar Avatar
# in theme directory(source/images): /images/avatar.jpg
# in site  directory(source/uploads): /uploads/avatar.jpg
avatar: http://example.com/avatar.png
</code></pre>
<p>或者使用本地图片,把图片放入 <code>themes/next/source/images</code> 下,修改 <code>avatar</code>：</p>
<pre><code class="jsx">avatar: /images/avatar.gif
</code></pre>
<h4 id="设置头像为圆形并且触碰旋转"><a href="#设置头像为圆形并且触碰旋转" class="headerlink" title="设置头像为圆形并且触碰旋转"></a>设置头像为圆形并且触碰旋转</h4><p>打开主题配置文件</p>
<blockquote>
<p>themes&#x2F;next&#x2F;_config.yml</p>
</blockquote>
<pre><code class="yaml"># Sidebar Avatar
avatar:
  # Replace the default image and set the url here.
  url: /images/avatar.gif
  # 新版本Hexo将下面下个设置为true，代码判断自动生效
  # If true, the avatar will be dispalyed in circle.
  rounded: true 
  # If true, the avatar will be rotated with the cursor.
  rotated: true
</code></pre>
<p><a href="https://crayonnew.github.io/2018/11/05/Hexo-NexT%E4%B8%BB%E9%A2%98-%E8%AE%BE%E7%BD%AE%E5%9C%86%E5%BD%A2%E5%A4%B4%E5%83%8F%E5%B9%B6%E6%97%8B%E8%BD%AC/">旧版Hexo设置</a></p>
<p>新版主题配置文件更换了位置(“&#x2F;themes&#x2F;next&#x2F;source&#x2F;css&#x2F;_common&#x2F;outline&#x2F;sidebar&#x2F;sidebar-author.styl”)</p>
<h3 id="浏览页面的时候显示当前浏览进度"><a href="#浏览页面的时候显示当前浏览进度" class="headerlink" title="浏览页面的时候显示当前浏览进度"></a>浏览页面的时候显示当前浏览进度</h3><p>打开 <code>themes/next/_config.yml</code> ,搜索关键字 <code>scrollpercent</code> ,把 <code>false</code> 改为 <code>true</code>。</p>
<pre><code class="bash">  # Scroll percent label in b2t button
  scrollpercent: true
</code></pre>
<p>如果想把 <code>top</code>按钮放在侧边栏,打开 <code>themes/next/_config.yml</code> ,搜索关键字 <code>b2t</code> ,把 <code>false</code> 改为 <code>true</code>。</p>
<pre><code class="bash"> # Back to top in sidebar
  b2t: true

  # Scroll percent label in b2t button
  scrollpercent: true
</code></pre>
<h3 id="侧边栏设置"><a href="#侧边栏设置" class="headerlink" title="侧边栏设置"></a>侧边栏设置</h3><h4 id="设置侧边栏社交链接"><a href="#设置侧边栏社交链接" class="headerlink" title="设置侧边栏社交链接"></a>设置侧边栏社交链接</h4><p>打开 <code>themes/next/_config.yml</code> 文件,搜索关键字 <code>social</code> ,然后添加社交站点名称与地址即可。</p>
<pre><code class="ruby"># ---------------------------------------------------------------
# Sidebar Settings
# ---------------------------------------------------------------

# Social Links.
# Usage: `Key: permalink || icon`
# Key is the link label showing to end users.
# Value before `||` delimeter is the target permalink.
# Value after `||` delimeter is the name of FontAwesome icon. If icon (with or without delimeter) is not specified, globe icon will be loaded.
social:
  E-Mail: mailto:yourname@gmail.com || envelope
  Google: https://plus.google.com/yourname || google
  Twitter: https://twitter.com/yourname || twitter
  FB Page: https://www.facebook.com/yourname || facebook
  # 等等
</code></pre>
<h4 id="设置侧边栏社交图标"><a href="#设置侧边栏社交图标" class="headerlink" title="设置侧边栏社交图标"></a>设置侧边栏社交图标</h4><p>打开 <code>themes/next/_config.yml</code> 文件,搜索关键字 <code>social_icons</code> ，添加社交站点名称（注意大小写）图标，<a href="http://fontawesome.dashgame.com/">Font Awesome</a>图标地。</p>
<h4 id="RSS"><a href="#RSS" class="headerlink" title="RSS"></a>RSS</h4><p>在你 <code>Hexo</code> 站点目录下：</p>
<pre><code class="ruby">$ npm install hexo-generator-feed --save
</code></pre>
<p>打开 <code>Hexo</code> 站点下的 <code>_config.yml</code> ,添加如下配置：</p>
<pre><code class="bash"># feed
# Dependencies: https://github.com/hexojs/hexo-generator-feed
feed:
  type: atom
  path: atom.xml
  limit: 20
  hub:
  content:
</code></pre>
<h4 id="友情链接"><a href="#友情链接" class="headerlink" title="友情链接"></a>友情链接</h4><p>打开 <code>themes/next/_config.yml</code> 文件,搜索关键字 <code>Blog rolls</code>：</p>
<pre><code class="csharp"># Blog rolls
links_title: 友情链接 #标题
links_layout: block #布局，一行一个连接
#links_layout: inline
links: #连接
  baidu: http://example.com/
  google: http://example.com/
</code></pre>
<h3 id="主页文章添加边框阴影效果"><a href="#主页文章添加边框阴影效果" class="headerlink" title="主页文章添加边框阴影效果"></a>主页文章添加边框阴影效果</h3><p>打开 <code>themes/next/source/css/_custom/custom.styl</code> ,向里面加代码:（旧版本NexT）</p>
<pre><code class="cpp">// 主页文章添加阴影效果
.post &#123;
   margin-top: 0px;
   margin-bottom: 60px;
   padding: 25px;
   -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5);
   -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);
&#125;
</code></pre>
<p>打开<code>themes\next\source\css\_common\components\post\post.styl</code>文件，将<code>post-block</code>代码进行如下更改：（新版本NexT）</p>
<pre><code>if (hexo-config(&#39;motion.transition.post_block&#39;)) &#123;
    .post-block&#123;
        margin-top: 60px;
        margin-bottom: 60px;
        padding: 25px;
        background:rgba(255,255,255,0.9) none repeat scroll !important; //添加透明效果
        -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5);
        -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);
    &#125;
    .pagination, .comments &#123;
      opacity: 0;
    &#125;
  &#125;
</code></pre>
<h3 id="修改文章间分割线"><a href="#修改文章间分割线" class="headerlink" title="修改文章间分割线"></a>修改文章间分割线</h3><blockquote>
<p>新版NexT已配置好</p>
</blockquote>
<p>打开 <code>themes/next/source/css/_common/components/post/post-eof.styl</code> ,修改：</p>
<pre><code class="ruby">.posts-expand &#123;
  .post-eof &#123;
    display: block;
  //  margin: $post-eof-margin-top auto $post-eof-margin-bottom;  
    width: 0%; //分割线长度
    height: 0px; // 分割线高度
    background: $grey-light;
    text-align: center;
  &#125;
&#125;
</code></pre>
<h3 id="代码块自定义样式"><a href="#代码块自定义样式" class="headerlink" title="代码块自定义样式"></a>代码块自定义样式</h3><blockquote>
<p>不知道是啥</p>
</blockquote>
<pre><code class="css">// Custom styles.
code &#123;
    color: #ff7600;
    background: #fbf7f8;
    margin: 2px;
&#125;
// 边框的自定义样式
.highlight, pre &#123;
    margin: 5px 0;
    padding: 5px;
    border-radius: 3px;
&#125;
.highlight, code, pre &#123;
    border: 1px solid #d6d6d6;
&#125;
</code></pre>
<h3 id="开启版权声明"><a href="#开启版权声明" class="headerlink" title="开启版权声明"></a>开启版权声明</h3><blockquote>
<p>旧版本NexT</p>
</blockquote>
<p>主题配置文件下,搜索关键字 <code>post_copyright</code> , <code>enable</code> 改为 <code>true</code>：</p>
<pre><code class="yaml"># Declare license on posts
post_copyright:
  enable: true
  license: CC BY-NC-SA 4.0
  license_url: https://creativecommons.org/licenses/by-nc-sa/4.0/
</code></pre>
<blockquote>
<p>新版本NexT</p>
</blockquote>
<p>主题配置文件下,搜索关键字 <code>creative_commons</code> , <code>post</code> 改为 <code>true</code>：</p>
<pre><code class="yaml"># Creative Commons 4.0 International License.
# See: https://creativecommons.org/share-your-work/licensing-types-examples
# Available values of license: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zero
# You can set a language value if you prefer a translated version of CC license, e.g. deed.zh
# CC licenses are available in 39 languages, you can find the specific and correct abbreviation you need on https://creativecommons.org
creative_commons:
  license: by-nc-sa
  sidebar: false
  post: true     # 默认显示版权信息
  language:
</code></pre>
<blockquote>
<p><a href="https://blog.pangao.vip/Hexo%E5%8D%9A%E5%AE%A2NexT%E4%B8%BB%E9%A2%98%E7%BE%8E%E5%8C%96%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E6%96%87%E7%AB%A0%E5%BA%95%E9%83%A8%E7%89%88%E6%9D%83%E5%A3%B0%E6%98%8E/">自定义版权声明文件内容</a></p>
</blockquote>
<h3 id="设置页面加载动画"><a href="#设置页面加载动画" class="headerlink" title="设置页面加载动画"></a>设置页面加载动画</h3><p><a href="https://tding.top/archives/dfac1e9c.html">原文链接</a></p>
<p>主题配置文件下,<code>enable</code>改为<code>true</code>：</p>
<pre><code class="yaml">pace:
  enable: true
  # Themes list:
  # big-counter | bounce | barber-shop | center-atom | center-circle | center-radar | center-simple
  # corner-indicator | fill-left | flat-top | flash | loading-bar | mac-osx | material | minimal
  theme: minimal
</code></pre>
<p>但是这个加载动画需要安装依赖，地址：<a href="https://github.com/theme-next/theme-next-pace">Progress bar for NexT</a>。</p>
<ul>
<li>方法 1：安装文件</li>
</ul>
<pre><code># 进入主题目录
cd themes/next

# 从GitHub下载依赖文件
git clone https://github.com/theme-next/theme-next-pace source/lib/pace
</code></pre>
<ul>
<li>方法 2：启用 CDN(未使用过)</li>
</ul>
<p>我们可以在主题配置文件<code>_config.yml</code> 中修改：</p>
<pre><code>vendors:
  pace: //cdn.jsdelivr.net/npm/pace-js@1/pace.min.js
  pace_css: //cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.min.css
</code></pre>
<h3 id="在右上角或者左上角实现fork-me-on-github"><a href="#在右上角或者左上角实现fork-me-on-github" class="headerlink" title="在右上角或者左上角实现fork me on github"></a>在右上角或者左上角实现fork me on github</h3><p>1.首先到<a href="http://tholman.com/github-corners/">GitHub Corners</a>或者<a href="https://github.blog/2008-12-19-github-ribbons/">GitHub Ribbons</a>选择自己喜欢的图标，然后copy相应的代码</p>
<p>2.然后将刚才复制的代码粘贴到<code>themes/next/layout/_layout.swig</code>文件中<div class="headband"></div>下面一行</p>
<p>3.把代码中的href后面的值替换成你要跳转的地址，比如你的GitHub主页</p>
<h3 id="顶部阅读进度条"><a href="#顶部阅读进度条" class="headerlink" title="顶部阅读进度条"></a>顶部阅读进度条</h3><p>在主题配置文件中修改<code>enable</code>为<code>true</code></p>
<pre><code class="yaml">reading_progress:
  enable: true
  # Available values: top | bottom
  position: top
  color: &quot;#37c6c0&quot;
  height: 3px
</code></pre>
<h3 id="修改文章底部的那个带-号的标签"><a href="#修改文章底部的那个带-号的标签" class="headerlink" title="修改文章底部的那个带#号的标签"></a>修改文章底部的那个带#号的标签</h3><p>打开配置文件<code>themes\next\layout\_macro\post.swg</code>，观察代码</p>
<pre><code class="html">    &#123;%- if post.tags and post.tags.length %&#125;
        &lt;!--这里判断theme.tag_icon是否为true--&gt;
          &#123;%- if theme.tag_icon %&#125;
            &lt;!--如果是则使用fa fa-tag图标--&gt;
            &#123;%- set tag_indicate = '<i class="fa fa-tag"></i>' %&#125;
          &#123;% else %&#125;
            &lt;!--如果不是则使用&#39;#&#39;--&gt;
            &#123;%- set tag_indicate = '#' %&#125;
          &#123;%- endif %&#125;
          &lt;div class=&quot;post-tags&quot;&gt;
            &#123;%- for tag in post.tags.toArray() %&#125;
              &lt;a href=&quot;&#123;&#123; url_for(tag.path) &#125;&#125;&quot; rel=&quot;tag&quot;&gt;&#123;&#123; tag_indicate &#125;&#125; &#123;&#123; tag.name &#125;&#125;&lt;/a&gt;
            &#123;%- endfor %&#125;
          &lt;/div&gt;
    &#123;%- endif %&#125;
</code></pre>
<p>因此，在主题配置文件<code>_config.yml</code>，将<code>tag_icon</code>设置为<code>true</code>。</p>
<pre><code class="yaml"># Use icon instead of the symbol # to indicate the tag at the bottom of the post
tag_icon: true
</code></pre>
<h3 id="本地搜索"><a href="#本地搜索" class="headerlink" title="本地搜索"></a>本地搜索</h3><p>在你站点的根目录下</p>
<pre><code class="ruby">$ npm install hexo-generator-searchdb --save
</code></pre>
<p>打开 <code>Hexo</code> 站点的 <code>_config.yml</code>,添加配置</p>
<pre><code class="bash">search:
  path: search.xml
  field: post
  format: html
  limit: 10000
</code></pre>
<p>打开 <code>themes/next/_config.yml</code> ,搜索关键字 <code>local_search</code> ,设置为 <code>true</code>：</p>
<pre><code class="bash"># Local search
# Dependencies: https://github.com/flashlab/hexo-generator-search
local_search:
  enable: true
  # if auto, trigger search by changing input
  # if manual, trigger search by pressing enter key or search button
  trigger: auto
  # show top n results per article, show all results by setting to -1
  top_n_per_article: 1
</code></pre>
<h3 id="修改网页底部"><a href="#修改网页底部" class="headerlink" title="修改网页底部"></a>修改网页底部</h3><ol>
<li>在图标库中找到你自己喜欢的图标，修改桃心,打开 <code>themes/next/_config.yml</code> ,搜索关键字 <code>footer</code>,在<code>icon</code>中替换图标名</li>
<li>隐藏网页底部 <code>Hexo 强力驱动</code>，打开主题配置文件,搜索关键字 <code>copyright</code> ，将<code>powered</code>设置为<code>false</code>:</li>
</ol>
<pre><code class="objectivec">footer:
  # Specify the date when the site was setup. If not defined, current year will be used.
  #since: 2015

  # Icon between year and copyright info.
  icon:
    # Icon name in Font Awesome. See: https://fontawesome.com/icons
    name: fa fa-star
    # If you want to animate the icon, set it to true.
    animated: false
    # Change the color of icon, using Hex Code.
    color: &quot;#ff0000&quot;

  # If not defined, `author` from Hexo `_config.yml` will be used.设置作者名称
  copyright: false
    
  # Powered by Hexo &amp; NexT
  powered: true
</code></pre>
<h3 id="统计功能，统计功能-显示文章字数统计-阅读时长-总字数"><a href="#统计功能，统计功能-显示文章字数统计-阅读时长-总字数" class="headerlink" title="统计功能，统计功能,显示文章字数统计,阅读时长,总字数"></a>统计功能，统计功能,显示文章字数统计,阅读时长,总字数</h3><h4 id="首页文章属性"><a href="#首页文章属性" class="headerlink" title="首页文章属性"></a>首页文章属性</h4><pre><code>post_meta:
  item_text: false    # 设为true 可以一行显示，文章的所有属性
  created_at: true    # 显示创建时间
  updated_at:
    enabled: true     # 显示修改的时间
    another_day: true # 设true时，如果创建时间和修改时间一样则显示一个时间
  categories: true    # 显示分类信息
</code></pre>
<h4 id="页面阅读统计"><a href="#页面阅读统计" class="headerlink" title="页面阅读统计"></a>页面阅读统计</h4><pre><code>busuanzi_count:
  enable: false              # 设true 开启
  total_visitors: true       # 总阅读人数（uv数）
  total_visitors_icon: user  # 阅读总人数的图标
  total_views: true          # 总阅读次数（pv数）
  total_views_icon: eye      # 阅读总次数的图标
  post_views: true           # 开启内容阅读次数
  post_views_icon: eye       # 内容页阅读数的图标
</code></pre>
<h4 id="字数统计、阅读时长"><a href="#字数统计、阅读时长" class="headerlink" title="字数统计、阅读时长"></a>字数统计、阅读时长</h4><p>首先安装插件：</p>
<pre><code>npm install hexo-symbols-count-time --save
</code></pre>
<p>主题配置文件<code>_config.yml</code> 修改如下：</p>
<pre><code class="yaml">symbols_count_time:
  separated_meta: true  # false会显示一行
  item_text_post: true  # 显示属性名称,设为false后只显示图标和统计数字,不显示属性的文字
  item_text_total: true # 底部footer是否显示字数统计属性文字
  awl: 4                # 计算字数的一个设置,没设置过
  wpm: 275              # 一分钟阅读的字数
</code></pre>
<p>站点配置文件<code>_config.yml</code> 新增如下：</p>
<pre><code class="yaml">symbols_count_time:
 #文章内是否显示
  symbols: true
  time: true
 # 网页底部是否显示
  total_symbols: true
  total_time: true
</code></pre>
<h3 id="首页文章不展示全文显示摘要"><a href="#首页文章不展示全文显示摘要" class="headerlink" title="首页文章不展示全文显示摘要"></a>首页文章不展示全文显示摘要</h3><p>我们可以在主题配置文件中设置：</p>
<pre><code>scroll_to_more: true      # 点击阅读全文后是否跳到&lt;!--more--&gt;标记处,设为false时点击阅读全文可以从头阅读

save_scroll: false        # 自动保存每篇文章或页面上一次滚动的地方

excerpt_description: true # 自动在首页对文章进行摘要描述作为前言文本

auto_excerpt:   # 是否自动截取摘要
  enable: false # 设置为true则自动截取150字当做首页摘要
  length: 150   # 自动截取的字数
</code></pre>
<blockquote>
<p>官方公告：<code>auto_excerpt</code> 可以自动截断文章内容作为摘要。此功能不是一个 Hexo 主题应当负责的，这为主题的维护者带来了太大压力。自 7.6.0 版本开始，此功能被移除，请自行安装第三方插件，或阅读 Hexo 有关文档。当然，我们仍然建议通过 <code>&lt;!-- more --&gt;</code> 来精确控制 Read More 的位置。</p>
</blockquote>
<p><strong>因此，这个功能在新版的 NexT 已经被废弃了，大家可以直接在文章中添加 <code>&lt;!-- more --&gt;</code> 来精确控制摘要内容</strong>。</p>
<h3 id="添加Live2D看板娘"><a href="#添加Live2D看板娘" class="headerlink" title="添加Live2D看板娘"></a>添加Live2D看板娘</h3><h4 id="普通版"><a href="#普通版" class="headerlink" title="普通版"></a>普通版</h4><p>输入如下命令获取 live2d ：</p>
<pre><code>cnpm install --save hexo-helper-live2d
</code></pre>
<p>输入以下命令，下载相应的模型，将 packagename 更换成模型名称即可，更多模型选择请<a href="https://github.com/xiazeyu/live2d-widget-models">点击此处</a>，各个模型的预览请<a href="https://huaji8.top/post/live2d-plugin-2.0/">访问原作者的博客</a></p>
<pre><code>$ npm install packagename
</code></pre>
<p>打开站点目录下的 _config.yml 文件，添加如下代码：</p>
<pre><code>复制live2d:
  enable: true
  scriptFrom: local
  model:
    use: live2d-widget-model-haruto #模型选择
  display:
    position: right  #模型位置
    width: 150       #模型宽度
    height: 300      #模型高度
  mobile:
    show: false      #是否在手机端显示
</code></pre>
<p>取消看板娘</p>
<pre><code>cnpm uninstall hexo-helper-live2d
</code></pre>
<h4 id="进阶版"><a href="#进阶版" class="headerlink" title="进阶版"></a><a href="https://blog.csdn.net/qq_39610915/article/details/90679768">进阶版</a></h4><h3 id="文章打赏功能"><a href="#文章打赏功能" class="headerlink" title="文章打赏功能"></a>文章打赏功能</h3><p>主题配置文件下：</p>
<pre><code class="yaml"># Reward (Donate)
# Front-matter variable (unsupport animation).
reward_settings:
  # If true, reward will be displayed in every article by default.
  enable: true
  animation: false
  #comment: Donate comment here.

reward:
  wechatpay: /images/wechatpay.png
  alipay: /images/alipay.png
  #paypal: /images/paypal.png
  #bitcoin: /images/bitcoin.png
</code></pre>
<h3 id="内容页里的代码块新增复制按钮"><a href="#内容页里的代码块新增复制按钮" class="headerlink" title="内容页里的代码块新增复制按钮"></a>内容页里的代码块新增复制按钮</h3><p>主题配置文件下：</p>
<pre><code class="yaml">codeblock:
  # Code Highlight theme
  # Available values: normal | night | night eighties | night blue | night bright | solarized | solarized dark | galactic
  # See: https://github.com/chriskempson/tomorrow-theme
  highlight_theme: normal    #代码块色彩主题
  # Add copy button on codeblock
  copy_button:
    enable: true            #是否开启复制按钮
    # Show text copy result.
    show_result: true        #是否显示复制成功信息
    # Available values: default | flat | mac
    style: mac                #代码块主题
</code></pre>
<h3 id="去除页面最上面的黑线"><a href="#去除页面最上面的黑线" class="headerlink" title="去除页面最上面的黑线"></a>去除页面最上面的黑线</h3><p>个人觉得看着很闹心。</p>
<blockquote>
<p>方法一：打开<code>themes\next\layout\_layout.swig</code></p>
</blockquote>
<pre><code class="html">&lt;div class=&quot;container&#123;%- if theme.motion.enable %&#125; use-motion&#123;%- endif %&#125;&quot;&gt;
    &lt;!--
        &lt;div class=&quot;headband&quot;&gt;&lt;/div&gt; 注释或者删除这句
    --&gt;
    ......
&lt;/div&gt;
</code></pre>
<blockquote>
<p>方法二：打开<code>themes\next\source\css\_variables\base.syl</code></p>
</blockquote>
<pre><code>// Headband  将像素设置为0px
// --------------------------------------------------
$headband-height                = 3px;
$headband-bg                    = $black-deep;
</code></pre>
<h3 id="设置背景图片-博客内容透明化"><a href="#设置背景图片-博客内容透明化" class="headerlink" title="设置背景图片+博客内容透明化"></a>设置背景图片+博客内容透明化</h3><p>将<code>styles.styl</code>文件放入<code>themes\next\source\_data</code>以及<code>hexoblog\_data</code>中（没有文件、文件夹需要创建）</p>
<p><code>styles.styl</code>文件内容：</p>
<pre><code class="css">body &#123;
    background:url(/images/background_pink.jpg); // 可以是路径也可以是链接
    background-repeat: no-repeat; // 不重复
    background-attachment:fixed; // 固定住背景图片
    background-position:50% 50%; // 图片位置：居中
    background-size: 100% 100%; // 图片长宽扩充为100%
&#125;


//博客内容透明化
//文章内容的透明度设置
.content-wrap &#123;
  opacity: 0.9;
&#125;

//侧边框的透明度设置
.sidebar &#123;
  opacity: 0.9;
&#125;

//菜单栏的透明度设置
.header-inner &#123;
  background: rgba(255,255,255,0.9);
&#125;

//搜索框（local-search）的透明度设置
.popup &#123;
  opacity: 0.9;
&#125;
</code></pre>
<p>打开<code>themes\next\source\css\main.styl</code>，添加最下面这句</p>
<pre><code>// Custom Layer
// --------------------------------------------------
for $inject_style in hexo-config(&#39;injects.style&#39;)
  @import $inject_style;
  @import &quot;../_data/styles.styl&quot;
</code></pre>
<p>打开主题配置文件</p>
<pre><code class="yaml"># Define custom file paths.
# Create your custom files in site directory `source/_data` and uncomment needed files below.
custom_file_path:
  #head: source/_data/head.swig
  #header: source/_data/header.swig
  #sidebar: source/_data/sidebar.swig
  #postMeta: source/_data/post-meta.swig
  #postBodyEnd: source/_data/post-body-end.swig
  #footer: source/_data/footer.swig
  #bodyEnd: source/_data/body-end.swig
  #variable: source/_data/variables.styl
  #mixin: source/_data/mixins.styl
  style: source/_data/styles.styl  #取消这个注释  
</code></pre>
<h3 id="每篇文章末尾统一添加“本文结束”标记"><a href="#每篇文章末尾统一添加“本文结束”标记" class="headerlink" title="每篇文章末尾统一添加“本文结束”标记"></a>每篇文章末尾统一添加“本文结束”标记</h3><p>在路径 <code>/themes/next/layout/_macro</code> 中新建  <code>passage-end-tag.swig</code> 文件,并添加以下内容：</p>
<pre><code class="xml">&lt;div&gt;
    &#123;% if not is_index %&#125;
        <div style="text-align:center;color: #ccc;font-size:14px;">------ 本文结束------</div>
    &#123;% endif %&#125;
&lt;/div&gt;
</code></pre>
<p>打开 <code>themes/next/layout/_macro/post.swig</code> 文件,添加：</p>
<pre><code class="php">&lt;div&gt;
    &#123;% if not is_index %&#125;
    &#123;% include 'passage-end-tag.swig' %&#125;
    &#123;% endif %&#125;
 &lt;/div&gt;
</code></pre>
<p>然后打开主题配置文件 <code>_config.yml</code>,在末尾添加：</p>
<pre><code class="yaml"># 文章末尾添加“本文结束”标记
passage_end_tag:
enabled: true
</code></pre>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>个人博客</tag>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap知识点</title>
    <url>/2022/03/22/HashMap%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<p><a href="https://www.bilibili.com/video/BV1nJ411J7AA?p=9&spm_id_from=333.880.my_history.page.click">原文链接：B站黑马程序员深入解读HashMap技术点</a></p>
<p>JDK1.8的HashMap设计的诸多细节与优化大多为了<strong>尽量避免hash碰撞，优化hash碰撞的解决方案，提高key的hash值的运算效率，提升查询效率，尽量减少扩容次数。</strong></p>
<p>避免hash碰撞：HashMap数组长度始终为2的次方</p>
<p>优化hash碰撞的解决方案：JDK1.8新增了红黑树结构用来存储节点（类为Node继承自Map.Entry）</p>
<p>提高key的hash值的运算效率：在所有关于hash的运算中，尽量使用了位运算。</p>
<p>提升查询效率：严格的扩容机制（阈值大于8并且数组长度大于64时，链表才转换为红黑树）</p>
<span id="more"></span>

<h2 id="1-HashMap集合简介"><a href="#1-HashMap集合简介" class="headerlink" title="1.HashMap集合简介"></a>1.HashMap集合简介</h2><p>​    HashMap基于哈希表的Map接口实现，是以key-value存储形式存在，即主要用来存放键值对。HashMap 的实现不是同步的，这意味着它不是线程安全的。它的key、value都可以为null。此外，HashMap中的映射不是有序的。</p>
<p>​    JDK1.8 之前 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突**(两个对象调用的hashCode方法计算的哈希码值一致导致计算的数组索引值相同)<strong>而存在的（“拉链法”解决冲突）.JDK1.8 以后在解决哈希冲突时有了较大的变化，</strong>当链表长度大于阈值（或者红黑树的边界值，默认为 8）并且当前数组的长度大于64时，此时此索引位置上的所有数据改为使用红黑树存储。**</p>
<p>补充：将链表转换成红黑树前会判断，即使阈值大于8，但是数组长度小于64，此时并不会将链表变为红黑树。而是选择进行数组扩容。</p>
<p>这样做的目的是因为数组比较小，尽量避开红黑树结构，这种情况下变为红黑树结构，反而会降低效率，因为红黑树需要进行左旋，右旋，变色这些操作来保持平衡 。同时数组长度小于64时，搜索时间相对要快些。所以综上所述为了提高性能和减少搜索时间，底层在阈值大于8并且数组长度大于64时，链表才转换为红黑树。具体可以参考 <code>treeifyBin</code>方法。</p>
<p>当然虽然增了红黑树作为底层数据结构，结构变得复杂了，但是阈值大于8并且数组长度大于64时，链表转换为红黑树时，效率也变的更高效。 </p>
<p>特点：</p>
<p>1.存取无序的</p>
<p>2.键和值位置都可以是null，但是键位置只能是一个null</p>
<p>3.键位置是唯一的，底层的数据结构控制键的</p>
<p>4.jdk1.8前数据结构是：链表 + 数组  jdk1.8之后是 ： 链表 + 数组  + 红黑树</p>
<p>5.阈值(边界值) &gt; 8 并且数组长度大于64，才将链表转换为红黑树，变为红黑树的目的是为了高效的查询。</p>
<h2 id="2-HashMap集合底层的数据结构"><a href="#2-HashMap集合底层的数据结构" class="headerlink" title="2.HashMap集合底层的数据结构"></a>2.HashMap集合底层的数据结构</h2><h3 id="2-1数据结构概念"><a href="#2-1数据结构概念" class="headerlink" title="2.1数据结构概念"></a>2.1数据结构概念</h3><p>数据结构：就是存储数据的一种方式。ArrayList LinkedList</p>
<p>在JDK1.8 之前 HashMap 由 <strong>数组+链表</strong> 数据结构组成的。</p>
<p>在JDK1.8 之后 HashMap 由 <strong>数组+链表 +红黑树</strong>数据结构组成的。</p>
<h3 id="2-2HashMap底层的数据结构存储数据的过程"><a href="#2-2HashMap底层的数据结构存储数据的过程" class="headerlink" title="2.2HashMap底层的数据结构存储数据的过程"></a>2.2HashMap底层的数据结构存储数据的过程</h3><p><img src="/2022/03/22/HashMap%E7%9F%A5%E8%AF%86%E7%82%B9/image-20220322134900491.png" alt="image-20220322134900491"></p>
<p>说明：</p>
<p>1.面试题：HashMap中hash函数是怎么实现的？还有哪些hash函数的实现方式？</p>
<pre><code>对于key的hashCode做hash操作，无符号右移16位然后做异或运算。
还有平方取中法，伪随机数法和取余数法。这三种效率都比较低。而无符号右移16位异或运算效率是最高的。至于底层是如何计算的我们下面看源码时给大家讲解。
</code></pre>
<p>2.面试题：当两个对象的hashCode相等时会怎么样？</p>
<pre><code>会产生哈希碰撞，若key值内容相同则替换旧的value.不然连接到链表后面，链表长度超过阈值8就转换为红黑树存储。
</code></pre>
<p>3.面试题：何时发生哈希碰撞和什么是哈希碰撞,如何解决哈希碰撞？</p>
<pre><code>只要两个元素的key计算的哈希码值相同就会发生哈希碰撞。jdk8前使用链表解决哈希碰撞。jdk8之后使用链表+红黑树解决哈希碰撞。
</code></pre>
<p>4.面试题：如果两个键的hashcode相同，如何存储键值对？</p>
<pre><code>hashcode相同，通过equals比较内容是否相同。
相同：则新的value覆盖之前的value
不相同：则将新的键值对添加到哈希表中
</code></pre>
<p>5.在不断的添加数据的过程中，会涉及到扩容问题，当超出临界值(且要存放的位置非空)时，扩容。默认的扩容方式：扩容为原来容量的2倍，并将原有的数据复制过来。</p>
<p>6.通过上述描述，当位于一个链表中的元素较多，即hash值相等但是内容不相等的元素较多时，通过key值依次查找的效率较低。而<strong>JDK1.8</strong>中，哈希表存储采用数组+链表+红黑树实现，当链表长度(阀值)超过 8 时且当前数组的长度 &gt; 64时，将链表转换为红黑树，这样大大减少了查找时间。jdk8在哈希表中引入红黑树的原因只是为了查找效率更高。</p>
<p>简单的来说，哈希表是由数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的。如下图所示。</p>
<p><img src="/2022/03/22/HashMap%E7%9F%A5%E8%AF%86%E7%82%B9/image-20220322135320319.png" alt="image-20220322135320319"></p>
<p> <strong>但是这样的话问题来了，传统hashMap的缺点，1.8为什么引入红黑树？这样结构的话不是更麻烦了吗，为何阈值大于8换成红黑树？</strong></p>
<p> JDK 1.8 以前 HashMap 的实现是 数组+链表，即使哈希函数取得再好，也很难达到元素百分百均匀分布。当 HashMap 中有大量的元素都存放到同一个桶中时，这个桶下有一条长长的链表，这个时候 HashMap 就相当于一个单链表，假如单链表有 n 个元素，遍历的时间复杂度就是 O(n)，完全失去了它的优势。针对这种情况，JDK 1.8 中引入了 红黑树（查找时间复杂度为 O(logn)）来优化这个问题。 当链表长度很小的时候，即使遍历，速度也非常快，但是当链表长度不断变长，肯定会对查询性能有一定的影响，所以才需要转成树。</p>
<p>至于为什么阈值是8，我想，去源码中找寻答案应该是最可靠的途径。 下面我们在分析源码的时候会介绍。</p>
<p><strong>7.总结：</strong></p>
<p>上述我们大概阐述了HashMap底层存储数据的方式。为了方便大家更好的理解，我们结合一个存储流程图来进一步说明一下：(jdk8存储过程)</p>
<p><img src="/2022/03/22/HashMap%E7%9F%A5%E8%AF%86%E7%82%B9/image-20220322135336403.png" alt="image-20220322135336403"></p>
<p>说明：</p>
<p>1.size表示 HashMap中K-V的实时数量 ， 注意这个不等于数组的长度 。 </p>
<p>2.threshold( 临界值)  &#x3D;capacity(容量) * loadFactor( 加载因子 )。这个值是当前已占用数组长度的最大值。size超过这个临界值就重新resize(扩容)，扩容后的 HashMap 容量是之前容量的两倍 。</p>
<h2 id="3-HashMap继承关系"><a href="#3-HashMap继承关系" class="headerlink" title="3.HashMap继承关系"></a>3.HashMap继承关系</h2><p>HashMap继承关系如下图所示：</p>
<p><img src="/2022/03/22/HashMap%E7%9F%A5%E8%AF%86%E7%82%B9/1-16479285030424.bmp" alt="1"></p>
<p>说明：</p>
<ul>
<li>Cloneable 空接口，表示可以克隆。 创建并返回HashMap对象的一个副本。</li>
<li>Serializable 序列化接口。属于标记性接口。HashMap对象可以被序列化和反序列化。</li>
<li>AbstractMap 父类提供了Map实现接口。以最大限度地减少实现此接口所需的工作。</li>
</ul>
<p>补充：通过上述继承关系我们发现一个很奇怪的现象， 就是HashMap已经继承了AbstractMap而AbstractMap类实现了Map接口，那为什么HashMap还要在实现Map接口呢？同样在ArrayList中LinkedList中都是这种结构。 </p>
<pre><code class="java">据 java 集合框架的创始人Josh Bloch描述，这样的写法是一个失误。在java集合框架中，类似这样的写法很多，最开始写java集合框架的时候，他认为这样写，在某些地方可能是有价值的，直到他意识到错了。显然的，JDK的维护者，后来不认为这个小小的失误值得去修改，所以就这样存在下来了。
</code></pre>
<h2 id="4-HashMap集合类的成员"><a href="#4-HashMap集合类的成员" class="headerlink" title="4.HashMap集合类的成员"></a>4.HashMap集合类的成员</h2><h3 id="4-1成员变量"><a href="#4-1成员变量" class="headerlink" title="4.1成员变量"></a>4.1成员变量</h3><p>1.序列化版本号</p>
<pre><code class="java">private static final long serialVersionUID = 362498820763181265L;
</code></pre>
<p>2.集合的初始化容量( <strong>必须是二的n次幂</strong> )</p>
<pre><code class="java">//默认的初始容量是16 -- 1&lt;&lt;4相当于1*2的4次方---1*16
static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4;   
</code></pre>
<p>问题： <strong>为什么必须是2的n次幂？如果输入值不是2的幂比如10会怎么样？</strong> </p>
<p>HashMap构造方法还可以指定集合的初始化容量大小：</p>
<pre><code class="java">HashMap(int initialCapacity) 构造一个带指定初始容量和默认加载因子 (0.75) 的空 HashMap。
</code></pre>
<p> 根据上述讲解我们已经知道，当向HashMap中添加一个元素的时候，需要根据key的hash值，去确定其在数组中的具体位置。 HashMap为了存取高效，要尽量较少碰撞，就是要尽量把数据分配均匀，每个链表长度大致相同，这个实现就在把数据存到哪个链表中的算法。</p>
<p>这个算法实际就是取模，hash%length，计算机中直接求余效率不如位移运算(这点上述已经讲解)。所以源码中做了优化,使用 hash&amp;(length-1)，而实际上hash%length等于hash&amp;(length-1)的前提是length是2的n次幂。</p>
<p>为什么这样能均匀分布减少碰撞呢？2的n次方实际就是1后面n个0，2的n次方-1  实际就是n个1；</p>
<p>举例：</p>
<p><strong>说明：按位与运算：相同的二进制数位上，都是1的时候，结果为1，否则为零。</strong></p>
<pre><code class="java">例如长度为8时候，3&amp;(8-1)=3  2&amp;(8-1)=2 ，不同位置上，不碰撞；
例如长度length为8时候，8是2的3次幂。二进制是：1000
length-1 二进制运算：
    1000
-       1
---------------------
     111
如下所示：
hash&amp;(length-1)
3   &amp;(8    - 1)=3  
    00000011  3 hash
&amp;   00000111  7 length-1
---------------------
    00000011-----》3 数组下标
    
hash&amp;(length-1)
2 &amp;  (8 -    1) = 2  
    00000010  2 hash
&amp;   00000111  7 length-1
---------------------
    00000010-----》2  数组下标
说明：上述计算结果是不同位置上，不碰撞；
</code></pre>
<pre><code class="java">例如长度为9时候，3&amp;(9-1)=0  2&amp;(9-1)=0 ，都在0上，碰撞了；
例如长度length为9时候，9不是2的n次幂。二进制是：00001001
length-1 二进制运算：
    1001
-       1
---------------------
    1000
如下所示：
hash&amp;(length-1)
3   &amp;(9    - 1)=0  
    00000011  3 hash
&amp;   00001000  8 length-1 
---------------------
    00000000-----》0  数组下标
    
hash&amp;(length-1)
2 &amp;  (9 -    1) = 2  
    00000010 2 hash
&amp;   00001000 8 length-1 
---------------------
    00000000-----》0  数组下标
说明：上述计算结果都在0上，碰撞了；
</code></pre>
<p><strong>注意： 当然如果不考虑效率直接求余即可（就不需要要求长度必须是2的n次方了）</strong> </p>
<p>小结：</p>
<p>​    1.由上面可以看出，当我们根据key的hash确定其在数组的位置时，如果n为2的幂次方，可以保证数据的均匀插入，如果n不是2的幂次方，可能数组的一些位置永远不会插入数据，浪费数组的空间，加大hash冲突。</p>
<p>​    2.另一方面，一般我们可能会想通过 % 求余来确定位置，这样也可以，只不过性能不如 &amp; 运算。而且当n是2的幂次方时：hash &amp; (length - 1) &#x3D;&#x3D; hash % length</p>
<p>​    3.因此，HashMap 容量为2次幂的原因，就是为了数据的的均匀分布，减少hash冲突，毕竟hash冲突越大，代表数组中一个链的长度越大，这样的话会降低hashmap的性能</p>
<p>​    <strong>4.如果创建HashMap对象时，输入的数组长度是10，不是2的幂，HashMap通过一通位移运算和或运算得到的肯定是2的幂次数，并且是离那个数最近的数字（&gt;&#x3D; 输入的数组长度）。</strong></p>
<p>源代码如下：</p>
<pre><code class="java">//创建HashMap集合的对象，指定数组长度是10，不是2的幂
HashMap hashMap = new HashMap(10);
public HashMap(int initialCapacity) &#123;//initialCapacity=10
   this(initialCapacity, DEFAULT_LOAD_FACTOR);
 &#125;
public HashMap(int initialCapacity, float loadFactor) &#123;//initialCapacity=10
     if (initialCapacity &lt; 0)
            throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +
                                               initialCapacity);
        if (initialCapacity &gt; MAXIMUM_CAPACITY)
            initialCapacity = MAXIMUM_CAPACITY;
        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))
            throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +
                                               loadFactor);
    this.loadFactor = loadFactor;
    this.threshold = tableSizeFor(initialCapacity);//initialCapacity=10
&#125;
  /**
   * Returns a power of two size for the given target capacity.
  */
    static final int tableSizeFor(int cap) &#123;//int cap = 10
        int n = cap - 1;
        n |= n &gt;&gt;&gt; 1;
        n |= n &gt;&gt;&gt; 2;
        n |= n &gt;&gt;&gt; 4;
        n |= n &gt;&gt;&gt; 8;
        n |= n &gt;&gt;&gt; 16;
        return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
    &#125;
</code></pre>
<p>说明：</p>
<p>由此可以看到，当在实例化HashMap实例时，如果给定了initialCapacity(假设是10)，由于HashMap的capacity必须都是2的幂，因此这个方法用于找到大于等于initialCapacity(假设是10)的最小的2的幂（initialCapacity如果就是2的幂，则返回的还是这个数）。<br>下面分析这个算法：<br>1)、首先，为什么要对cap做减1操作。int n &#x3D; cap - 1;<br>这是为了防止，cap已经是2的幂。如果cap已经是2的幂， 又没有执行这个减1操作，则执行完后面的几条无符号右移操作之后，返回的capacity将是这个cap的2倍。如果不懂，要看完后面的几个无符号右移之后再回来看看。<br>下面看看这几个无符号右移操作：<br>2）、如果n这时为0了（经过了cap-1之后），则经过后面的几次无符号右移依然是0，最后返回的capacity是        1（最后有个n+1的操作）。<br>这里只讨论n不等于0的情况。</p>
<p>3）、注意：**|（按位或运算）：运算规则：相同的二进制数位上，都是0的时候，结果为0，否则为1。**</p>
<p>​     <strong>第一次右移</strong> ：</p>
<pre><code class="java">int n = cap - 1;//cap=10  n=9
n |= n &gt;&gt;&gt; 1;
    00000000 00000000 00000000 00001001 //9
|    
    00000000 00000000 00000000 00000100 //9右移之后变为4
-------------------------------------------------
    00000000 00000000 00000000 00001101 //按位异或之后是13
</code></pre>
<p> 由于n不等于0，则n的二进制表示中总会有一bit为1，这时考虑最高位的1。通过无符号右移1位，则将最高位的1右移了1位，再做或操作，使得n的二进制表示中与最高位的1紧邻的右边一位也为1，如：</p>
<pre><code class="java">00000000 00000000 00000000 00001101
</code></pre>
<p> <strong>第二次右移</strong> ：</p>
<pre><code class="java"> n |= n &gt;&gt;&gt; 2;//n通过第一次右移变为了：n=13
    00000000 00000000 00000000 00001101  // 13
|
    00000000 00000000 00000000 00000011  //13右移之后变为3
-------------------------------------------------
    00000000 00000000 00000000 00001111 //按位异或之后是15
</code></pre>
<p> 注意，这个n已经经过了<code>n |= n &gt;&gt;&gt; 1;</code> 操作。假设此时n为00000000 00000000 00000000 00001101 ，则n无符号右移两位，会将最高位两个连续的1右移两位，然后再与原来的n做或操作，这样n的二进制表示的高位中会有4个连续的1。如：</p>
<pre><code class="java">00000000 00000000 00000000 00001111 //按位异或之后是15
</code></pre>
<p> <strong>第三次右移</strong> :</p>
<pre><code class="java">n |= n &gt;&gt;&gt; 4;//n通过第一、二次右移变为了：n=15
    00000000 00000000 00000000 00001111  // 15
|
    00000000 00000000 00000000 00000000  //15右移之后变为0
-------------------------------------------------
    00000000 00000000 00000000 00001111 //按位异或之后是15
</code></pre>
<p>这次把已经有的高位中的连续的4个1，右移4位，再做或操作，这样n的二进制表示的高位中正常会有8个连续的1。如00001111 1111xxxxxx 。<br>以此类推<br>注意，容量最大也就是32bit的正数，因此最后n |&#x3D; n &gt;&gt;&gt; 16; ，最多也就32个1（但是这已经是负数了。在执行tableSizeFor之前，对initialCapacity做了判断，如果大于MAXIMUM_CAPACITY(2 ^ 30)，则取MAXIMUM_CAPACITY。如果等于MAXIMUM_CAPACITY(2 ^ 30)，会执行移位操作。所以这里面的移位操作之后，最大30个1，不会大于等于MAXIMUM_CAPACITY。30个1，加1之后得2 ^ 30） 。<br>请看下面的一个完整例子：</p>
<p><img src="/2022/03/22/HashMap%E7%9F%A5%E8%AF%86%E7%82%B9/image-20191115151657917.png" alt="image-20191115151657917"></p>
<p>  注意，得到的这个capacity却被赋值给了threshold。 </p>
<pre><code class="java">this.threshold = tableSizeFor(initialCapacity);//initialCapacity=10
</code></pre>
<p>3.默认的负载因子，默认值是0.75 </p>
<pre><code class="java">static final float DEFAULT_LOAD_FACTOR = 0.75f;
</code></pre>
<p>4.集合最大容量 </p>
<pre><code class="java">//集合最大容量的上限是：2的30次幂
static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;
</code></pre>
<p>5.当链表的值超过8则会转红黑树(<strong>1.8新增</strong>) </p>
<pre><code class="java"> //当桶(bucket)上的结点数大于这个值时会转成红黑树
 static final int TREEIFY_THRESHOLD = 8;
</code></pre>
<p><strong>问题：为什么Map桶中节点个数超过8才转为红黑树？</strong></p>
<p>8这个阈值定义在HashMap中，针对这个成员变量，在源码的注释中只说明了8是bin（bin就是bucket(桶)）从链表转成树的阈值，但是并没有说明为什么是8：</p>
<p> 在HashMap中有一段注释说明： 我们继续往下看 :</p>
<pre><code class="java">Because TreeNodes are about twice the size of regular nodes, we use them only when bins contain enough nodes to warrant use (see TREEIFY_THRESHOLD). And when they become too small (due to removal or resizing) they are converted back to plain bins.  In usages with well-distributed user hashCodes, tree bins are rarely used.  Ideally, under random hashCodes, the frequency of nodes in bins follows a Poisson distribution
(http://en.wikipedia.org/wiki/Poisson_distribution) with a parameter of about 0.5 on average for the default resizing threshold of 0.75, although with a large variance because of resizing granularity. Ignoring variance, the expected occurrences of list size k are (exp(-0.5)*pow(0.5, k)/factorial(k)).
The first values are:
因为树节点的大小大约是普通节点的两倍，所以我们只在箱子包含足够的节点时才使用树节点(参见TREEIFY_THRESHOLD)。当它们变得太小(由于删除或调整大小)时，就会被转换回普通的桶。在使用分布良好的用户hashcode时，很少使用树箱。理想情况下，在随机哈希码下，箱子中节点的频率服从泊松分布
(http://en.wikipedia.org/wiki/Poisson_distribution)，默认调整阈值为0.75，平均参数约为0.5，尽管由于调整粒度的差异很大。忽略方差，列表大小k的预期出现次数是(exp(-0.5)*pow(0.5, k)/factorial(k))。
第一个值是:

0:    0.60653066
1:    0.30326533
2:    0.07581633
3:    0.01263606
4:    0.00157952
5:    0.00015795
6:    0.00001316
7:    0.00000094
8:    0.00000006
more: less than 1 in ten million
</code></pre>
<p>TreeNodes占用空间是普通Nodes的两倍，所以只有当bin包含足够多的节点时才会转成TreeNodes，而是否足够多就是由TREEIFY_THRESHOLD的值决定的。当bin中节点数变少时，又会转成普通的bin。并且我们查看源码的时候发现，链表长度达到8就转成红黑树，当长度降到6就转成普通bin。</p>
<p>这样就解释了为什么不是一开始就将其转换为TreeNodes，而是需要一定节点数才转为TreeNodes，说白了就是权衡，空间和时间的权衡。</p>
<p> 这段内容还说到：当hashCode离散性很好的时候，树型bin用到的概率非常小，因为数据均匀分布在每个bin中，几乎不会有bin中链表长度会达到阈值。但是在随机hashCode下，离散性可能会变差，然而JDK又不能阻止用户实现这种不好的hash算法，因此就可能导致不均匀的数据分布。不过理想情况下随机hashCode算法下所有bin中节点的分布频率会遵循泊松分布，我们可以看到，一个bin中链表长度达到8个元素的概率为0.00000006，几乎是不可能事件。所以，之所以选择8，不是随便决定的，而是根据概率统计决定的。由此可见，发展将近30年的Java每一项改动和优化都是非常严谨和科学的。 </p>
<p>也就是说：选择8因为符合泊松分布，超过8的时候，概率已经非常小了，所以我们选择8这个数字。</p>
<p>补充：</p>
<p>1）.</p>
<pre><code> Poisson分布(泊松分布)，是一种统计与概率学里常见到的离散[概率分布]。
泊松分布的概率函数为：
</code></pre>
<p><img src="/2022/03/22/HashMap%E7%9F%A5%E8%AF%86%E7%82%B9/image-20191115161055901.png" alt="image-20191115161055901"></p>
<pre><code> 泊松分布的参数λ是单位时间(或单位面积)内随机事件的平均发生次数。 泊松分布适合于描述单位时间内随机事件发生的次数。
</code></pre>
<p>2）.以下是我在研究这个问题时，在一些资料上面翻看的解释：供大家参考：</p>
<pre><code class="java">红黑树的平均查找长度是log(n)，如果长度为8，平均查找长度为log(8)=3，链表的平均查找长度为n/2，当长度为8时，平均查找长度为8/2=4，这才有转换成树的必要；链表长度如果是小于等于6，6/2=3，而log(6)=2.6，虽然速度也很快的，但是转化为树结构和生成树的时间并不会太短。
</code></pre>
<p><strong>6.当链表的值小于6则会从红黑树转回链表</strong> </p>
<pre><code class="java"> //当桶(bucket)上的结点数小于这个值时树转链表
 static final int UNTREEIFY_THRESHOLD = 6;
</code></pre>
<p>7.当Map里面的数量超过这个值时，表中的桶才能进行树形化 ，否则桶内元素太多时会扩容，而不是树形化 为了避免进行扩容、树形化选择的冲突，这个值不能小于 4 * TREEIFY_THRESHOLD (8)</p>
<pre><code class="java">//桶中结构转化为红黑树对应的数组长度最小的值 
static final int MIN_TREEIFY_CAPACITY = 64;
</code></pre>
<p><strong>8、table用来初始化(必须是二的n次幂)(重点)</strong> </p>
<pre><code class="java">//存储元素的数组 
transient Node&lt;K,V&gt;[] table;
</code></pre>
<p><strong>table</strong>在JDK1.8中我们了解到HashMap是由数组加链表加红黑树来组成的结构其中table就是HashMap中的数组，jdk8之前数组类型是Entry&lt;K,V&gt;类型。从jdk1.8之后是Node&lt;K,V&gt;类型。只是换了个名字，都实现了一样的接口：Map.Entry&lt;K,V&gt;。负责存储键值对数据的。</p>
<p>9、用来存放缓存 </p>
<pre><code class="java">//存放具体元素的集合
transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;
</code></pre>
<p><strong>10、 HashMap中存放元素的个数(重点)</strong></p>
<pre><code class="java">//存放元素的个数，注意这个不等于数组的长度。
 transient int size;
</code></pre>
<p><strong>size</strong>为HashMap中K-V的实时数量，不是数组table的长度。</p>
<p>11、 用来记录HashMap的修改次数 </p>
<pre><code class="java">// 每次扩容和更改map结构的计数器
 transient int modCount;  
</code></pre>
<p>12、 用来调整大小下一个容量的值计算方式为(容量*负载因子) </p>
<pre><code class="java">// 临界值 当实际大小(容量*负载因子)超过临界值时，会进行扩容
int threshold;
</code></pre>
<p><strong>13、 哈希表的加载因子(重点)</strong> </p>
<pre><code class="java">// 加载因子
final float loadFactor;
</code></pre>
<p><strong>说明：</strong></p>
<p>1.<strong>loadFactor</strong>加载因子，是用来衡量 HashMap 满的程度，<strong>表示HashMap的疏密程度，影响hash操作到同一个数组位置的概率</strong>，计算HashMap的实时加载因子的方法为：size&#x2F;capacity，而不是占用桶的数量去除以capacity。capacity 是桶的数量，也就是 table 的长度length。</p>
<p><strong>loadFactor太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor的默认值为0.75f是官方给出的一个比较好的临界值</strong>。</p>
<p><strong>当HashMap里面容纳的元素已经达到HashMap数组长度的75%时，表示HashMap太挤了，需要扩容，而扩容这个过程涉及到 rehash、复制数据等操作，非常消耗性能。，所以开发中尽量减少扩容的次数，可以通过创建HashMap集合对象时指定初始容量来尽量避免。</strong></p>
<p><strong>同时在HashMap的构造器中可以定制loadFactor。</strong></p>
<pre><code class="java">构造方法：
HashMap(int initialCapacity, float loadFactor) 构造一个带指定初始容量和加载因子的空 HashMap。
</code></pre>
<p>2.为什么加载因子设置为0.75,初始化临界值是12？</p>
<p>loadFactor越趋近于1，那么 数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，loadFactor越小，也就是趋近于0，数组中存放的数据(entry)也就越少，也就越稀疏。</p>
<p><img src="/2022/03/22/HashMap%E7%9F%A5%E8%AF%86%E7%82%B9/image-20191115173553375.png" alt="image-20191115173553375"></p>
<p>如果希望链表尽可能少些。要提前扩容，有的数组空间有可能一直没有存储数据。加载因子尽可能小一些。</p>
<p>举例：</p>
<pre><code>例如：加载因子是0.4。 那么16*0.4---&gt;6 如果数组中满6个空间就扩容会造成数组利用率太低了。
     加载因子是0.9。 那么16*0.9----&gt;14 那么这样就会导致链表有点多了。导致查找元素效率低。
</code></pre>
<p>所以既兼顾数组利用率又考虑链表不要太多，经过大量测试0.75是最佳方案。</p>
<ul>
<li><strong>threshold</strong>计算公式：capacity(数组长度默认16) * loadFactor(负载因子默认0.75)。这个值是当前已占用数组长度的最大值。<strong>当Size&gt;&#x3D;threshold</strong>的时候，那么就要考虑对数组的resize(扩容)，也就是说，这个的意思就是 <strong>衡量数组是否需要扩增的一个标准</strong>。 扩容后的 HashMap 容量是之前容量的两倍.</li>
</ul>
<h3 id="4-2构造方法"><a href="#4-2构造方法" class="headerlink" title="4.2构造方法"></a>4.2构造方法</h3><p> HashMap 中重要的构造方法，它们分别如下： </p>
<p>1、构造一个空的 <code>HashMap</code> ，默认初始容量（16）和默认负载因子（0.75）。 </p>
<pre><code class="java">public HashMap() &#123;
   this.loadFactor = DEFAULT_LOAD_FACTOR; // 将默认的加载因子0.75赋值给loadFactor，并没有创建数组
&#125;
</code></pre>
<p>2、 构造一个具有指定的初始容量和默认负载因子（0.75） <code>HashMap</code>。 </p>
<pre><code class="java"> // 指定“容量大小”的构造函数
  public HashMap(int initialCapacity) &#123;
      this(initialCapacity, DEFAULT_LOAD_FACTOR);
  &#125;
</code></pre>
<p>3、 构造一个具有指定的初始容量和负载因子的 <code>HashMap</code>。我们来分析一下。 </p>
<pre><code class="java">/*
     指定“容量大小”和“加载因子”的构造函数
     initialCapacity: 指定的容量
     loadFactor:指定的加载因子
*/
public HashMap(int initialCapacity, float loadFactor) &#123;
        //判断初始化容量initialCapacity是否小于0
        if (initialCapacity &lt; 0)
            //如果小于0，则抛出非法的参数异常IllegalArgumentException
            throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +
                                               initialCapacity);
        //判断初始化容量initialCapacity是否大于集合的最大容量MAXIMUM_CAPACITY-》2的30次幂
        if (initialCapacity &gt; MAXIMUM_CAPACITY)
            //如果超过MAXIMUM_CAPACITY，会将MAXIMUM_CAPACITY赋值给initialCapacity
            initialCapacity = MAXIMUM_CAPACITY;
        //判断负载因子loadFactor是否小于等于0或者是否是一个非数值
        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))
            //如果满足上述其中之一，则抛出非法的参数异常IllegalArgumentException
            throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +
                                               loadFactor);
         //将指定的加载因子赋值给HashMap成员变量的负载因子loadFactor
        this.loadFactor = loadFactor;
        /*
            tableSizeFor(initialCapacity) 判断指定的初始化容量是否是2的n次幂，如果不是那么会变为比指            定初始化容量大的最小的2的n次幂。这点上述已经讲解过。
            但是注意，在tableSizeFor方法体内部将计算后的数据返回给调用这里了，并且直接赋值给threshold边            界值了。有些人会觉得这里是一个bug,应该这样书写：
            this.threshold = tableSizeFor(initialCapacity) * this.loadFactor;
            这样才符合threshold的意思（当HashMap的size到达threshold这个阈值时会扩容）。
            但是，请注意，在jdk8以后的构造方法中，并没有对table这个成员变量进行初始化，table的初始化被推             迟到了put方法中，在put方法中会对threshold重新计算，put方法的具体实现我们下面会进行讲解
        */
        this.threshold = tableSizeFor(initialCapacity);
    &#125;
最后调用了tableSizeFor，来看一下方法实现：
     /**
     * Returns a power of two size for the given target capacity.
       返回比指定初始化容量大的最小的2的n次幂
     */
    static final int tableSizeFor(int cap) &#123;
        int n = cap - 1;
        n |= n &gt;&gt;&gt; 1;
        n |= n &gt;&gt;&gt; 2;
        n |= n &gt;&gt;&gt; 4;
        n |= n &gt;&gt;&gt; 8;
        n |= n &gt;&gt;&gt; 16;
        return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
    &#125;
</code></pre>
<p>说明：</p>
<p>对于 this.threshold &#x3D; tableSizeFor(initialCapacity); 疑问解答：</p>
<pre><code class="java">tableSizeFor(initialCapacity) 判断指定的初始化容量是否是2的n次幂，如果不是那么会变为比指            定初始化容量大的最小的2的n次幂。这点上述已经讲解过。
但是注意，在tableSizeFor方法体内部将计算后的数据返回给调用这里了，并且直接赋值给threshold边            界值了。有些人会觉得这里是一个bug,应该这样书写：
this.threshold = tableSizeFor(initialCapacity) * this.loadFactor;
这样才符合threshold的意思（当HashMap的size到达threshold这个阈值时会扩容）。
但是，请注意，在jdk8以后的构造方法中，并没有对table这个成员变量进行初始化，table的初始化被推             迟到了put方法中，在put方法中会对threshold重新计算，put方法的具体实现我们下面会进行讲解
</code></pre>
<p>4、包含另一个“Map”的构造函数 </p>
<pre><code class="java">//构造一个映射关系与指定 Map 相同的新 HashMap。
public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;
        //负载因子loadFactor变为默认的负载因子0.75
         this.loadFactor = DEFAULT_LOAD_FACTOR;
         putMapEntries(m, false);
 &#125;
</code></pre>
<p>最后调用了putMapEntries，来看一下方法实现：</p>
<pre><code class="java">final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) &#123;
    //获取参数集合的长度
    int s = m.size();
    if (s &gt; 0)
    &#123;
        //判断参数集合的长度是否大于0，说明大于0
        if (table == null)  // 判断table是否已经初始化
        &#123; // pre-size
                // 未初始化，s为m的实际元素个数
                float ft = ((float)s / loadFactor) + 1.0F;
                int t = ((ft &lt; (float)MAXIMUM_CAPACITY) ?
                        (int)ft : MAXIMUM_CAPACITY);
                // 计算得到的t大于阈值，则初始化阈值
                if (t &gt; threshold)
                    threshold = tableSizeFor(t);
        &#125;
        // 已初始化，并且m元素个数大于阈值，进行扩容处理
        else if (s &gt; threshold)
            resize();
        // 将m中的所有元素添加至HashMap中
        for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;
            K key = e.getKey();
            V value = e.getValue();
            putVal(hash(key), key, value, false, evict);
        &#125;
    &#125;
&#125;
</code></pre>
<p>注意：</p>
<p> float ft &#x3D; ((float)s &#x2F; loadFactor) + 1.0F;这一行代码中为什么要加1.0F ？</p>
<p> s&#x2F;loadFactor的结果是小数，加1.0F与(int)ft相当于是对小数做一个向上取整以尽可能的保证更大容量，更大的容量能够减少resize的调用次数。所以 + 1.0F是为了获取更大的容量。 </p>
<p>例如：原来集合的元素个数是6个，那么6&#x2F;0.75是8，是2的n次幂，那么新的数组大小就是8了。然后原来数组的数据就会存储到长度是8的新的数组中了，这样会导致在存储元素的时候，容量不够，还得继续扩容，那么性能降低了，而如果+1呢，数组长度直接变为16了，这样可以减少数组的扩容。</p>
<h3 id="4-3成员方法"><a href="#4-3成员方法" class="headerlink" title="4.3成员方法"></a>4.3成员方法</h3><h4 id="4-3-1增加方法"><a href="#4-3-1增加方法" class="headerlink" title="4.3.1增加方法"></a>4.3.1增加方法</h4><p>put方法是比较复杂的，实现步骤大致如下：</p>
<p>1）先通过hash值计算出key映射到哪个桶；</p>
<p>2）如果桶上没有碰撞冲突，则直接插入；</p>
<p>3）如果出现碰撞冲突了，则需要处理冲突：</p>
<p>​    a:如果该桶使用红黑树处理冲突，则调用红黑树的方法插入数据；</p>
<p>​    b:否则采用传统的链式方法插入。如果链的长度达到临界值，则把链转变为红黑树；</p>
<p>4）如果桶中存在重复的键，则为该键替换新值value；</p>
<p>5）如果size大于阈值threshold，则进行扩容；</p>
<p>具体的方法如下：</p>
<pre><code class="java">public V put(K key, V value) &#123;
    return putVal(hash(key), key, value, false, true);
&#125;
</code></pre>
<p>说明： </p>
<p>​    1）HashMap只提供了put用于添加元素，putVal方法只是给put方法调用的一个方法，并没有提供给用户使用。 所以我们重点看putVal方法。</p>
<pre><code> 2）我们可以看到在putVal()方法中key在这里执行了一下hash()方法,来看一下Hash方法是如何实现的。 
</code></pre>
<pre><code class="java"> static final int hash(Object key) 
 &#123;
        int h;
         /*
             1）如果key等于null：
                 可以看到当key等于null的时候也是有哈希值的，返回的是0.
             2）如果key不等于null：
                 首先计算出key的hashCode赋值给h,然后与h无符号右移16位后的二进制进行按位异或得到最后的                    hash值
         */
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);
 &#125;
</code></pre>
<p>从上面可以得知HashMap是支持Key为空的，而HashTable是直接用Key来获取HashCode所以key为空会抛异常。</p>
<p>{其实上面就已经解释了为什么HashMap的长度<strong>为什么要是2的幂</strong>因为HashMap 使用的方法很巧妙，它通过 hash &amp; (table.length -1)来得到该对象的保存位，前面说过 HashMap 底层数组的长度总是2的n次方，这是HashMap在速度上的优化。当 length 总是2的n次方时，hash &amp; (length-1)运算等价于对 length 取模，也就是hash%length，但是&amp;比%具有更高的效率。比如 n % 32 &#x3D; n &amp; (32 -1)。}</p>
<p><strong>解读上述hash方法：</strong></p>
<p>我们先研究下key的哈希值是如何计算出来的。key的哈希值是通过上述方法计算出来的。</p>
<p>这个哈希方法首先计算出key的hashCode赋值给h,然后与h无符号右移16位后的二进制进行按位异或得到最后的    hash值。计算过程如下所示：</p>
<pre><code class="java"> static final int hash(Object key) 
 &#123;
        int h;
         /*
             1）如果key等于null：
                 可以看到当key等于null的时候也是有哈希值的，返回的是0.
             2）如果key不等于null：
                 首先计算出key的hashCode赋值给h,然后与h无符号右移16位后的二进制进行按位异或得到最后的                    hash值
         */
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);
 &#125;
</code></pre>
<p>在putVal函数中使用到了上述hash函数计算的哈希值：</p>
<pre><code class="java">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) &#123;
        。。。。。。。。。。。。。。
        if ((p = tab[i = (n - 1) &amp; hash]) == null)//这里的n表示数组长度16
       。。。。。。。。。。。。。。
  &#125;
</code></pre>
<p>计算过程如下所示：</p>
<p>​    说明：</p>
<p>​        1）key.hashCode()；返回散列值也就是hashcode。假设随便生成的一个值。</p>
<p>​        2）n表示数组初始化的长度是16</p>
<p>​        3）&amp;（按位与运算）：运算规则：相同的二进制数位上，都是1的时候，结果为1，否则为零。</p>
<p>​        4）^（按位异或运算）：运算规则：相同的二进制数位上，数字相同，结果为0，不同为1。</p>
<p><img src="/2022/03/22/HashMap%E7%9F%A5%E8%AF%86%E7%82%B9/image-20191114193730911.png" alt="image-20191114193730911"></p>
<p>简单来说就是：</p>
<ul>
<li><p>高16 bit 不变，低16 bit 和高16 bit 做了一个异或（得到的 hashcode 转化为32位二进制，前16位和后16位低16 bit和高16 bit做了一个异或）</p>
<p><strong>问题：为什么要这样操作呢？</strong></p>
<p>如果当n即数组长度很小，假设是16的话，那么n-1即为  —》1111 ，这样的值和hashCode()直接做按位与操作，实际上只使用了哈希值的后4位。如果当哈希值的高位变化很大，低位变化很小，这样就很容易造成哈希冲突了，所以这里把高低位都利用起来，从而解决了这个问题。</p>
<pre><code class="java">例如上述：
hashCode()值：     1111 1111 1111 1111 1111 0000 1110 1010
                &amp;
n-1即16-1--》15：  。。。。。。。。。。。。。。。。。。。。。。1111
-------------------------------------------------------------------
                  0000 0000 0000 0000 0000 0000 0000 1010 ----》10作为索引
其实就是将hashCode值作为数组索引，那么如果下个高位hashCode不一致，低位一致的话，就会造成计算的索引还是10,从而造成了哈希冲突了。降低性能。
</code></pre>
</li>
<li><p>(n-1) &amp; hash &#x3D; -&gt; 得到下标   (n-1)   n表示数组长度16，n-1就是15</p>
</li>
<li><p>取余数本质是不断做除法，把剩余的数减去，运算效率要比位运算低。</p>
</li>
</ul>
<p>现在看putVal()方法，看看它到底做了什么。</p>
<p>主要参数：</p>
<ul>
<li>hash key的hash值</li>
<li>key 原始Key</li>
<li>value 要存放的值</li>
<li>onlyIfAbsent 如果true代表不更改现有的值</li>
<li>evict 如果为false表示table为创建状态</li>
</ul>
<p>putVal()方法源代码如下所示：</p>
<pre><code class="java">public V put(K key, V value) 
&#123;
        return putVal(hash(key), key, value, false, true);
&#125;
final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) &#123;
    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;
    /*
        1）transient Node&lt;K,V&gt;[] table; 表示存储Map集合中元素的数组。
        2）(tab = table) == null 表示将空的table赋值给tab,然后判断tab是否等于null，第一次肯定是            null
        3）(n = tab.length) == 0 表示将数组的长度0赋值给n,然后判断n是否等于0，n等于0
        由于if判断使用双或，满足一个即可，则执行代码 n = (tab = resize()).length; 进行数组初始化。
        并将初始化好的数组长度赋值给n.
        4）执行完n = (tab = resize()).length，数组tab每个空间都是null
    */
    if ((tab = table) == null || (n = tab.length) == 0)
        n = (tab = resize()).length;
    /*
        1）i = (n - 1) &amp; hash 表示计算数组的索引赋值给i，即确定元素存放在哪个桶中
        2）p = tab[i = (n - 1) &amp; hash]表示获取计算出的位置的数据赋值给节点p
        3) (p = tab[i = (n - 1) &amp; hash]) == null 判断节点位置是否等于null，如果为null，则执行代            码：tab[i] = newNode(hash, key, value, null);根据键值对创建新的节点放入该位置的桶中
        小结：如果当前桶没有哈希碰撞冲突，则直接把键值对插入空间位置
    */ 
    if ((p = tab[i = (n - 1) &amp; hash]) == null)
        //创建一个新的节点存入到桶中
        tab[i] = newNode(hash, key, value, null);
    else &#123;
         // 执行else说明tab[i]不等于null，表示这个位置已经有值了。
        Node&lt;K,V&gt; e; K k;
        /*
            比较桶中第一个元素(数组中的结点)的hash值和key是否相等
            1）p.hash == hash ：p.hash表示原来存在数据的hash值  hash表示后添加数据的hash值 比较两个                 hash值是否相等
                 说明：p表示tab[i]，即 newNode(hash, key, value, null)方法返回的Node对象。
                    Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; next) 
                    &#123;
                        return new Node&lt;&gt;(hash, key, value, next);
                    &#125;
                    而在Node类中具有成员变量hash用来记录着之前数据的hash值的
             2）(k = p.key) == key ：p.key获取原来数据的key赋值给k  key 表示后添加数据的key 比较两                    个key的地址值是否相等
             3）key != null &amp;&amp; key.equals(k)：能够执行到这里说明两个key的地址值不相等，那么先判断后                添加的key是否等于null，如果不等于null再调用equals方法判断两个key的内容是否相等
        */
        if (p.hash == hash &amp;&amp;
            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
                /*
                    说明：两个元素哈希值相等，并且key的值也相等
                    将旧的元素整体对象赋值给e，用e来记录
                */ 
                e = p;
        // hash值不相等或者key不相等；判断p是否为红黑树结点
        else if (p instanceof TreeNode)
            // 放入树中
            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);
        // 说明是链表节点
        else &#123;
            /*
                1)如果是链表的话需要遍历到最后节点然后插入
                2)采用循环遍历的方式，判断链表中是否有重复的key
            */
            for (int binCount = 0; ; ++binCount) &#123;
                /*
                    1)e = p.next 获取p的下一个元素赋值给e
                    2)(e = p.next) == null 判断p.next是否等于null，等于null，说明p没有下一个元                    素，那么此时到达了链表的尾部，还没有找到重复的key,则说明HashMap没有包含该键
                    将该键值对插入链表中
                */
                if ((e = p.next) == null) &#123;
                    /*
                        1）创建一个新的节点插入到尾部
                         p.next = newNode(hash, key, value, null);
                         Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; next) 
                         &#123;
                                return new Node&lt;&gt;(hash, key, value, next);
                         &#125;
                         注意第四个参数next是null，因为当前元素插入到链表末尾了，那么下一个节点肯定是                                null
                         2）这种添加方式也满足链表数据结构的特点，每次向后添加新的元素
                    */
                    p.next = newNode(hash, key, value, null);
                    /*
                        1)节点添加完成之后判断此时节点个数是否大于TREEIFY_THRESHOLD临界值8，如果大于
                        则将链表转换为红黑树
                        2）int binCount = 0 ：表示for循环的初始化值。从0开始计数。记录着遍历节点的个                        数。值是0表示第一个节点，1表示第二个节点。。。。7表示第八个节点，加上数组中的的一                        个元素，元素个数是9
                        TREEIFY_THRESHOLD - 1 --》8 - 1 ---》7
                        如果binCount的值是7(加上数组中的的一个元素，元素个数是9)
                        TREEIFY_THRESHOLD - 1也是7，此时转换红黑树
                    */
                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                        //转换为红黑树
                        treeifyBin(tab, hash);
                    // 跳出循环
                    break;
                &#125;
                 
                /*
                    执行到这里说明e = p.next 不是null，不是最后一个元素。继续判断链表中结点的key值与插                      入的元素的key值是否相等
                */
                if (e.hash == hash &amp;&amp;
                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                    // 相等，跳出循环
                    /*
                        要添加的元素和链表中的存在的元素的key相等了，则跳出for循环。不用再继续比较了
                        直接执行下面的if语句去替换去 if (e != null) 
                    */
                    break;
                /*
                    说明新添加的元素和当前节点不相等，继续查找下一个节点。
                    用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表
                */
                p = e;
            &#125;
        &#125;
        /*
            表示在桶中找到key值、hash值与插入元素相等的结点
            也就是说通过上面的操作找到了重复的键，所以这里就是把该键的值变为新的值，并返回旧值
            这里完成了put方法的修改功能
        */
        if (e != null) &#123; 
            // 记录e的value
            V oldValue = e.value;
            // onlyIfAbsent为false或者旧值为null
            if (!onlyIfAbsent || oldValue == null)
                //用新值替换旧值
                //e.value 表示旧值  value表示新值 
                e.value = value;
            // 访问后回调
            afterNodeAccess(e);
            // 返回旧值
            return oldValue;
        &#125;
    &#125;
    //修改记录次数
    ++modCount;
    // 判断实际大小是否大于threshold阈值，如果超过则扩容
    if (++size &gt; threshold)
        resize();
    // 插入后回调
    afterNodeInsertion(evict);
    return null;
&#125; 
</code></pre>
<h4 id="4-3-2将链表转换为红黑树的treeifyBin方法"><a href="#4-3-2将链表转换为红黑树的treeifyBin方法" class="headerlink" title="4.3.2将链表转换为红黑树的treeifyBin方法"></a>4.3.2将链表转换为红黑树的treeifyBin方法</h4><p>节点添加完成之后判断此时节点个数是否大于TREEIFY_THRESHOLD临界值8，如果大于则将链表转换为红黑树，转换红黑树的方法  treeifyBin，整体代码如下：</p>
<pre><code class="java">if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
   //转换为红黑树 tab表示数组名  hash表示哈希值
   treeifyBin(tab, hash);
</code></pre>
<p>treeifyBin方法如下所示：</p>
<pre><code class="java">  /**
   * Replaces all linked nodes in bin at index for given hash unless
   * table is too small, in which case resizes instead.
     替换指定哈希表的索引处桶中的所有链接节点，除非表太小，否则将修改大小。
     Node&lt;K,V&gt;[] tab = tab 数组名
     int hash = hash表示哈希值
  */
    final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) &#123;
        int n, index; Node&lt;K,V&gt; e;
        /*
            如果当前数组为空或者数组的长度小于进行树形化的阈值(MIN_TREEIFY_CAPACITY = 64),
            就去扩容。而不是将节点变为红黑树。
            目的：如果数组很小，那么转换红黑树，然后遍历效率要低一些。这时进行扩容，那么重新计算哈希值
            ，链表长度有可能就变短了，数据会放到数组中，这样相对来说效率高一些。
        */
        if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)
            //扩容方法
            resize();
        else if ((e = tab[index = (n - 1) &amp; hash]) != null) &#123;
            /*
                1）执行到这里说明哈希表中的数组长度大于阈值64，开始进行树形化
                2）e = tab[index = (n - 1) &amp; hash]表示将数组中的元素取出赋值给e,e是哈希表中指定位                    置桶里的链表节点，从第一个开始
            */
            //hd：红黑树的头结点   tl :红黑树的尾结点
            TreeNode&lt;K,V&gt; hd = null, tl = null;
            do &#123;
                //新创建一个树的节点，内容和当前链表节点e一致
                TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null);
                if (tl == null)
                    //将新创键的p节点赋值给红黑树的头结点
                    hd = p;
                else &#123;
                    /*
                         p.prev = tl：将上一个节点p赋值给现在的p的前一个节点
                         tl.next = p;将现在节点p作为树的尾结点的下一个节点
                    */
                    p.prev = tl;
                    tl.next = p;
                &#125;
                tl = p;
                /*
                    e = e.next 将当前节点的下一个节点赋值给e,如果下一个节点不等于null
                    则回到上面继续取出链表中节点转换为红黑树
                */
            &#125; while ((e = e.next) != null);
            /*
                让桶中的第一个元素即数组中的元素指向新建的红黑树的节点，以后这个桶里的元素就是红黑树
                而不是链表数据结构了
            */
            if ((tab[index] = hd) != null)
                hd.treeify(tab);
        &#125;
    &#125;
</code></pre>
<p>小结：上述操作一共做了如下几件事：</p>
<p>1.根据哈希表中元素个数确定是扩容还是树形化</p>
<p>2.如果是树形化遍历桶中的元素，创建相同个数的树形节点，复制内容，建立起联系</p>
<p>3.然后让桶中的第一个元素指向新创建的树根节点，替换桶的链表内容为树形化内容</p>
<h4 id="4-3-3扩容方法-resize"><a href="#4-3-3扩容方法-resize" class="headerlink" title="4.3.3扩容方法_resize"></a>4.3.3扩容方法_resize</h4><h5 id="4-3-3-1扩容机制"><a href="#4-3-3-1扩容机制" class="headerlink" title="4.3.3.1扩容机制"></a>4.3.3.1扩容机制</h5><p>想要了解HashMap的扩容机制你要有这两个问题</p>
<ul>
<li>1.什么时候才需要扩容</li>
<li>2.HashMap的扩容是什么</li>
</ul>
<p><strong>1.什么时候才需要扩容</strong></p>
<p>当HashMap中的元素个数超过数组大小(数组长度)*loadFactor(负载因子)时，就会进行数组扩容，loadFactor的默认值(DEFAULT_LOAD_FACTOR)是0.75,这是一个折中的取值。也就是说，默认情况下，数组大小为16，那么当HashMap中的元素个数超过16×0.75&#x3D;12(这个值就是阈值或者边界值threshold值)的时候，就把数组的大小扩展为2×16&#x3D;32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常耗性能的操作，所以如果我们已经预知HashMap中元素的个数，那么预知元素的个数能够有效的提高HashMap的性能。</p>
<p><strong>补充：</strong></p>
<p><strong>当HashMap中的其中一个链表的对象个数如果达到了8个，此时如果数组长度没有达到64，那么HashMap会先扩容解决，如果已经达到了64，那么这个链表会变成红黑树，节点类型由Node变成TreeNode类型。当然，如果映射关系被移除后，下次执行resize方法时判断树的节点个数低于6，也会再把树转换为链表。</strong></p>
<p><strong>2.HashMap的扩容是什么</strong></p>
<p> 进行扩容，会伴随着一次重新hash分配，并且会遍历hash表中所有的元素，是非常耗时的。在编写程序中，要尽量避免resize。 </p>
<p>HashMap在进行扩容时，使用的rehash方式非常巧妙，因为每次扩容都是翻倍，与原来计算的 (n-1)&amp;hash的结果相比，只是多了一个bit位，所以节点要么就在原来的位置，要么就被分配到”<strong>原位置+旧容量</strong>“这个位置。</p>
<p> 怎么理解呢？例如我们从16扩展为32时，具体的变化如下所示： </p>
<p><img src="/2022/03/22/HashMap%E7%9F%A5%E8%AF%86%E7%82%B9/image-20191117110812839.png" alt="image-20191117110812839"></p>
<p> 因此元素在重新计算hash之后，因为n变为2倍，那么n-1的标记范围在高位多1bit(红色)，因此新的index就会发生这样的变化： </p>
<p><img src="/2022/03/22/HashMap%E7%9F%A5%E8%AF%86%E7%82%B9/image-20191117110934974.png" alt="image-20191117110934974"></p>
<p>说明：5是假设计算出来的原来的索引。这样就验证了上述所描述的：扩容之后所以节点要么就在原来的位置，要么就被分配到”<strong>原位置+旧容量</strong>“这个位置。</p>
<p> 因此，我们在扩充HashMap的时候，不需要重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就可以了，是0的话索引没变，是1的话索引变成“原索引+oldCap(<strong>原位置+旧容量</strong>)”。可以看看下图为16扩充为32的resize示意图： </p>
<p><img src="/2022/03/22/HashMap%E7%9F%A5%E8%AF%86%E7%82%B9/image-20191117111211630.png" alt="image-20191117111211630"></p>
<p>正是因为这样巧妙的rehash方式，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，在resize的过程中保证了rehash之后每个桶上的节点数一定小于等于原来桶上的节点数，保证了rehash之后不会出现更严重的hash冲突，均匀的把之前的冲突的节点分散到新的桶中了。</p>
<h5 id="4-3-3-2源码resize方法的解读"><a href="#4-3-3-2源码resize方法的解读" class="headerlink" title="4.3.3.2源码resize方法的解读"></a>4.3.3.2源码resize方法的解读</h5><p>下面是代码的具体实现：</p>
<pre><code class="java">final Node&lt;K,V&gt;[] resize() &#123;
    //得到当前数组
    Node&lt;K,V&gt;[] oldTab = table;
    //如果当前数组等于null长度返回0，否则返回当前数组的长度
    int oldCap = (oldTab == null) ? 0 : oldTab.length;
    //当前阀值点 默认是12(16*0.75)
    int oldThr = threshold;
    int newCap, newThr = 0;
    //如果老的数组长度大于0
    //开始计算扩容后的大小
    if (oldCap &gt; 0) &#123;
        // 超过最大值就不再扩充了，就只好随你碰撞去吧
        if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;
            //修改阈值为int的最大值
            threshold = Integer.MAX_VALUE;
            return oldTab;
        &#125;
        /*
            没超过最大值，就扩充为原来的2倍
            1)(newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY 扩大到2倍之后容量要小于最大容量
            2）oldCap &gt;= DEFAULT_INITIAL_CAPACITY 原数组长度大于等于数组初始化长度16
        */
        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;
                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)
            //阈值扩大一倍
            newThr = oldThr &lt;&lt; 1; // double threshold
    &#125;
    //老阈值点大于0 直接赋值
    else if (oldThr &gt; 0) // 老阈值赋值给新的数组长度
        newCap = oldThr;
    else &#123;// 直接使用默认值
        newCap = DEFAULT_INITIAL_CAPACITY;//16
        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
    &#125;
    // 计算新的resize最大上限
    if (newThr == 0) &#123;
        float ft = (float)newCap * loadFactor;
        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?
                  (int)ft : Integer.MAX_VALUE);
    &#125;
    //新的阀值 默认原来是12 乘以2之后变为24
    threshold = newThr;
    //创建新的哈希表
    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)
    //newCap是新的数组长度--》32
    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];
    table = newTab;
    //判断旧数组是否等于空
    if (oldTab != null) &#123;
        // 把每个bucket都移动到新的buckets中
        //遍历旧的哈希表的每个桶，重新计算桶里元素的新位置
        for (int j = 0; j &lt; oldCap; ++j) &#123;
            Node&lt;K,V&gt; e;
            if ((e = oldTab[j]) != null) &#123;
                //原来的数据赋值为null 便于GC回收
                oldTab[j] = null;
                //判断数组是否有下一个引用
                if (e.next == null)
                    //没有下一个引用，说明不是链表，当前桶上只有一个键值对，直接插入
                    newTab[e.hash &amp; (newCap - 1)] = e;
                //判断是否是红黑树
                else if (e instanceof TreeNode)
                    //说明是红黑树来处理冲突的，则调用相关方法把树分开
                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);
                else &#123; // 采用链表处理冲突
                    Node&lt;K,V&gt; loHead = null, loTail = null;
                    Node&lt;K,V&gt; hiHead = null, hiTail = null;
                    Node&lt;K,V&gt; next;
                    //通过上述讲解的原理来计算节点的新位置
                    do &#123;
                        // 原索引
                        next = e.next;
                         //这里来判断如果等于true e这个节点在resize之后不需要移动位置
                        if ((e.hash &amp; oldCap) == 0) &#123;
                            if (loTail == null)
                                loHead = e;
                            else
                                loTail.next = e;
                            loTail = e;
                        &#125;
                        // 原索引+oldCap
                        else &#123;
                            if (hiTail == null)
                                hiHead = e;
                            else
                                hiTail.next = e;
                            hiTail = e;
                        &#125;
                    &#125; while ((e = next) != null);
                    // 原索引放到bucket里
                    if (loTail != null) &#123;
                        loTail.next = null;
                        newTab[j] = loHead;
                    &#125;
                    // 原索引+oldCap放到bucket里
                    if (hiTail != null) &#123;
                        hiTail.next = null;
                        newTab[j + oldCap] = hiHead;
                    &#125;
                &#125;
            &#125;
        &#125;
    &#125;
    return newTab;
&#125;
</code></pre>
<h4 id="4-3-4-删除方法-remove"><a href="#4-3-4-删除方法-remove" class="headerlink" title="4.3.4 删除方法(remove)"></a>4.3.4 删除方法(remove)</h4><p> 理解了put方法之后，remove方法已经没什么难度了，所以重复的内容就不再做详细介绍了。</p>
<p> 删除的话就是首先先找到元素的位置，如果是链表就遍历链表找到元素之后删除。如果是用红黑树就遍历树然后找到之后做删除，树小于6的时候要转链表。 </p>
<p> 删除remove方法： </p>
<pre><code class="java">//remove方法的具体实现在removeNode方法中，所以我们重点看下removeNode方法
public V remove(Object key) &#123;
        Node&lt;K,V&gt; e;
        return (e = removeNode(hash(key), key, null, false, true)) == null ?
            null : e.value;
    &#125;
</code></pre>
<p> removeNode方法： </p>
<pre><code class="java">final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value,
                               boolean matchValue, boolean movable) &#123;
        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index;
        //根据hash找到位置 
        //如果当前key映射到的桶不为空
        if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;
            (p = tab[index = (n - 1) &amp; hash]) != null) &#123;
            Node&lt;K,V&gt; node = null, e; K k; V v;
            //如果桶上的节点就是要找的key，则将node指向该节点
            if (p.hash == hash &amp;&amp;
                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
                node = p;
            else if ((e = p.next) != null) &#123;
                //说明节点存在下一个节点
                if (p instanceof TreeNode)
                    //说明是以红黑树来处理的冲突，则获取红黑树要删除的节点
                    node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);
                else &#123;
                    //判断是否以链表方式处理hash冲突，是的话则通过遍历链表来寻找要删除的节点
                    do &#123;
                        if (e.hash == hash &amp;&amp;
                            ((k = e.key) == key ||
                             (key != null &amp;&amp; key.equals(k)))) &#123;
                            node = e;
                            break;
                        &#125;
                        p = e;
                    &#125; while ((e = e.next) != null);
                &#125;
            &#125;
            //比较找到的key的value和要删除的是否匹配
            if (node != null &amp;&amp; (!matchValue || (v = node.value) == value ||
                                 (value != null &amp;&amp; value.equals(v)))) &#123;
                //通过调用红黑树的方法来删除节点
                if (node instanceof TreeNode)
                    ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable);
                else if (node == p)
                    //链表删除
                    tab[index] = node.next;
                else
                    p.next = node.next;
                //记录修改次数
                ++modCount;
                //变动的数量
                --size;
                afterNodeRemoval(node);
                return node;
            &#125;
        &#125;
        return null;
    &#125;
</code></pre>
<h4 id="4-3-5查找元素方法-get"><a href="#4-3-5查找元素方法-get" class="headerlink" title="4.3.5查找元素方法(get)"></a>4.3.5查找元素方法(get)</h4><p> 查找方法，通过元素的Key找到Value。 </p>
<p>代码如下：</p>
<pre><code class="java">public V get(Object key) &#123;
    Node&lt;K,V&gt; e;
    return (e = getNode(hash(key), key)) == null ? null : e.value;
&#125;
</code></pre>
<p>get方法主要调用的是getNode方法，代码如下：</p>
<pre><code class="java">final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;
    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;
    //如果哈希表不为空并且key对应的桶上不为空
    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;
        (first = tab[(n - 1) &amp; hash]) != null) &#123;
        /* 
            判断数组元素是否相等
            根据索引的位置检查第一个元素
            注意：总是检查第一个元素
        */
        if (first.hash == hash &amp;&amp; // always check first node
            ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))
            return first;
        // 如果不是第一个元素，判断是否有后续节点
        if ((e = first.next) != null) &#123;
            // 判断是否是红黑树，是的话调用红黑树中的getTreeNode方法获取节点
            if (first instanceof TreeNode)
                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);
            do &#123;
                // 不是红黑树的话，那就是链表结构了，通过循环的方法判断链表中是否存在该key
                if (e.hash == hash &amp;&amp;
                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                    return e;
            &#125; while ((e = e.next) != null);
        &#125;
    &#125;
    return null;
&#125;
</code></pre>
<p>小结：</p>
<p>1.get方法实现的步骤：</p>
<p>​    1）通过hash值获取该key映射到的桶</p>
<p>​    2）桶上的key就是要查找的key,则直接找到并返回</p>
<p>​    3）桶上的key不是要找的key,则查看后续的节点：</p>
<p>​            a:如果后续节点是红黑树节点，通过调用红黑树的方法根据key获取value</p>
<p>​            b:如果后续节点是链表节点，则通过循环遍历链表根据key获取value</p>
<p>2.上述红黑树节点调用的是getTreeNode方法通过树形节点的find方法进行查找：</p>
<pre><code class="java"> final TreeNode&lt;K,V&gt; getTreeNode(int h, Object k) &#123;
            return ((parent != null) ? root() : this).find(h, k, null);
 &#125;
 final TreeNode&lt;K,V&gt; find(int h, Object k, Class&lt;?&gt; kc) &#123;
            TreeNode&lt;K,V&gt; p = this;
            do &#123;
                int ph, dir; K pk;
                TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q;
                if ((ph = p.hash) &gt; h)
                    p = pl;
                else if (ph &lt; h)
                    p = pr;
                else if ((pk = p.key) == k || (k != null &amp;&amp; k.equals(pk)))
                    return p;//找到之后直接返回
                else if (pl == null)
                    p = pr;
                else if (pr == null)
                    p = pl;
                else if ((kc != null ||
                          (kc = comparableClassFor(k)) != null) &amp;&amp;
                         (dir = compareComparables(kc, k, pk)) != 0)
                    p = (dir &lt; 0) ? pl : pr;
                //递归查找
                else if ((q = pr.find(h, k, kc)) != null)
                    return q;
                else
                    p = pl;
            &#125; while (p != null);
            return null;
        &#125;
</code></pre>
<p>3.查找红黑树，由于之前添加时已经保证这个树是有序的了，因此查找时基本就是折半查找，效率更高。</p>
<p>4.这里和插入时一样，如果对比节点的哈希值和要查找的哈希值相等，就会判断key是否相等，相等就直接返回。不相等就从子树中递归查找。</p>
<ol start="5">
<li></li>
</ol>
<p>​    若为树，则在树中通过key.equals(k)查找，O(logn) </p>
<p>​    若为链表，则在链表中通过key.equals(k)查找，O(n)。</p>
<h4 id="4-3-6遍历HashMap集合几种方式"><a href="#4-3-6遍历HashMap集合几种方式" class="headerlink" title="4.3.6遍历HashMap集合几种方式"></a>4.3.6遍历HashMap集合几种方式</h4><p> 1、分别遍历Key和Values </p>
<p><img src="/2022/03/22/HashMap%E7%9F%A5%E8%AF%86%E7%82%B9/image-20191117160455507.png" alt="image-20191117160455507"></p>
<p>2、使用Iterator迭代器迭代 </p>
<p><img src="/2022/03/22/HashMap%E7%9F%A5%E8%AF%86%E7%82%B9/image-20191117160627369.png" alt="image-20191117160627369"></p>
<p>3、通过get方式（不建议使用）</p>
<p><img src="/2022/03/22/HashMap%E7%9F%A5%E8%AF%86%E7%82%B9/image-20191117160733756.png" alt="image-20191117160733756"></p>
<p>说明：根据阿里开发手册，不建议使用这种方式，因为迭代两次。keySet获取Iterator一次，还有通过get又迭代一次。降低性能。</p>
<p>4.jdk8以后使用Map接口中的默认方法：</p>
<pre><code>default void forEach(BiConsumer&lt;? super K,? super V&gt; action) 
BiConsumer接口中的方法：
    void accept​(T t, U u) 对给定的参数执行此操作。  
        参数 
            t - 第一个输入参数 
            u - 第二个输入参数 
</code></pre>
<p>遍历代码：</p>
<pre><code class="java">public class Demo02 &#123;
    public static void main(String[] args) &#123;
        HashMap&lt;String,String&gt; m1 = new HashMap();
        m1.put(&quot;001&quot;, &quot;zhangsan&quot;);
        m1.put(&quot;002&quot;, &quot;lisi&quot;);
        m1.forEach((key,value)-&gt;&#123;
            System.out.println(key+&quot;---&quot;+value);
        &#125;);
    &#125;
&#125;
</code></pre>
<h2 id="5-如何设计多个非重复的键值对要存储HashMap的初始化？"><a href="#5-如何设计多个非重复的键值对要存储HashMap的初始化？" class="headerlink" title="5.如何设计多个非重复的键值对要存储HashMap的初始化？"></a>5.如何设计多个非重复的键值对要存储HashMap的初始化？</h2><h3 id="5-1HashMap的初始化问题描述"><a href="#5-1HashMap的初始化问题描述" class="headerlink" title="5.1HashMap的初始化问题描述"></a>5.1HashMap的初始化问题描述</h3><p>​    如果我们确切的知道我们有多少键值对需要存储，那么我们在初始化HashMap的时候就应该指定它的容量，以防止HashMap自动扩容，影响使用效率。</p>
<p>​    默认情况下HashMap的容量是16，但是，如果用户通过构造函数指定了一个数字作为容量，那么Hash会选择大于该数字的第一个2的幂作为容量。(3-&gt;4、7-&gt;8、9-&gt;16) .这点我们在上述已经进行过讲解。</p>
<p> 《阿里巴巴Java开发手册》中建议我们设置HashMap的初始化容量。 </p>
<p><img src="/2022/03/22/HashMap%E7%9F%A5%E8%AF%86%E7%82%B9/2.bmp" alt="image-20191117164748836"></p>
<p> 那么，为什么要这么建议？你有想过没有。 </p>
<p>当然，以上建议也是有理论支撑的。我们上面介绍过，HashMap的扩容机制，就是当达到扩容条件时会进行扩容。HashMap的扩容条件就是当HashMap中的元素个数（size）超过临界值（threshold）时就会自动扩容。在HashMap中，threshold &#x3D; loadFactor * capacity。</p>
<p>所以，如果我们没有设置初始容量大小，随着元素的不断增加，HashMap会有可能发生多次扩容，而HashMap中的扩容机制决定了每次扩容都需要重建hash表，是非常影响性能的。</p>
<p>但是设置初始化容量，设置的数值不同也会影响性能，那么当我们已知HashMap中即将存放的KV个数的时候，容量设置成多少为好呢？</p>
<h3 id="5-2HashMap中容量的初始化"><a href="#5-2HashMap中容量的初始化" class="headerlink" title="5.2HashMap中容量的初始化"></a>5.2HashMap中容量的初始化</h3><p>当我们使用HashMap(int initialCapacity)来初始化容量的时候，jdk会默认帮我们计算一个相对合理的值当做初始容量。那么，是不是我们只需要把已知的HashMap中即将存放的元素个数直接传给initialCapacity就可以了呢？</p>
<p>关于这个值的设置，在《阿里巴巴Java开发手册》有以下建议：</p>
<p><img src="/2022/03/22/HashMap%E7%9F%A5%E8%AF%86%E7%82%B9/image-20191117165438726.png" alt="image-20191117165438726"></p>
<p>也就是说，如果我们设置的默认值是7，经过Jdk处理之后，会被设置成8，但是，这个HashMap在元素个数达到 8*0.75 &#x3D; 6的时候就会进行一次扩容，这明显是我们不希望见到的。我们应该尽量减少扩容。原因也已经分析过。</p>
<p>如果我们通过<strong>initialCapacity&#x2F; 0.75F + 1.0F</strong>计算，7&#x2F;0.75 + 1 &#x3D; 10 ,10经过Jdk处理之后，会被设置成16，这就大大的减少了扩容的几率。</p>
<p>当HashMap内部维护的哈希表的容量达到75%时（默认情况下），会触发rehash，而rehash的过程是比较耗费时间的。所以初始化容量要设置成<strong>initialCapacity&#x2F;0.75 + 1</strong>的话，可以有效的减少冲突也可以减小误差。</p>
<p>所以，我可以认为，当我们明确知道HashMap中元素的个数的时候，把默认容量设置成<strong>initialCapacity&#x2F; 0.75F + 1.0F</strong>是一个在性能上相对好的选择，但是，同时也会牺牲些内存。</p>
<p>我们想要在代码中创建一个HashMap的时候，如果我们已知这个Map中即将存放的元素个数，给HashMap设置初始容量可以在一定程度上提升效率。</p>
<p>但是，JDK并不会直接拿用户传进来的数字当做默认容量，而是会进行一番运算，最终得到一个2的幂。原因也已经分析过。</p>
<p>但是，为了最大程度的避免扩容带来的性能消耗，我们建议可以把默认容量的数字设置成<strong>initialCapacity&#x2F; 0.75F + 1.0F</strong>。</p>
]]></content>
      <categories>
        <category>HashMap</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>HashMap</tag>
        <tag>集合</tag>
      </tags>
  </entry>
</search>
